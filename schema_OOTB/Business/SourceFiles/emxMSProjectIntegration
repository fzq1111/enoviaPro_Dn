// ${CLASSNAME}.java
//
// Copyright (c) 2001-2015 Dassault Systemes.
//
// $Log: ${CLASSNAME}.java,v $
// Revision 10.6.3.0  9/26/2006
// for supporting resource allocation
// PMC MSP Integration
// @quickReview 16:02:23 AMA3 FUN058265 Multiple Calendars Integration

import java.io.StringReader;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import matrix.db.AccessConstants;
import matrix.db.Context;
import matrix.db.JPO;
import matrix.db.RelationshipType;
import matrix.util.MatrixException;
import matrix.util.Pattern;
import matrix.util.StringList;

import com.matrixone.apps.common.Person;
import com.matrixone.apps.common.SubtaskRelationship;
//import com.matrixone.apps.common.WorkCalendar;
import com.matrixone.apps.domain.DomainConstants;
import com.matrixone.apps.domain.DomainObject;
import com.matrixone.apps.domain.DomainRelationship;
import com.matrixone.apps.domain.util.ContextUtil;
import com.matrixone.apps.domain.util.EnoviaResourceBundle;
import com.matrixone.apps.domain.util.FrameworkException;
import com.matrixone.apps.domain.util.MapList;
import com.matrixone.apps.domain.util.MqlUtil;
import com.matrixone.apps.domain.util.PersonUtil;
import com.matrixone.apps.domain.util.PropertyUtil;
import com.matrixone.apps.domain.util.eMatrixDateFormat;
import com.matrixone.apps.framework.ui.UITable;
import com.matrixone.apps.program.ProgramCentralConstants;
import com.matrixone.apps.program.ProgramCentralUtil;
import com.matrixone.apps.program.ProjectSpace;
import com.matrixone.apps.program.Task;
import com.matrixone.jdom.Document;
import com.matrixone.jdom.Element;
import com.matrixone.jdom.input.SAXBuilder;
import com.matrixone.jdom.output.XMLOutputter;

/**
 * The <code>emxMSProjectIntegration</code> class represents the JPO for the MS
 * Project integration synchronization mechanism
 */
public class ${CLASSNAME} extends ProjectSpace {

	public static final String RELATIONSHIP_SUBTASK = PropertyUtil.getSchemaProperty("relationship_Subtask");

	// cache map of person "lastname firstname" and personId
	private static Hashtable _personInfo = new Hashtable();
	//private StringList ProjectspaceSubtypes = null;
	private StringList ProjectIds = new StringList();
	private StringList AllOldProjectIds = new StringList();

	private static final String SELECT_ATTRIBUTE_PROJECT_SCHEDULE_FROM = "attribute[" + ATTRIBUTE_PROJECT_SCHEDULE_FROM	+ "]";
	//private static final String SELECT_ATTRIBUTE_DEFAULT_CONSTRAINT_TYPE = "attribute["	+ ATTRIBUTE_DEFAULT_CONSTRAINT_TYPE + "]";
	private static final String SELECT_TO_RELATIONSHIP_SUBTASK_ID = "to[" + RELATIONSHIP_SUBTASK + "].id";
	private static final String ATTRIBUTE_SCHEDULEBASEDON = (String) PropertyUtil.getSchemaProperty("attribute_ScheduleBasedOn");
	public static final String SELECT_ATTRIBUTE_SCHEDULEBASEDON = "attribute[" + (String)PropertyUtil.getSchemaProperty("attribute_ScheduleBasedOn") + "]";
	//private static final String SELECT_DEFAULT_CALENDAR = "from["+ ProgramCentralConstants.RELATIONSHIP_DEFAULT_CALENDAR + "].to.id";

	String SELECT_TASK_ASSIGNEE_NAME = "to[" + ProgramCentralConstants.RELATIONSHIP_ASSIGNED_TASKS + "].from.name";
	String SELECT_TASK_ASSIGNEE_ID = "to[" + ProgramCentralConstants.RELATIONSHIP_ASSIGNED_TASKS + "].from.id";
	String SELECT_RELATIONSHIP_CONNECTION_ID = "to[" + ProgramCentralConstants.RELATIONSHIP_ASSIGNED_TASKS + "].id";
	String SELECT_ASSIGNEE_LAST_NAME = "to[" + ProgramCentralConstants.RELATIONSHIP_ASSIGNED_TASKS + "].from."  + getAttributeSelect(ATTRIBUTE_LAST_NAME);
	String SELECT_ASSIGNEE_FIRST_NAME = "to[" + ProgramCentralConstants.RELATIONSHIP_ASSIGNED_TASKS + "].from."  + getAttributeSelect(ATTRIBUTE_FIRST_NAME);
	String SELECT_ASSIGNEE_EMAIL_ADDR = "to[" + ProgramCentralConstants.RELATIONSHIP_ASSIGNED_TASKS + "].from."  + getAttributeSelect(ATTRIBUTE_EMAIL_ADDRESS);
	//String SELECT_TASK_CALENDAR = "from[" + ProgramCentralConstants.RELATIONSHIP_CALENDAR +"].to.id";
	RelationshipType relSubTask = new RelationshipType(RELATIONSHIP_SUBTASK);

	String xmlForClient = "";
	String sProjectSchduleBasedOn = "";

	ProjectSpace project = null;
	ProjectSpace subProject = null;
	com.matrixone.apps.common.DependencyRelationship dependency = null;
	Task task = null;
	Task parentTask = null;
	Person person = new Person();
	com.matrixone.apps.common.AssignedTasksRelationship assignee = null;

	/** This flag should be used to Turn Debugging On in the JPO
	 *  this will enable the system.out messages to fire which allow for better debugging.
	 *  This should not be set to "true" in production systems as it can be a performance bottleneck
	 *
	 *  true - enable debugging
	 *  false - disable debugging (default)
	 */

	boolean debug = false;

	SubtaskRelationship subtask = null;

	// counters and indexmaps
	StringList projectList = new StringList();
	Map taskIndexMap = new HashMap();
	Map taskParentMap = new HashMap();
	Map tasktypeDefaultPolicyMap = new HashMap(); // [: for caching the default task policy]
	String codeRegn = "";

	SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'TO'H:mm:ss");
	SimpleDateFormat MATRIX_DATE_FORMAT = new SimpleDateFormat(eMatrixDateFormat.getEMatrixDateFormat(), Locale.US);

	// JPO version
	public static String strMSPJPOVersion = "V6R2016x";

	public long mergeStartTime = 0;
	public long mergeEndTime = 0;

	public long StartValidateResourceTime = 0;
	public long EndValidateResourceTime = 0;

	public long xmlfileGen_BeginTime = 0;
	public long xmlfileGen_EndTime = 0;

	public long xmlDataForMerge_BeginTime = 0;
	public long xmlDataForMerge_EndTime = 0;

	public long getTaskStructure_startTime = 0;
	public long getTaskStructure_endTime = 0;

	public long addAssignees_startTime = 0;
	public long addAssignees_endTime = 0;

	// Iteration for each new added task
	public long iterationStartTime = 0;
	public long iterationEndTime = 0;

	public long ifTaskCreate = 0;
	public long ifTaskCreated = 0;

	Map tasks = null;
	StringList slProjectSpaceSubTypes;
	StringList slProjectTaskSubTypes;

	Context m_ctxUserContext = null;
	String userLanguage = "en";

	static StringList projectSelectable = new StringList();
	static Map<String, Map> projectColAttrMap = new HashMap<String,Map>();
	static StringList taskSelectable = new StringList();
	static StringList taskRelSelectable = new StringList();
	static Map<String, Map> taskColAttrMap = new HashMap<String,Map>();
	
	//Needed to filter the data according to the type specific attributes based upon column name
	static Map<String, String> taskColNameBusAttrMap = new HashMap<String,String>();
	
	//Needed to filter the data according to the type specific attributes based upon column name
	static Map<String, String> taskColNameRelAttrMap = new HashMap<String,String>();
	
	//ignore basic attributes as specific API is called for each basic attribute
	final StringList basicfieldsToIgnoreInSave = new StringList(new String[] {"Name", "Description", "Owner", "State","NodeType", "Title", "CreationDate"});

	//following fields need to pass in updateDates() and other attributes needs to pass in setAttributeValues
	final StringList scheduleFieldsInSave = new StringList(new String[] {"ConstraintType" , "ConstraintDate" , "Duration" , 
			"Start" , "Finish", "ActualStart", "ActualFinish", "PercentComplete"});

	HashMap<String, String> GetConstraintNameMap = new HashMap<String, String>() {
		{
			put("0", "As Soon As Possible");
			put("1", "As Late As Possible");
			put("2", "Must Start On");
			put("3", "Must Finish On");
			put("4", "Start No Earlier Than");
			put("5", "Start No Later Than");
			put("6", "Finish No Earlier Than");
			put("7", "Finish No Later Than");
		}
	};

	HashMap<String, String> GetConstraintConstantMap = new HashMap<String, String>() {
		{
			put("As Soon As Possible", "0");
			put("As Late As Possible", "1");
			put("Must Start On", "2");
			put("Must Finish On", "3");
			put("Start No Earlier Than", "4");
			put("Start No Later Than", "5");
			put("Finish No Earlier Than", "6");
			put("Finish No Later Than", "7");
		}
	};

	public ${CLASSNAME} ()
	{
		//Do nothing
	}

	/**
	 * Constructs a new emxMSProjectIntegration JPO object.
	 *
	 * @param context the eMatrix <code>Context</code> object
	 * @param args an array of String arguments for this method
	 * @throws Exception if the operation fails
	 * @since AEF 10.0.0.0
	 */
	public ${CLASSNAME}(Context context, String[] args) throws Exception {

		super(); // Call the super constructor
		m_ctxUserContext = context;

		// instantiate beans
		dependency = (com.matrixone.apps.common.DependencyRelationship) DomainRelationship.newInstance(m_ctxUserContext, DomainConstants.RELATIONSHIP_DEPENDENCY);
		task = (Task) DomainObject.newInstance(m_ctxUserContext, DomainConstants.TYPE_TASK, DomainConstants.PROGRAM);
		parentTask = (Task) DomainObject.newInstance(m_ctxUserContext, DomainConstants.TYPE_TASK, DomainConstants.PROGRAM);
		project = (ProjectSpace) DomainObject.newInstance(m_ctxUserContext, DomainConstants.TYPE_PROJECT_SPACE, DomainConstants.PROGRAM);
		subProject = (ProjectSpace) DomainObject.newInstance(m_ctxUserContext, DomainConstants.TYPE_PROJECT_SPACE, DomainConstants.PROGRAM);

		if(tasktypeDefaultPolicyMap.isEmpty()) {
			String taskPolicy = task.getDefaultPolicy(context,DomainConstants.TYPE_TASK);
			tasktypeDefaultPolicyMap.put(DomainConstants.TYPE_TASK, taskPolicy);
		}
		
		slProjectSpaceSubTypes = ProgramCentralUtil.getSubTypesList(context, DomainConstants.TYPE_PROJECT_SPACE);
		slProjectTaskSubTypes = ProgramCentralUtil.getTaskSubTypesList(context);

		//instantiate mapping of project and tasks fields
		SetProjectTasksMapping("MPIProjectColumnMapping", projectSelectable, projectColAttrMap, false);
		SetProjectTasksMapping("MPITaskColumnMapping", taskSelectable, taskColAttrMap, true);
	}

	public String mxMain(Context context, String[] args) throws Exception {
		return "";
	}

	private void SetProjectTasksMapping(String tableName, StringList selectableList,  Map<String, Map> columnAttrMap, boolean forTask) 
			throws Exception {

		try {
			HashMap tableMap = UITable.getTable(m_ctxUserContext, tableName);

			MapList colList = UITable.getColumns(tableMap);

			Iterator columnsItr = colList.iterator();

			selectableList.clear();
			columnAttrMap.clear();

			while(columnsItr.hasNext()) {

				Map columnSettingMap = new HashMap();

				HashMap columnMap = (HashMap) columnsItr.next();

				String columnName = UITable.getName(columnMap);

				columnSettingMap.put("Name", columnName);

				String columnTypeDetail = UITable.getSetting(columnMap, "MPIColumnType");
				String ignoreForServer = UITable.getSetting(columnMap, "MPIIgnoreForServer");

				String columnExpr = (String)columnMap.get("expression_businessobject");
				String columnRelExpr = ""; 

				if(columnExpr == null && ignoreForServer == "") {
					columnRelExpr = (String)columnMap.get("expression_relationship");
					if(!taskRelSelectable.contains(columnRelExpr))
						taskRelSelectable.add(columnRelExpr);
					columnAttrMap.put(columnRelExpr, columnSettingMap);

					if(forTask)
						taskColNameRelAttrMap.put(columnName,columnRelExpr);
				}
				if(columnExpr != null && !columnExpr.equals("")) {

					if(columnTypeDetail != "")
						columnSettingMap.put("MPIColumnType", columnTypeDetail);

					if(ignoreForServer != "")
						columnSettingMap.put("MPIIgnoreForServer", ignoreForServer);

					columnAttrMap.put(columnExpr, columnSettingMap);
					selectableList.add(columnExpr);

					if(forTask)
						taskColNameBusAttrMap.put(columnName, columnExpr);
				}
			}
		}
		catch(Exception e) {
			throw new Exception(e.getMessage());
		}
	}

	
	/**
	 * Returns the modified task Attribute Selectables List based upon the typeName filter
	 *
	 * @param typeName 
	 * @param taskBusSelect To store bus selects
	 * @param taskRelSelect  To store relationships selects
	 * @throws Exception if the operation fails
	 */
	private void GetTypeSpecificTaskSelectables(Context context,String typeName, StringList taskBusSelect, StringList taskRelSelect) throws MatrixException
	{
		StringList typeSpecificList = (StringList)JPO.invoke(context, "MSFUtil", null, "GetTypeSpecificAttributeList", new String[] {typeName}, StringList.class);

		if(typeSpecificList == null || typeSpecificList.size() == 0)
			return;

		for(int iItr = 0; iItr < typeSpecificList.size(); iItr++)
		{
			String name = (String)typeSpecificList.elementAt(iItr);

			String busSelectExpr = (String)taskColNameBusAttrMap.get(name);
			if(busSelectExpr != null)
			{
				taskBusSelect.addElement(busSelectExpr);
			}
			else
			{
				String relSelectExpr =(String)taskColNameRelAttrMap.get(name);
				if(relSelectExpr != null)
				{
					taskRelSelect.addElement(relSelectExpr);
				}
			}
		}
	}
	
	public StringList GetProjectSpaceSubTypes(Context context, String[] args) throws MatrixException {
		
		return slProjectSpaceSubTypes;
	}
	
	/**
	 * Checks out a Project Space for synchronization.
	 * Generates XML string representing the Project Space and is downloaded
	 * on the client desktop where MS Project resides
	 *
	 * @param busid String value of the BusID identifying the Project Space object
	 * @throws Exception if the operation fails
	 */
	public String executeFindForCheckout(Context context, String[] args) throws MatrixException {

		try {
			codeRegn = "Inside executeFindForCheckout";

			if (debug) {
				System.out.println("================ START executeFindForCheckout ================");
				xmlfileGen_BeginTime = System.currentTimeMillis();
			}
			Element elCommandRoot = loadXMLSentFromServlet(args[0]);

			// create the response placeholder
			Element elResponseRoot = new Element("transaction");
			elResponseRoot.setAttribute("cname", elCommandRoot.getAttributeValue("cname"));

			// get bus id and project xml
			String strBusId = "";
			Element elCommandArguments = elCommandRoot.getChild("arguments");
			List lArguments = elCommandArguments.getChildren("argument");
			ListIterator litCtr = lArguments.listIterator();
			Element elProjectRoot = null;
			String strEditStatus = "";

			while (litCtr.hasNext()) {
				Element elArgument = (Element) litCtr.next();

				if (elArgument.getAttributeValue("name").equals("busid")) {
					strBusId = elArgument.getText();
				}

				if (elArgument.getAttributeValue("name").equals("foredit")) {
					strEditStatus = elArgument.getText();
				}
			}

			codeRegn = "Project XML and BusID got.";
			if (debug) 
				System.out.println(codeRegn);

			// now create placeholder for response
			Element elResponseArgumentsNode = new Element("arguments");
			elResponseRoot.addContent(elResponseArgumentsNode);

			// create the busid argument placeholder
			Element elBusIdArgument = new Element("argument");
			elBusIdArgument.setAttribute("name", "busid");
			elBusIdArgument.setText(strBusId);
			elResponseArgumentsNode.addContent(elBusIdArgument);

			// create the edit status argument placeholder
			Element elEditStatusArgument = new Element("argument");
			elEditStatusArgument.setAttribute("name", "foredit");
			elEditStatusArgument.setText(strEditStatus);
			elResponseArgumentsNode.addContent(elEditStatusArgument);

			String projectId = strBusId;
			project.setId(projectId);
			//sProjectSchduleBasedOn = project.getAttributeValue(context, ATTRIBUTE_SCHEDULEBASEDON);

			if (debug)
				System.out.println("Read Project data");

			// Define selectables for each Task object.
			StringList busSelects = new StringList();
			busSelects.add(SELECT_ID);
			busSelects.add(SELECT_TYPE);
			busSelects.add(SELECT_POLICY);
			busSelects.add(SELECT_CURRENT);
			busSelects.add(SELECT_PERCENT_COMPLETE);
			busSelects.add(SELECT_TASK_ESTIMATED_DURATION);
			busSelects.add(SELECT_TASK_ACTUAL_DURATION);
			busSelects.add(SELECT_TASK_ACTUAL_START_DATE);
			busSelects.add(SELECT_TASK_ACTUAL_FINISH_DATE);
			busSelects.add(SELECT_TASK_CONSTRAINT_DATE);
			//busSelects.add(SELECT_DEFAULT_CALENDAR);  // Fetch calendar

			busSelects.addAll(projectSelectable);

			StringList taskSelects = new StringList();
			taskSelects.add(SELECT_ID);
			taskSelects.add(SELECT_ATTRIBUTE_PROJECT_SCHEDULE_FROM);
			taskSelects.add(SELECT_PREDECESSOR_IDS);
			taskSelects.add(SELECT_PREDECESSOR_TYPES);
			taskSelects.add(SELECT_PREDECESSOR_LAG_TIMES);
			taskSelects.add(task.SELECT_HAS_SUBTASK);
			taskSelects.add(SELECT_POLICY);
			//taskSelects.add(SELECT_TASK_CALENDAR);

			// project.setId(projectId);
			task.setId(projectId);

			// get the project info
			Map projectMap = project.getInfo(context, busSelects);

			//create Project Schedule is Estimated or Actual in argument placeholder
			sProjectSchduleBasedOn = (String)projectMap.get(SELECT_ATTRIBUTE_SCHEDULEBASEDON);
			Element elProjectScheduleOnArgument = new Element("argument");
			elProjectScheduleOnArgument.setAttribute("name", "ProjectScheduleOn");
			elProjectScheduleOnArgument.setText(sProjectSchduleBasedOn);
			elResponseArgumentsNode.addContent(elProjectScheduleOnArgument);

			//create argument placeholder to confirm is logged in user is owner or not
			Element elIsLoggedinOwner = new Element("argument");
			elIsLoggedinOwner.setAttribute("name", "LoggedinIsOwner");

			Boolean bIsLoggedInSameAsOwner = (projectMap.get(SELECT_OWNER).toString().equals(context.getUser())) ? true : false;
			elIsLoggedinOwner.setText(bIsLoggedInSameAsOwner.toString());
			elResponseArgumentsNode.addContent(elIsLoggedinOwner);

			//create the project xml argument placeholder
			Element elProjectArgument = new Element("argument");
			elProjectArgument.setAttribute("name", "projectxml");
			elResponseArgumentsNode.addContent(elProjectArgument);

			//create empty node for project xml
			elProjectRoot = new Element("Project");
			elProjectArgument.addContent(elProjectRoot);

			codeRegn = "Project data Read";
			if (debug)
				System.out.println(codeRegn);

			//Filter the TaskSelect w.r.t the Project type
			String projectType = (String)projectMap.get(SELECT_TYPE);
			if(projectType != null && !projectType.isEmpty())
			{
				StringList taskBusSelect = new StringList();
				StringList taskRelSelect = new StringList();
				GetTypeSpecificTaskSelectables(context, projectType, taskBusSelect, taskRelSelect);

				if(taskBusSelect.size() != 0 || taskRelSelect.size() != 0)
				{
					taskSelects.addAll(taskBusSelect);
					taskRelSelectable = taskRelSelect;
				}
				else
				{
					taskSelects.addAll(taskSelectable);
				}
			}
			
			// get the task info
			MapList taskList = task.getTasks(context, task, 1, taskSelects, taskRelSelectable);

			Element elCurrentNode = null;
			Element elTasksNode = null;
			Element elParentNode = elProjectRoot;
			String content = "";

			createTaskIndexMap(context, projectId);
			String thisProjectIndex = Integer.toString(projectList.indexOf(projectId));
			addToParent(elParentNode, "UID", thisProjectIndex);
			addToParent(elParentNode, "ID", thisProjectIndex);

			//content = (String) projectMap.get(SELECT_NAME);
			addToParent(elParentNode, "Title", (String) projectMap.get(SELECT_NAME));

			content = (String) projectMap.get(SELECT_PERCENT_COMPLETE);
			//Integer newPercent = new Integer(Double.valueOf(content).intValue());//if value is 46.7, prev it was returning 46 now it returns 47
			Integer newPercent = new Integer(Math.round(Float.valueOf(content)));
			content = Integer.toString(newPercent.intValue());
			addToParent(elParentNode, "PercentComplete", content);

			// Project Calendar Check if exists and assign
			/*String calendarID = (String) projectMap.get(SELECT_DEFAULT_CALENDAR);
			String calendarName = "";
			if (calendarID != null && calendarID.length() > 0)
			{
				WorkCalendar workCalendar = new WorkCalendar(calendarID);
				workCalendar.load(context);
				addToParent(elParentNode, "Calendar", calendarID);
				calendarName = workCalendar.getName(context);
				addToParent(elParentNode, "CalendarName", calendarName);
			}*/

			SetProjectDetailsForClientXML(elParentNode, projectColAttrMap, projectMap, false);			

			// Define DefaultTaskType - PMC supports ONLY fixed duration
			// 0 = Fixed Unit, 1 = Fixed Duration and 2 = Fixed Work
			// We will hard-code it to 1

			// addToParent(elParentNode, "DefaultTaskType", "1");

			// Define NewTasksEffortDriven - Tasks are not effort driven in PMC
			// 0 = Disabled and 1 = Enabled
			// addToParent(elParentNode, "NewTasksEffortDriven", "0");
			
			elParentNode = elProjectRoot;

			codeRegn = "Add tasks as XML nodes";
			elCurrentNode = new Element("Tasks");
			elParentNode.addContent(elCurrentNode);
			elTasksNode = elCurrentNode;
			elParentNode = elTasksNode;

			elCurrentNode = new Element("Task");
			elParentNode.addContent(elCurrentNode);

			elParentNode = elCurrentNode;
			
			/*if (calendarID != null && calendarID.length() > 0)
			{
				addToParent(elParentNode, "Calendar", calendarID);
				addToParent(elParentNode, "CalendarName", calendarName);
			}*/

			SetSummaryProjectNodeForClientXML(context, elParentNode,projectMap);	 //special handling of project summary node.

			elParentNode = elProjectRoot;
			Element elResourcesNode = new Element("Resources");
			elParentNode.addContent(elResourcesNode);

			// summary node for resource
			elCurrentNode = new Element("Resource");
			elParentNode = elResourcesNode;
			elParentNode.addContent(elCurrentNode);
			elParentNode = elCurrentNode;
			addToParent(elParentNode, "UID", "0");
			addToParent(elParentNode, "ID", "0");
			addToParent(elParentNode, "Type", "1");
			addToParent(elParentNode, "CanLevel", "1");
			addToParent(elParentNode, "AccrueAt", "3");

			// Add project Members as resources
			// this will show up in resource sheet of MS Project
			// and users will be able to assign them as task assignees in MS Project
			busSelects.clear();
			busSelects.add(person.SELECT_ID);
			busSelects.add(person.SELECT_NAME);
			busSelects.add(person.SELECT_FIRST_NAME);
			busSelects.add(person.SELECT_LAST_NAME);
			busSelects.add(person.SELECT_EMAIL_ADDRESS);
			// busSelects.add(person.SELECT_MIDDLE_NAME);
			// busSelects.add(person.SELECT_COMPANY_NAME);
			MapList membersList = project.getMembers(context, busSelects, null, null, null);
			ListIterator membersItr = membersList.listIterator();

			Map resourceIndexMap = new HashMap();
			int resourceCounter = 1;
			while (membersItr.hasNext()) {

				Map membersMap = (Map) membersItr.next();
				String personName = (String) membersMap.get(person.SELECT_LAST_NAME) + " " + (String) membersMap.get(person.SELECT_FIRST_NAME);

				// add to the resourceMap if the person is not already added to the resource list
				if (resourceIndexMap.get(personName) == null) {

					resourceIndexMap.put(personName, String.valueOf(resourceCounter));
					// create the resource details
					elCurrentNode = new Element("Resource");
					elParentNode = elResourcesNode;
					elParentNode.addContent(elCurrentNode);
					elParentNode = elCurrentNode;

					content = String.valueOf(resourceCounter);
					addToParent(elParentNode, "UID", content);
					addToParent(elParentNode, "ID", content);

					addToParent(elParentNode, "Name", personName);
					addToParent(elParentNode, "Type", "1");
					// addToParent(elParentNode, "IsNull", "0");
					// addToParent(elParentNode, "WorkGroup", "0");

					/*Person person = Person.getPerson(context, (String) membersMap.get(SELECT_NAME));
					String locationId = person.getInfo(context, Person.SELECT_LOCATION_ID);

					if (locationId != null) {
						WorkCalendar workCalendar = WorkCalendar.getCalendar(context, locationId);
						if (workCalendar != null) {
							String calID = workCalendar.getId(context);
							addToParent(elParentNode, "Calendar", calID);
							addToParent(elParentNode, "CalendarName", workCalendar.getName(context));
						}
					}*/

					content = (String) membersMap.get(person.SELECT_EMAIL_ADDRESS);
					addToParent(elParentNode, "EmailAddress", content);
					// addToParent(elParentNode, "OverAllocated", "0");
					addToParent(elParentNode, "CanLevel", "1");
					addToParent(elParentNode, "AccrueAt", "3");

					elCurrentNode = new Element("ExtendedAttribute");
					elParentNode.addContent(elCurrentNode);

					elParentNode = elCurrentNode;

					content = String.valueOf(resourceCounter);
					addToParent(elParentNode, "UID", content);

					//addToParent(elParentNode, "FieldID", "205520904");

					content = (String) membersMap.get(person.SELECT_ID);
					addToParent(elParentNode, "Value", content);
					resourceCounter++;

					// find the person id of the person with the given Last name First Name
					// if it is not found then add to the _personInfo for caching
					if (_personInfo != null && _personInfo.get(personName) == null) {
						//found new Last Name First Name, add to cache
						// this will be reused when the user adds the user as task assignee
						_personInfo.put(personName, membersMap.get(person.SELECT_NAME));
					}
				}
			}

			elParentNode = elProjectRoot;
			Element elAssignmentsNode = new Element("Assignments");
			elParentNode.addContent(elAssignmentsNode);

			codeRegn = "Assignment XML done.";
			// Loops through all the task of the project to get the task info
			codeRegn = "Inside getTaskStructure: fetch task details start";
			ListIterator itr = taskList.listIterator();
			StringList taskIds = new StringList();

			while (itr.hasNext()) {
				Map map = new HashMap();
				map = (Map) itr.next();
				getTaskStructure(context, map, elTasksNode, taskIds, 1, projectType);
				//getTaskStructure(context, map, elTasksNode, elResourcesNode, elAssignmentsNode, resourceIndexMap, 1);
			}
			codeRegn = "Inside getTaskStructure: fetch task details end";

			Object[] objectIdList = taskIds.toArray();
			String[] taskIdArray = Arrays.copyOf(objectIdList, objectIdList.length, String[].class);		  

			MapList assignInfoList = getAssignmentInfo(context, taskIdArray);

			//get Resource and Assignment structure
			getResc_AssignmentStructure(context, taskIdArray, assignInfoList, elResourcesNode, elAssignmentsNode, resourceIndexMap);		  

			elResponseRoot.setAttribute("result", "success");
			if (debug) {
				System.out.println("Sending processed XML back to MS Project...Done");
				xmlfileGen_EndTime = System.currentTimeMillis();

				long total_xmlfileGenTime = xmlfileGen_EndTime - xmlfileGen_BeginTime;
				System.out.println("TOTAL TIME in executeFindCheckout (in Secs) ...  " + total_xmlfileGenTime / 1000);
				System.out.println("================ END executeFindForCheckout ================");
			}
			return "true|" + dumpTransactionXMLForServlet(elResponseRoot);
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("{Exception from executeFindForCheckout} : " + codeRegn + " " + e.getMessage());
			throw new MatrixException(e.getMessage());
		}
	}

	//set the summary details to send the xml at client side
	private void SetSummaryProjectNodeForClientXML(Context context, Element elParentNode,
			Map projectMap) throws Exception {

		String content = "";

		addToParent(elParentNode, "UID", "0");
		addToParent(elParentNode, "ID", "0");

		addToParent(elParentNode, "Summary", "1");
		addToParent(elParentNode, "OutlineNumber", "0");
		addToParent(elParentNode, "OutlineLevel", "0");
		//addToParent(elParentNode, "Rollup", "0");

		Element elExtendedAttributeNode = new Element("ExtendedAttribute");
		elParentNode.addContent(elExtendedAttributeNode);

		//addToParent(elExtendedAttributeNode, "FieldID", "188743731");
		content = (String) projectMap.get(SELECT_ID);
		addToParent(elExtendedAttributeNode, "Value", content);

		content = (String) projectMap.get(SELECT_CURRENT);
		addToParent(elParentNode, "State", content);	  

		content = (String) projectMap.get(SELECT_PERCENT_COMPLETE);
		content = SetDetailsAsPerFormat("percent", content);
		addToParent(elParentNode, "PercentComplete", content);

		content = setFormatDateInReqrdForm((String)projectMap.get(SELECT_TASK_CONSTRAINT_DATE));

		addToParent(elParentNode, "ConstraintDate", content);

		String taskEstDuration = (String) projectMap.get(SELECT_TASK_ESTIMATED_DURATION);

		if (!taskEstDuration.equals(""))
		{
			content = setDurationInReqrdForm(taskEstDuration);
		}
		addToParent(elParentNode, "Duration", content);

		if(sProjectSchduleBasedOn.equals("Actual"))
		{	//IR-185678V6R2013x Begin
			content = setFormatDateInReqrdForm((String) projectMap.get(SELECT_TASK_ACTUAL_START_DATE));

			addToParent(elParentNode, "ActualStart", content);

			content = setFormatDateInReqrdForm((String) projectMap.get(SELECT_TASK_ACTUAL_FINISH_DATE));

			addToParent(elParentNode, "ActualFinish", content);
			//IR-185678V6R2013x end 

			String taskActualDuration = (String) projectMap.get(SELECT_TASK_ACTUAL_DURATION);
			content = "";
			if (!taskActualDuration.equals(""))
				content = setDurationInReqrdForm(taskActualDuration);

			addToParent(elParentNode, "ActualDuration", content);
		}

		content = (String) projectMap.get(SELECT_TYPE);
		addToParent(elParentNode, "NodeType", content);

		content = (String) projectMap.get(SELECT_POLICY);
		addToParent(elParentNode, "Policy", content);

		SetProjectDetailsForClientXML(elParentNode, projectColAttrMap, projectMap, true);
	}

	private void SetProjectDetailsForClientXML(Element elParentNode, Map<String, Map> colAttrMap, Map detailsMap, boolean isSummary) 
			throws Exception {

		String content = "";
		Set<String> colKeys = new HashSet<String>(colAttrMap.keySet());
		String sScheduleFrom = (String) detailsMap.get(SELECT_ATTRIBUTE_PROJECT_SCHEDULE_FROM);

		Iterator<String> colKeysIter=colKeys.iterator();

		while(colKeysIter.hasNext()) {

			Map colSettingMap = new HashMap();
			String sKey = colKeysIter.next();			
			colSettingMap = colAttrMap.get(sKey);
			content = (String) detailsMap.get(sKey);

			String sColumnName = (String)colSettingMap.get("Name");
			String columnType = (String)colSettingMap.get("MPIColumnType");
			/*String sIgnoreForServer = (String)colSettingMap.get("MPIIgnoreForServer"); 

			if(sIgnoreForServer != null && sIgnoreForServer.equals("true"))
				continue;*/

			if(sColumnName.equals("ScheduleFrom")) {
				content = "True"; // True for Project Start Date
				if(sScheduleFrom.equals("Project Finish Date"))		  
					content = "False";					  
			}			
			else if(sColumnName.equals("ProjectStart")) {

				if(isSummary) {
					sColumnName = "Start";
					content = (String) detailsMap.get(SELECT_TASK_ESTIMATED_START_DATE);;
				}
				else {
					if(sScheduleFrom.equals("Project Start Date"))
						content = (String) detailsMap.get(SELECT_TASK_CONSTRAINT_DATE);
					else
						content = (String) detailsMap.get(SELECT_TASK_ESTIMATED_START_DATE);
				}
			}
			else if(sColumnName.equals("ProjectFinish")) {

				if(isSummary) {
					sColumnName = "Finish";
					content = (String) detailsMap.get(SELECT_TASK_ESTIMATED_FINISH_DATE);;
				}
				else {	
					if(sScheduleFrom.equals("Project Finish Date"))
						content = (String) detailsMap.get(SELECT_TASK_CONSTRAINT_DATE);
					else
						content = (String) detailsMap.get(SELECT_TASK_ESTIMATED_FINISH_DATE);;
				}
			}

			if(columnType != null && columnType != "") {
				if(!content.equals("")) {
					content = SetDetailsAsPerFormat(columnType.toLowerCase(), content);
				}
			}

			addToParent(elParentNode, sColumnName, content);
		}
	}
	
	//set the task details in a xml format to send to client 
	private void SetTaskDetailsForClientXML(Element elParentNode, Map<String, Map> colAttrMap, Map detailsMap) throws Exception {

		String content = "";

		Set<String> colKeys = new HashSet<String>(colAttrMap.keySet());

		Iterator<String> colKeysIter=colKeys.iterator();

		while(colKeysIter.hasNext()) {

			Map colSettingMap = new HashMap();
			String sKey = colKeysIter.next();
			colSettingMap = colAttrMap.get(sKey);

			content = (String) detailsMap.get(sKey);

			String columnName = (String)colSettingMap.get("Name");

			String columnType = (String)colSettingMap.get("MPIColumnType");
			String sIgnoreForServer = (String)colSettingMap.get("MPIIgnoreForServer"); 

			if(sIgnoreForServer != null && sIgnoreForServer.equals("true"))
				continue;				

			if((columnName.equals("ActualStart") || columnName.equals("ActualFinish") || columnName.equals("ActualDuration"))
					&& sProjectSchduleBasedOn.equals("Estimated"))
			{
				addToParent(elParentNode, columnName, "");
				continue;
			}			

			if(columnType != null && columnType != "") {

				if(columnType.equals("constraint")) {

					if(slProjectSpaceSubTypes.contains((String)detailsMap.get(task.SELECT_TYPE))) {
						content = "As Soon As Possible";
						String sScheduleFrom = (String) detailsMap.get(SELECT_ATTRIBUTE_PROJECT_SCHEDULE_FROM);

						if(null != sScheduleFrom && sScheduleFrom.equals("Project Finish Date"))		  
							content = "As Late As Possible";
					}
				}
				if(content!= null && !content.equals("")) {
					content = SetDetailsAsPerFormat(columnType.toLowerCase(),content);
				}
			}

			addToParent(elParentNode, columnName, content);
		}
	}

	private String SetDetailsAsPerFormat(String columnType, String content) throws Exception {

		if(columnType.equals("date")) {
			content = setFormatDateInReqrdForm(content);
		}
		else if(columnType.equals("percent")) {
			Integer newPercent = new Integer(Math.round(Float.valueOf(content)));
			content = Integer.toString(newPercent.intValue());
		}
		else if(columnType.equals("duration")) {
			content = setDurationInReqrdForm(content);
		}
		else if(columnType.equals("user")) {
			content = getPersonLastNameFirstName(m_ctxUserContext, content);
		}
		else if(columnType.equals("constraint")) {
			content = GetConstraintConstantMap.get(content);
		}
		return content;
	}

	// set Matrix date to date format as 2003-03-11To8:00:00
	private String setFormatDateInReqrdForm(String dateContent) {

		if (dateContent != null && !dateContent.equals(""))  {

			Date date = MATRIX_DATE_FORMAT.parse(dateContent, new java.text.ParsePosition(0));
			dateContent = dateFormat.format(date);
			return dateContent;
		}
		return "";
	}

	//To convert duration in such form PT32H0M0S in handling of open case
	private String setDurationInReqrdForm(String durnContent) {

		Integer newDuration = new Integer(Double.valueOf(durnContent).intValue());
		Double new2Duration = new Double(Double.valueOf(durnContent).doubleValue());
		durnContent = "PT" + Integer.toString(newDuration.intValue() * 8) + "H" 
				+ Long.toString(Math.round(new2Duration.doubleValue() * 8 * 60 - newDuration.intValue() * 8 * 60 )) + "M0S";
		return durnContent;
	}

	private MapList getAssignmentInfo(Context context, String[] taskIdArray) throws Exception {

		MULTI_VALUE_LIST.add(SELECT_TASK_ASSIGNEE_NAME);
		MULTI_VALUE_LIST.add(SELECT_TASK_ASSIGNEE_ID);
		MULTI_VALUE_LIST.add(SELECT_ASSIGNEE_FIRST_NAME);
		MULTI_VALUE_LIST.add(SELECT_ASSIGNEE_LAST_NAME);
		MULTI_VALUE_LIST.add(SELECT_ASSIGNEE_EMAIL_ADDR);

		DomainObject domTaskObject = DomainObject.newInstance(context);
		StringList slObjectSelects = new StringList();	  

		slObjectSelects.add(SELECT_TASK_ASSIGNEE_NAME);
		slObjectSelects.add(SELECT_TASK_ASSIGNEE_ID);
		slObjectSelects.add(SELECT_ASSIGNEE_FIRST_NAME);
		slObjectSelects.add(SELECT_ASSIGNEE_LAST_NAME);
		slObjectSelects.add(SELECT_ASSIGNEE_EMAIL_ADDR);
		return domTaskObject.getInfo(context, taskIdArray, slObjectSelects);
	}

	private void getResc_AssignmentStructure(Context context, 
			String[] taskIdArray, MapList assignInfoList, 
			Element elResourcesNode, Element elAssignmentsNode, 
			Map resourceIndexMap) throws Exception {

		Element elCurrentNode = null;
		Element elParentNode = null;

		for(int iItr = 0 ; iItr< assignInfoList.size(); iItr++)
		{		  
			Map assigneeMap = (HashMap)assignInfoList.get(iItr);
			Object assignee = assigneeMap.get(SELECT_TASK_ASSIGNEE_ID);

			if(!assigneeMap.isEmpty()) {
				String currentTaskId = taskIdArray[iItr];
				String taskCounter = (String)taskIndexMap.get(currentTaskId);
				String sTaskOID = String.valueOf(taskCounter);
				StringList assigneeName = new StringList();
				StringList assigneeId = new StringList();
				StringList assigneeFirstName = new StringList();
				StringList assigneeLastName = new StringList();
				StringList assigneeEmail = new StringList();

				if(assignee instanceof StringList){
					assigneeName.addAll((StringList)assigneeMap.get(SELECT_TASK_ASSIGNEE_NAME));
					assigneeId.addAll((StringList)assigneeMap.get(SELECT_TASK_ASSIGNEE_ID));
					assigneeFirstName.addAll((StringList)assigneeMap.get(SELECT_ASSIGNEE_FIRST_NAME));
					assigneeLastName.addAll((StringList)assigneeMap.get(SELECT_ASSIGNEE_LAST_NAME));
					assigneeEmail.addAll((StringList)assigneeMap.get(SELECT_ASSIGNEE_EMAIL_ADDR));
				}

				int assigneeCounter = 0;
				for(int iAssignee =0 ; iAssignee < assigneeId.size(); iAssignee ++)
				{
					String personName = assigneeLastName.get(iAssignee) + " " + assigneeFirstName.get(iAssignee);
					String content = "";
					//add to the resourceMap if the person is not already added to the resource list
					if(resourceIndexMap.get(personName) == null)
					{
						int resourceCounter = resourceIndexMap.size() + 1;
						String sRescCounter = String.valueOf(resourceCounter);
						resourceIndexMap.put(personName, sRescCounter);
						//create the resource details
						elCurrentNode = new Element("Resource");
						elParentNode = elResourcesNode;
						elParentNode.addContent(elCurrentNode);
						elParentNode = elCurrentNode;

						//content = String.valueOf(resourceCounter);
						addToParent(elParentNode, "UID", sRescCounter);
						addToParent(elParentNode, "ID", sRescCounter);

						//content = personName;
						addToParent(elParentNode, "Name", personName);
						addToParent(elParentNode, "Type", "1");
						//addToParent(elParentNode, "IsNull", "0");
						//addToParent(elParentNode, "WorkGroup", "0");

						//content = (String)assigneeMap.get(person.SELECT_EMAIL_ADDRESS);
						content  = (String)assigneeEmail.get(iAssignee);
						addToParent(elParentNode, "EmailAddress", content);
						//addToParent(elParentNode, "OverAllocated", "0");
						addToParent(elParentNode, "CanLevel", "1");
						addToParent(elParentNode, "AccrueAt", "3");

						elCurrentNode = new Element("ExtendedAttribute");
						elParentNode.addContent(elCurrentNode);

						elParentNode = elCurrentNode;
						//content = String.valueOf(resourceCounter);
						addToParent(elParentNode, "UID", sRescCounter);

						//addToParent(elParentNode, "FieldID", "205520904");

						//content = (String) assigneeMap.get(person.SELECT_ID);
						content =  (String) assigneeId.get(iAssignee);
						addToParent(elParentNode, "Value", content);
					}

					//assign the resource to a task
					elCurrentNode = new Element("Assignment");
					elParentNode = elAssignmentsNode;
					elParentNode.addContent(elCurrentNode);
					elParentNode = elCurrentNode;

					//content = String.valueOf(resourceCounter);
					content = String.valueOf(assigneeCounter);
					addToParent(elParentNode, "UID", content);
					//content = String.valueOf(taskCounter);
					addToParent(elParentNode, "TaskID", sTaskOID);
					String taskUid = taskCounter;
					String parentProjectId = (String)taskParentMap.get(currentTaskId);
					int taskParentIndx = projectList.indexOf(parentProjectId);
					if(taskParentIndx>=0)
					{
						taskUid = taskParentIndx + "#" + taskUid;
					}
					addToParent(elParentNode, "TaskUID", taskUid);
					//get the resource id from the map			  
					content = (String) resourceIndexMap.get(personName);
					addToParent(elParentNode, "ResourceUID", content);

					String currentPersonName = (String)assigneeName.get(iAssignee);
					String percent = getAllocationPercent(context, currentTaskId, currentPersonName);
					double allocatedPercent = (Double.valueOf(percent)).doubleValue();

					Float f = new Float((1.0)*allocatedPercent);
					addToParent(elParentNode, "Units", f.toString());
				}//for(int iAssignee =0 ; iAssignee < assigneeId.size(); iAssignee ++)
			}//if(!assigneeMap.isEmpty()) {
		}//for(int iItr = 0 ; iItr< assignInfoList.size(); iItr++)
	}

	void createTaskIndexMap(Context context, String thisProjectId) throws Exception {

		projectList.add(thisProjectId);

		StringList taskSelects = new StringList();
		taskSelects.add(task.SELECT_ID);
		//taskSelects.add(subtask.SELECT_TASK_WBS);
		taskSelects.add(task.SELECT_TYPE);
		taskSelects.add(task.SELECT_HAS_SUBTASK);

		task.setId(thisProjectId);
		MapList taskList = task.getTasks(context, task, 1, taskSelects, null);

		ListIterator taskItr = taskList.listIterator();
		int counter = 1;
		while (taskItr.hasNext()) {
			Map map = (Map) taskItr.next();
			String id = (String) map.get(task.SELECT_ID);
			String type = (String) map.get(task.SELECT_TYPE);
			String isSummaryTask = (String) map.get(task.SELECT_HAS_SUBTASK);

			taskParentMap.put(id, thisProjectId);
			taskIndexMap.put(id, String.valueOf(counter++));
			if(slProjectSpaceSubTypes.contains(type)) {
				//if (isProjectSpace(context, type)) {
				createTaskIndexMap(context, id);
			} else {
				if (isSummaryTask.equalsIgnoreCase("true"))
					counter = getTaskStructureForTIMap(context, id, counter, thisProjectId);
			}
		}
	}

	int getTaskStructureForTIMap(Context context, String taskId, int nextTaskCount, String projectId) throws Exception {

		StringList taskSelects = new StringList();
		taskSelects.add(task.SELECT_ID);
		//taskSelects.add(subtask.SELECT_TASK_WBS);
		taskSelects.add(task.SELECT_TYPE);
		taskSelects.add(task.SELECT_HAS_SUBTASK);

		task.setId(taskId);
		MapList taskListForDependency = task.getTasks(context, task, 1, taskSelects, null);

		ListIterator taskItr = taskListForDependency.listIterator();
		while (taskItr.hasNext()) {
			Map map = (Map) taskItr.next();
			String id = (String) map.get(task.SELECT_ID);
			String type = (String) map.get(task.SELECT_TYPE);
			String isSummaryTask = (String) map.get(task.SELECT_HAS_SUBTASK);

			taskParentMap.put(id, projectId);
			taskIndexMap.put(id, String.valueOf(nextTaskCount++));
			if(slProjectSpaceSubTypes.contains(type)) {

				createTaskIndexMap(context, id);
			} else {

				if (isSummaryTask.equalsIgnoreCase("true"))
					nextTaskCount = getTaskStructureForTIMap(context, id, nextTaskCount, projectId);
			}
		}
		return nextTaskCount;
	}

	public Element executeCheckoutSubproject(Context context, String[] args) throws MatrixException {

		codeRegn = "inside executeCheckoutSubproject";
		if (debug)
			System.out.println(codeRegn);

		try {
			Element elCommandRoot = loadXMLSentFromServlet(args[0]);

			Element elResponseRoot = new Element("transaction");
			elResponseRoot.setAttribute("cname", elCommandRoot.getAttributeValue("cname"));

			String strBusId = "";
			Element elCommandArguments = elCommandRoot.getChild("arguments");
			List lArguments = elCommandArguments.getChildren("argument");
			ListIterator litCtr = lArguments.listIterator();
			Element elProjectRoot = null;
			String strEditStatus = "";

			while (litCtr.hasNext()) {

				Element elArgument = (Element) litCtr.next();

				if (elArgument.getAttributeValue("name").equals("busid")) {
					strBusId = elArgument.getText();
				}

				if (elArgument.getAttributeValue("name").equals("foredit")) {
					strEditStatus = elArgument.getText();
				}
			}

			codeRegn = "SubProject XML and BusID got.";
			if (debug)
				System.out.println(codeRegn);
			// now create placeholder for response
			Element elResponseArgumentsNode = new Element("arguments");
			elResponseRoot.addContent(elResponseArgumentsNode);

			// create the busid argument placeholder
			Element elBusIdArgument = new Element("argument");
			elBusIdArgument.setAttribute("name", "busid");
			elBusIdArgument.setText(strBusId);
			elResponseArgumentsNode.addContent(elBusIdArgument);

			// create the edit status argument placeholder
			Element elEditStatusArgument = new Element("argument");
			elEditStatusArgument.setAttribute("name", "foredit");
			elEditStatusArgument.setText(strEditStatus);
			elResponseArgumentsNode.addContent(elEditStatusArgument);

			// create the project xml argument placeholder
			Element elProjectArgument = new Element("argument");
			elProjectArgument.setAttribute("name", "projectxml");
			elResponseArgumentsNode.addContent(elProjectArgument);

			// create empty node for project xml
			elProjectRoot = new Element("Project");

			codeRegn = "Read SubProject data.";
			if (debug)
				System.out.println(codeRegn);

			// Define selectables for each Task object.
			StringList busSelects = new StringList();
			busSelects.add(SELECT_ID);
			busSelects.add(SELECT_TYPE);
			busSelects.add(SELECT_POLICY);
			busSelects.add(SELECT_CURRENT);
			busSelects.add(SELECT_PERCENT_COMPLETE);
			busSelects.add(SELECT_TASK_ESTIMATED_DURATION);
			busSelects.add(SELECT_TASK_ACTUAL_DURATION);
			busSelects.add(SELECT_TASK_ACTUAL_START_DATE);
			busSelects.add(SELECT_TASK_ACTUAL_FINISH_DATE);
			busSelects.add(SELECT_TASK_CONSTRAINT_DATE);
			//busSelects.add(SELECT_DEFAULT_CALENDAR);  // Fetch calendar

			busSelects.addAll(projectSelectable);		

			/*StringList taskRelSelects = new StringList();
			taskRelSelects.add(subtask.SELECT_TASK_WBS);*/

			StringList taskSelects = new StringList();
			taskSelects.add(SELECT_ID);
			taskSelects.add(SELECT_PREDECESSOR_IDS);
			taskSelects.add(SELECT_PREDECESSOR_TYPES);
			taskSelects.add(SELECT_PREDECESSOR_LAG_TIMES);
			taskSelects.add(SELECT_HAS_SUBTASK);
			taskSelects.add(SELECT_ATTRIBUTE_PROJECT_SCHEDULE_FROM);
			taskSelects.add(SELECT_POLICY);
			//taskSelects.add(SELECT_TASK_CALENDAR);

			String projectId = strBusId;
			project.setId(projectId);
			task.setId(projectId);

			// get the project info
			Map projectMap = project.getInfo(context, busSelects);

			//Filter the TaskSelect w.r.t the Project type
			String projectType = (String)projectMap.get(SELECT_TYPE);
			if(projectType != null && !projectType.isEmpty())
			{
				StringList taskBusSelect = new StringList();
				StringList taskRelSelect = new StringList();
				GetTypeSpecificTaskSelectables(context, projectType, taskBusSelect, taskRelSelect);

				if(taskBusSelect.size() != 0 || taskRelSelect.size() != 0)
				{
					taskSelects.addAll(taskBusSelect);
					taskRelSelectable = taskRelSelect;
				}
				else
				{
					taskSelects.addAll(taskSelectable);
				}
			}

			// get the task info
			MapList taskList = task.getTasks(context, task, 1, taskSelects, taskRelSelectable);

			codeRegn = "Fill subproject xml";
			if (debug)
				System.out.println(codeRegn);

			Element elCurrentNode = null;
			Element elTasksNode = null;
			Element elParentNode = elProjectRoot;
			String content = "";

			createTaskIndexMap(context, projectId);
			String thisProjectIndex = Integer.toString(projectList.indexOf(projectId));
			addToParent(elParentNode, "UID", thisProjectIndex);
			addToParent(elParentNode, "ID", thisProjectIndex);

			content = (String) projectMap.get(SELECT_NAME);
			addToParent(elParentNode, "Title", content);

			content = (String) projectMap.get(SELECT_PERCENT_COMPLETE);
			// Integer newPercent = new Integer(Double.valueOf(content).intValue());//if value is 46.7, prev it was returning 46 now it returns 47
			Integer newPercent = new Integer(Math.round(Float.valueOf(content)));
			content = Integer.toString(newPercent.intValue());
			addToParent(elParentNode, "PercentComplete", content);

			SetProjectDetailsForClientXML(elParentNode, projectColAttrMap, projectMap,false);			

			elParentNode = elProjectRoot;

			elCurrentNode = new Element("Tasks");
			elParentNode.addContent(elCurrentNode);
			elTasksNode = elCurrentNode;
			elParentNode = elTasksNode;

			elCurrentNode = new Element("Task");
			elParentNode.addContent(elCurrentNode);

			elParentNode = elCurrentNode;

			SetSummaryProjectNodeForClientXML(context, elParentNode,projectMap);	 //special handling of project summary node.

			elParentNode = elProjectRoot;
			Element elResourcesNode = new Element("Resources");
			elParentNode.addContent(elResourcesNode);

			// summary node for resource
			elCurrentNode = new Element("Resource");
			elParentNode = elResourcesNode;
			elParentNode.addContent(elCurrentNode);
			elParentNode = elCurrentNode;
			addToParent(elParentNode, "UID", "0");
			addToParent(elParentNode, "ID", "0");
			addToParent(elParentNode, "Type", "1");
			// addToParent(elParentNode, "IsNull", "0");
			// addToParent(elParentNode, "WorkGroup", "0");
			// addToParent(elParentNode, "OverAllocated", "0");
			addToParent(elParentNode, "CanLevel", "1");
			addToParent(elParentNode, "AccrueAt", "3");

			//Add project Members as resources this will show up in resource sheet of MS Project
			// and users will be able to assign them as task assignees in MS Project
			busSelects.clear();
			busSelects.add(person.SELECT_ID);
			busSelects.add(person.SELECT_NAME);
			busSelects.add(person.SELECT_FIRST_NAME);
			busSelects.add(person.SELECT_LAST_NAME);
			busSelects.add(person.SELECT_EMAIL_ADDRESS);
			// busSelects.add(person.SELECT_MIDDLE_NAME);
			// busSelects.add(person.SELECT_COMPANY_NAME);

			MapList membersList = project.getMembers(context, busSelects, null, null, null);
			ListIterator membersItr = membersList.listIterator();

			Map resourceIndexMap = new HashMap();
			int resourceCounter = 1;
			while (membersItr.hasNext()) {
				Map membersMap = (Map) membersItr.next();
				String personName = (String) membersMap.get(person.SELECT_LAST_NAME) + " " + (String) membersMap.get(person.SELECT_FIRST_NAME);
				// add to the resourceMap if the person is not already added to the resource list

				if (resourceIndexMap.get(personName) == null) {

					resourceIndexMap.put(personName, String.valueOf(resourceCounter));
					// create the resource details
					elCurrentNode = new Element("Resource");
					elParentNode = elResourcesNode;
					elParentNode.addContent(elCurrentNode);
					elParentNode = elCurrentNode;

					content = String.valueOf(resourceCounter);
					addToParent(elParentNode, "UID", content);
					addToParent(elParentNode, "ID", content);

					content = personName;
					addToParent(elParentNode, "Name", content);
					addToParent(elParentNode, "Type", "1");
					// addToParent(elParentNode, "IsNull", "0");
					// addToParent(elParentNode, "WorkGroup", "0");

					//Get SubProject Calendar					
					/*Person person = Person.getPerson(context, (String) membersMap.get(SELECT_NAME));
					String locationId = person.getInfo(context, Person.SELECT_LOCATION_ID);

					if (locationId != null) {
						WorkCalendar workCalendar = WorkCalendar.getCalendar(context, locationId);
						if (workCalendar != null) {
							String calID = workCalendar.getId(context);
							addToParent(elParentNode, "Calendar", calID);
							addToParent(elParentNode, "CalendarName", workCalendar.getName(context));
						}
					}*/

					content = (String) membersMap.get(person.SELECT_EMAIL_ADDRESS);
					addToParent(elParentNode, "EmailAddress", content);
					// addToParent(elParentNode, "OverAllocated", "0");
					addToParent(elParentNode, "CanLevel", "1");
					addToParent(elParentNode, "AccrueAt", "3");

					elCurrentNode = new Element("ExtendedAttribute");
					elParentNode.addContent(elCurrentNode);

					elParentNode = elCurrentNode;

					content = String.valueOf(resourceCounter);
					addToParent(elParentNode, "UID", content);

					//addToParent(elParentNode, "FieldID", "205520904");

					content = (String) membersMap.get(person.SELECT_ID);
					addToParent(elParentNode, "Value", content);
					resourceCounter++;

					// find the person id of the person with the given Last name First Name
					// if it is not found then add to the _personInfo for caching
					if (_personInfo != null && _personInfo.get(personName) == null) {
						// found new Last Name First Name, add to cache
						// this will be reused when the user adds the user as task assignee
						_personInfo.put(personName, membersMap.get(person.SELECT_NAME));
					}
				}
			}

			elParentNode = elProjectRoot;
			Element elAssignmentsNode = new Element("Assignments");
			elParentNode.addContent(elAssignmentsNode);

			// Loops through all the task of the project to get the task info
			ListIterator itr = taskList.listIterator();
			StringList taskSubIds = new StringList();

			while (itr.hasNext()) {
				Map map = new HashMap();
				map = (Map) itr.next();
				getTaskStructure(context, map, elTasksNode, taskSubIds,1, projectType);
				//getTaskStructure(context, map, elTasksNode, elResourcesNode, elAssignmentsNode, resourceIndexMap, 1);
			}

			Object[] objectIdList = taskSubIds.toArray();
			String[] taskIdArray = Arrays.copyOf(objectIdList, objectIdList.length, String[].class);

			MapList assignInfoList = getAssignmentInfo(context, taskIdArray);

			//get Resource and Assignment structure
			getResc_AssignmentStructure(context, taskIdArray, assignInfoList, elResourcesNode,elAssignmentsNode,resourceIndexMap);

			elResponseRoot.setAttribute("result", "success");
			if (debug) {
				System.out.println("Sending processed SubProject XML back to MS Project...Done");
				xmlfileGen_EndTime = System.currentTimeMillis();

				long total_xmlfileGenTime = xmlfileGen_EndTime - xmlfileGen_BeginTime;
				System.out.println("TOTAL TIME in executeCheckoutSubproject (in secs) " + total_xmlfileGenTime / 1000);
				System.out.println("================ END executeCheckoutSubproject ================");
			}

			return elProjectRoot;
		} catch (Exception e) {
			// e.printStackTrace();
			System.out.println("{Exception executeCheckoutSubproject} : " + e.getMessage());
			throw new MatrixException(e.getMessage());
		}
	}

	/**
	 * Get an XML string representing the Project Space.
	 * @param busid String value of the BusID identifying the Project Space object
	 * @throws Exception if the operation fails
	 */
	protected void getTaskStructure(Context context,
			Map     	taskDetailsMap,
			Element 	elTasksNode,
			StringList 	taskIds ,				  
			int     	currentLevel,
			String projectType) throws Exception
	{
		if (debug) {
			System.out.println("================ START getTaskStructure ================" + taskDetailsMap);
			getTaskStructure_startTime = System.currentTimeMillis();
		}

		Task newTask = new Task();

		String currentTaskId = (String) taskDetailsMap.get(task.SELECT_ID);
		String parentProjectId = (String)taskParentMap.get(currentTaskId);
		String taskCounter = (String)taskIndexMap.get(currentTaskId);
		taskIds.add(currentTaskId);

		newTask.setId(currentTaskId);

		// determine dependencies
		String preType = new String();
		String preId = new String();
		String lagTime = "0";
		preType = "";

		Object listPreds = (Object) taskDetailsMap.get(task.SELECT_PREDECESSOR_IDS);

		Object listTypes = (Object) taskDetailsMap.get(task.SELECT_PREDECESSOR_TYPES);

		Object listPredsLagTime = (Object) taskDetailsMap.get(task.SELECT_PREDECESSOR_LAG_TIMES);

		Element elCurrentNode = null;
		Element elParentNode = null;
		Element elTaskNode = null;
		String content = "";

		elTaskNode = new Element("Task");
		elTasksNode.addContent(elTaskNode);
		elParentNode = elTaskNode;

		int parentIndx1 = projectList.indexOf(parentProjectId);
		String sTaskOID  = String.valueOf(taskCounter);
		content = Integer.toString(parentIndx1) + "#" + sTaskOID;
		addToParent(elParentNode, "UID", content);
		addToParent(elParentNode, "ID", sTaskOID);
		addToParent(elParentNode, "OutlineNumber", (String) taskDetailsMap.get("attribute[Task WBS]"));

		addToParent(elParentNode, "Policy", (String) taskDetailsMap.get(SELECT_POLICY));

		/*WorkCalendar taskCalendar = WorkCalendar.getCalendar(context,currentTaskId);

		if (taskCalendar != null) {			
			addToParent(elParentNode, "Calendar", taskCalendar.getId(context));
			addToParent(elParentNode, "CalendarName", taskCalendar.getName(context));
		}*/

		SetTaskDetailsForClientXML(elParentNode, taskColAttrMap,taskDetailsMap);

		String effortDrivenFlag = "0";
		addToParent(elParentNode, "EffortDriven", effortDrivenFlag);
		elCurrentNode = new Element("ExtendedAttribute");
		elParentNode.addContent(elCurrentNode);

		elParentNode = elCurrentNode;
		//content = String.valueOf(taskCounter);
		addToParent(elParentNode, "UID", sTaskOID);
		//addToParent(elParentNode, "FieldID", "188743731");
		content = (String) taskDetailsMap.get(task.SELECT_ID);
		addToParent(elParentNode, "Value", content);

		elParentNode = elTaskNode;
		// create predecessor(dependency) tags
		if (listPreds == null) {

			preType = "";
			preId = "";
			lagTime = "0";
		} else if (listPreds instanceof String) {

			String predId = (String) listPreds;
			preId = (String) taskIndexMap.get(predId);
			String preParentId = (String) taskParentMap.get(predId);

			int preParentIndx = projectList.indexOf(preParentId);

			if (preParentIndx >= 0) {
				preId = preParentIndx + "#" + preId;
			}

			preType = (String) listTypes;
			lagTime = (String) listPredsLagTime;

			if (lagTime.charAt(0) != '-' && !lagTime.equals("0")) {
				lagTime = "+" + lagTime;
			} else if (lagTime.equals("0")) {
				lagTime = "+0";
			}

			if (preId == null) {
				// preString = "*"; //external ids not supported in MSP
			} else {
				elCurrentNode = new Element("PredecessorLink");
				elParentNode.addContent(elCurrentNode);
				elParentNode = elCurrentNode;

				content = preId;
				addToParent(elParentNode, "PredecessorUID", content);
				String mspPreType = getPredecessorType(preType, true);
				addToParent(elParentNode, "Type", mspPreType);
				addToParent(elParentNode, "LinkLag", lagTime);

				// set the parent node back to the task
				elParentNode = elTaskNode;
			}
		} // else if (listPreds instanceof String)
		else if (listPreds instanceof StringList) {
			StringList sl = (StringList) listPreds;
			StringList st = (StringList) listTypes;
			StringList sLag = (StringList) listPredsLagTime;

			for (int k = 0; k < sl.size(); k++) {
				String predId = (String) (String) sl.elementAt(k);
				preId = (String) taskIndexMap.get(predId);
				String preParentId = (String) taskParentMap.get(predId);
				int preParentIndx = projectList.indexOf(preParentId);

				if (preParentIndx >= 0) {
					preId = preParentIndx + "#" + preId;
				}
				if (preId != null) {

					preType = (String) st.elementAt(k);
					lagTime = (String) sLag.elementAt(k);
					if (lagTime.charAt(0) != '-' && !lagTime.equals("0")) {
						lagTime = "+" + lagTime;
					} else if (lagTime.equals("0")) {
						lagTime = "+0";
					}

					String mspPreType = getPredecessorType(preType, true);
					elCurrentNode = new Element("PredecessorLink");
					elParentNode.addContent(elCurrentNode);
					elParentNode = elCurrentNode;

					content = preId;
					addToParent(elParentNode, "PredecessorUID", content);
					addToParent(elParentNode, "Type", mspPreType);
					addToParent(elParentNode, "LinkLag", lagTime);

					// set the parent node back to the task
					elParentNode = elTaskNode;
				}
			} // for (int k =0; k < sl.size(); k++)
		} // else if (listPreds instanceof StringList)

		// check if the current task has sub-tasks and build the sub-task structure
		if (((String) taskDetailsMap.get(task.SELECT_HAS_SUBTASK)).equalsIgnoreCase("true") &&
				(!slProjectSpaceSubTypes.contains((String)taskDetailsMap.get(task.SELECT_TYPE)))) {

			StringList taskSelects = new StringList();
			taskSelects.add(SELECT_ID);
			taskSelects.add(SELECT_POLICY);
			taskSelects.add(SELECT_PREDECESSOR_IDS);
			taskSelects.add(SELECT_PREDECESSOR_TYPES);
			taskSelects.add(SELECT_PREDECESSOR_LAG_TIMES);
			taskSelects.add(task.SELECT_HAS_SUBTASK);			
			taskSelects.add(SELECT_ATTRIBUTE_PROJECT_SCHEDULE_FROM);
			//taskSelects.add(SELECT_TASK_CALENDAR);

			//Filter the TaskSelect w.r.t the Project type			
			if(projectType != null && !projectType.isEmpty())
			{
				StringList taskBusSelect = new StringList();
				StringList taskRelSelect = new StringList();
				GetTypeSpecificTaskSelectables(context, projectType, taskBusSelect, taskRelSelect);

				if(taskBusSelect.size() != 0 || taskRelSelect.size() != 0)
				{
					taskSelects.addAll(taskBusSelect);
					taskRelSelectable = taskRelSelect;
				}
				else
				{
					taskSelects.addAll(taskSelectable);
				}
			}

			addToParent(elParentNode, "Type", "1");
			addToParent(elParentNode, "Summary", "1");
			//addToParent(elParentNode, "Rollup", "1");
			content = Integer.toString(currentLevel++);
			addToParent(elParentNode, "OutlineLevel", content);

			MapList subTaskList = newTask.getTasks(context, newTask, 1, taskSelects, taskRelSelectable);

			// Loop through the subtask of the current task and get the task info
			ListIterator itr = subTaskList.listIterator();

			while (itr.hasNext()) {

				Map subTaskMap = (Map) itr.next();

				getTaskStructure(context, subTaskMap, elTasksNode, taskIds, currentLevel, projectType);
			}
		}
		//else if (isProjectSpace(context, (String) map.get(task.SELECT_TYPE)) == true) {
		else if(slProjectSpaceSubTypes.contains((String)taskDetailsMap.get(task.SELECT_TYPE))) {
			addToParent(elParentNode, "Type", "1");
			addToParent(elParentNode, "Summary", "1");
			//addToParent(elParentNode, "Rollup", "1");
			content = Integer.toString(currentLevel++);
			addToParent(elParentNode, "OutlineLevel", content);

			Element elFFCRoot = new Element("transaction");
			elFFCRoot.setAttribute("cname", "findforcheckout");

			// now create placeholder for response
			Element elResponseArgumentsNode = new Element("arguments");
			elFFCRoot.addContent(elResponseArgumentsNode);

			// create the busid argument placeholder
			Element elBusIdArgument = new Element("argument");
			elBusIdArgument.setAttribute("name", "busid");
			elBusIdArgument.setText(currentTaskId);
			elResponseArgumentsNode.addContent(elBusIdArgument);

			// create the edit status argument placeholder on Merge to ematrix the edit flag will be reset to false
			// the user will have to explicitly "Launch the project in Edit mode in order to make any further changes
			Element elEditStatusArgument = new Element("argument");
			elEditStatusArgument.setAttribute("name", "foredit");
			elEditStatusArgument.setText("true");
			elResponseArgumentsNode.addContent(elEditStatusArgument);

			String fileName = dumpTransactionXMLForServlet(elFFCRoot);

			Element elSubprojectNode = executeCheckoutSubproject(context, new String[] {fileName});
			elParentNode.addContent(elSubprojectNode);
		} //else if(isProjectSpace(context,(String)map.get(task.SELECT_TYPE))==true)
		else {
			/**
			Definition values for DefaultTaskType
			0 = Fixed Unit
			1 = Fixed Duration
			2 = Fixed Work
			 */
			// Because the task is currently set to "Fixed Unit" always the duration on the client is in-correct when 
			// resource allocation is supported. PMC Only supports "Fixed Duration" at this time, so the integration
			// should support only "Fixed Duration which is 1
			addToParent(elParentNode, "Type", "1");

			addToParent(elParentNode, "Summary", "0");
			//addToParent(elParentNode, "Rollup", "0");
			content = Integer.toString(currentLevel++);
			addToParent(elParentNode, "OutlineLevel", content);
		}

		if (debug) {
			getTaskStructure_endTime = System.currentTimeMillis();
			long getTaskStructure_totalTime = getTaskStructure_endTime - getTaskStructure_startTime;
			System.out.println("TOTAL TIME required in getTaskStructure " + getTaskStructure_totalTime / 1000);
			System.out.println("================ END getTaskStructure ================");
		}
	}

	/**
	 * Get an XML string representing the Project Space.
	 *
	 * @param busid String value of the BusID identifying the Project Space object
	 * @throws Exception if the operation fails
	 */
	/*public String executeSynchronizeFromeMatrix(Context context, String[] args) throws MatrixException {

		return executeFindForCheckout(context, args);
	}*/

	public String executeProjectExistenceCheck(Context context, String[] args) throws MatrixException {
		try {
			Element elCommandRoot = loadXMLSentFromServlet(args[0]);
			Element elCommandArguments = elCommandRoot.getChild("arguments");

			List lArguments = elCommandArguments.getChildren("argument");
			ListIterator litCtr = lArguments.listIterator();

			String strBusId = "";
			Boolean bExistingProject = false;

			while (litCtr.hasNext()) {
				Element elArgument = (Element) litCtr.next();

				if (elArgument.getAttributeValue("name").equals("busid")) {
					strBusId = elArgument.getText();

					if (strBusId != null && !strBusId.equals("")) {
						bExistingProject = "true".equalsIgnoreCase(MqlUtil.mqlCommand(context, "print bus '" + strBusId + "' select exists dump", true));
					}
				}
			}
			Element elRespCommandRoot = loadXMLSentFromServlet(args[0]);
			Element elResponseRoot = new Element("transaction");

			elResponseRoot.setAttribute("cname", elRespCommandRoot.getAttributeValue("cname"));

			Element isProjectExist = new Element("ProjectExist");
			isProjectExist.setText(bExistingProject.toString());
			elResponseRoot.addContent(isProjectExist);
			String sOwner = "";
			Boolean bIsLoggedInSameAsOwner = false;
			if (bExistingProject == true) {
				DomainObject obj = new DomainObject(strBusId);
				sOwner = obj.getInfo(context, SELECT_OWNER);
				bIsLoggedInSameAsOwner = (sOwner.equals(context.getUser())) ? true : false;
			}

			Element elIsLoggedinOwner = new Element("LoggedinIsOwner");
			elIsLoggedinOwner.setText(bIsLoggedInSameAsOwner.toString());
			elResponseRoot.addContent(elIsLoggedinOwner);

			elResponseRoot.setAttribute("result", "success");
			String xmlOut = dumpTransactionXMLForServlet(elResponseRoot);

			return xmlOut;
		} catch (Exception e) {
			e.printStackTrace();
			throw new MatrixException(e.getMessage());
		}
	}

	/**
	 * Get an XML string representing the Project Space.
	 * @param busid String value of the BusID identifying the Project Space object
	 * @throws Exception if the operation fails
	 */
	public String executeSynchronizeMerge(Context context, String[] args) throws MatrixException {

		codeRegn = "inside executeSynchronizeMerge";
		if (debug) {
			System.out.println("================ START executeSynchronizeMerge ================");
			mergeStartTime = System.currentTimeMillis();
		}
		try {
			ContextUtil.startTransaction(context, true);
			tasks = (Map) new HashMap();

			// this reflects the user modified project in MS Project
			Element elProjectRoot = null;
			// this reflects the project data when user downloaded the project for modification
			Element elOldProjectRoot = null;

			Element elCommandRoot = loadXMLSentFromServlet(args[0]); // load the xml

			// get the projectXml, Original Project XML
			Element elCommandArguments = elCommandRoot.getChild("arguments");

			List lArguments = elCommandArguments.getChildren("argument");
			ListIterator litCtr = lArguments.listIterator();

			String strBusId = "";
			boolean existingProject = false;

			while (litCtr.hasNext()) {
				Element elArgument = (Element) litCtr.next();

				if (elArgument.getAttributeValue("name").equals("busid")) {
					strBusId = elArgument.getText();
					project.setId(strBusId);
					if (strBusId != null && !strBusId.equals("")) {
						existingProject = "true".equalsIgnoreCase(MqlUtil.mqlCommand(context, "print bus '" + strBusId + "' select exists dump", true));
					}
					if (existingProject) {
						// determine if user can edit
						boolean editFlag = project.checkAccess(m_ctxUserContext, (short) AccessConstants.cModify);
						if (!editFlag) {
							String stringValue = "";
							try {
								stringValue = EnoviaResourceBundle.getProperty(context, "IntegrationFramework",
										"emxIEFDesignCenter.Common.NoModify", userLanguage);
							} catch (Exception ex) {
								if (debug)
									System.out.println("[emxMSProjectIntegration.executeSynchronizeMerge] No modify access. ERROR : " + ex.getMessage());
								stringValue = "No modify access";
								throw new Exception(stringValue + ": " + ex.getMessage());
							}
						}
					}
				}
				if (elArgument.getAttributeValue("name").equals("projectxml")) {
					elProjectRoot = elArgument.getChild("Project");
				} else if (elArgument.getAttributeValue("name").equals("prevprojectxml")) {
					elOldProjectRoot = elArgument.getChild("Project");
				}
			} // while (litCtr.hasNext())

			Map taskIndexMap = new HashMap();
			MapList dependencyMapList = new MapList();
			// newProjectMap collects data of current project coming from MS Project through tempCommand.xml
			Map newProjectMap = readXMLDataForMerge(context, elProjectRoot, existingProject, true, taskIndexMap, dependencyMapList);
			if (debug)
				System.out.println("Read XML for MS Project data...done");

			// obtain project info, task info, resource map, assignments
			Map prjInfoMap = (Map) newProjectMap.get("projectData");
			Map resourceIndexMap = (Map) newProjectMap.get("resourceIndexMap");
			// StringList resourceList = (StringList) newProjectMap.get("resourceList");
			MapList assigneeMapList = (MapList) newProjectMap.get("assigneeMapList");
			MapList taskDataMapList = (MapList) newProjectMap.get("taskData");

			Map taskLevelMap = (Map) newProjectMap.get("taskLevelMap");
			//Map taskUnitMap = (Map) newProjectMap.get("taskUnitsDataMap");

			String owner = ProgramCentralConstants.EMPTY_STRING;
			String estStartDate = ProgramCentralConstants.EMPTY_STRING;
			String estFinishDate = ProgramCentralConstants.EMPTY_STRING;
			//String constraintDate = ProgramCentralConstants.EMPTY_STRING;
			//String actStartDate = ProgramCentralConstants.EMPTY_STRING;
			//String actFinishDate = ProgramCentralConstants.EMPTY_STRING;

			// IR-092738V6R2013 begin
			ArrayList<String> inValidResourceNamesList = new ArrayList<String>();
			if (assigneeMapList.size() != 0) {

				Map resourceNameMap = (Map) newProjectMap.get("resourceNameMap");
				ListIterator listAssignmentCtr = assigneeMapList.listIterator();
				while (listAssignmentCtr.hasNext()) {

					Map assigneeMap = (Map) listAssignmentCtr.next();
					String resourceUID = (String) assigneeMap.get("resourceUID");
					String personID = (String) resourceIndexMap.get(resourceUID);
					String personNm = ProgramCentralConstants.EMPTY_STRING;
					if (ProgramCentralConstants.EMPTY_STRING.equalsIgnoreCase(personID)) {

						personNm = (String) resourceNameMap.get(resourceUID);
						inValidResourceNamesList.add(personNm);
					}
				}
				if (inValidResourceNamesList.size() > 0) {
					return executeResponseForValidateResource(args, inValidResourceNamesList,"invalidresource");
				}
				// IR-092738V6R2013 end
			}
			if (!existingProject) {

				if (debug)
					System.out.println("existingProject = " + existingProject);

				taskLevelMap.clear();
				taskIndexMap.clear();
				// busId does not exist, the xml supplied is for a brand new project
				// get details of the project and create project
				String projectName = (String) prjInfoMap.get("Name");

				String schedulefromstart = (String) prjInfoMap.get("ScheduleFrom");
				//String constraintTypeForProject = (String) prjInfoMap.get("ConstraintType");

				String description = (String) prjInfoMap.get("Description");
				owner = (String) prjInfoMap.get("Owner");

				sProjectSchduleBasedOn = (String) prjInfoMap.get("ScheduleBasedOn");

				//String ctxPersonId = person.getPerson(context).getId(context);
				//person.setId(ctxPersonId);
				String userVault = context.getVault().getName();// person.getVault();		

				String projectType = "";
				ListIterator Itr = taskDataMapList.listIterator();
				if (Itr.hasNext()) {
					Map projectMap = (Map) Itr.next();
					projectType = (String) projectMap.get("NodeType");
				}
				mspiCreateProject(context, project, projectType, projectName, userVault);
				codeRegn = "created new project ";
				if (debug)
					System.out.println(codeRegn);
				project.setDescription(context, description);

				//Project Calendar
				/*String prjCalendar = (String) prjInfoMap.get("ProjectCalendar");
				if (!prjCalendar.isEmpty()) {
					prjCalendar.concat("|DefaultCalendar");
					StringList cal_List = new StringList();
					cal_List.addElement(prjCalendar);
					project.addCalendars(context, cal_List);
				}*/

				Map projectAttributes = new HashMap();
				Set<String> prjColKeys = new HashSet<String>(projectColAttrMap.keySet());
				Set<String> taskColKeys = new HashSet<String>(taskColAttrMap.keySet());

				Iterator<String> prjColKeysIter = prjColKeys.iterator();			  

				while(prjColKeysIter.hasNext()) {

					Map colSettingMap = new HashMap();
					String sProjectSelectable = prjColKeysIter.next();
					colSettingMap = projectColAttrMap.get(sProjectSelectable);

					String columnName = (String)colSettingMap.get("Name");

					if(columnName.equals("Owner") || columnName.equals("Description") || 
							columnName.equals("NodeType") || columnName.equals("Name") || columnName.equals("Company"))
						continue;
					if((String) prjInfoMap.get(columnName) != null)
					{
						String sProjKey = null;
						if(sProjectSelectable.contains("attribute")) 
							sProjKey = sProjectSelectable.substring(sProjectSelectable.indexOf("[") + 1, sProjectSelectable.indexOf("]"));
						else
							sProjKey = sProjectSelectable;
						projectAttributes.put(sProjKey, (String) prjInfoMap.get(columnName));
					}
				}

				if(schedulefromstart.equals("Project Start Date"))
					projectAttributes.put(ATTRIBUTE_TASK_CONSTRAINT_DATE, (String) prjInfoMap.get("ProjectStart"));
				else
					projectAttributes.put(ATTRIBUTE_TASK_CONSTRAINT_DATE, (String) prjInfoMap.get("ProjectFinish"));

				project.setAttributeValues(context,projectAttributes);

				strBusId = project.getId(context);			   
				ListIterator taskDataItr = taskDataMapList.listIterator();
				String outlineNumber = ProgramCentralConstants.EMPTY_STRING;
				String taskUID = ProgramCentralConstants.EMPTY_STRING;
				//String taskReq = ProgramCentralConstants.EMPTY_STRING;

				if (taskDataItr.hasNext()) {

					Map nodeMap = (Map) taskDataItr.next();

					estStartDate = (String) nodeMap.get("Start");
					estFinishDate = (String) nodeMap.get("Finish");
					String percentComplete = (String) nodeMap.get("PercentComplete");
					String estDuration = (String) nodeMap.get("Duration");
					String actDuration = (String) nodeMap.get("ActualDuration");

					Map attributeMap = new HashMap(); // set the attribute values into a map

					attributeMap.put(ATTRIBUTE_TASK_ESTIMATED_START_DATE, estStartDate);
					attributeMap.put(ATTRIBUTE_TASK_ESTIMATED_FINISH_DATE, estFinishDate);

					if (percentComplete != null && !percentComplete.equals("0"))
						attributeMap.put(ATTRIBUTE_PERCENT_COMPLETE, percentComplete);

					if (estDuration != null && estDuration.length() > 0)
						attributeMap.put(ATTRIBUTE_TASK_ESTIMATED_DURATION, estDuration);

					if (actDuration != null && actDuration.length() > 0)
						attributeMap.put(ATTRIBUTE_TASK_ACTUAL_DURATION, actDuration);

					codeRegn = "setting project attribute values ";
					if (debug)
						System.out.println(codeRegn);
					project.setAttributeValues(context, attributeMap);
				} // if(taskDataItr.hasNext())

				codeRegn = "create tasks";
				//Map taskActualDataList = new HashMap();
				while (taskDataItr.hasNext()) {

					//Map taskActualDataMap = new HashMap();
					project.setId(strBusId);
					Map nodeMap = (Map) taskDataItr.next();
					taskUID = (String) nodeMap.get("taskUID");
					String taskName = (String) nodeMap.get("Name");
					//String constraintType = (String) nodeMap.get("ConstraintType");

					String taskDescription = (String) nodeMap.get("Description");
					outlineNumber = (String) nodeMap.get("OutlineNumber");
					if (debug) {
						System.out.println("creating task with name: " + taskName);
						System.out.println("outlineNumber : " + outlineNumber);
					}
					//taskReq = (String) nodeMap.get("taskReq");
					String taskState = (String) nodeMap.get("State");

					owner = (String) nodeMap.get("Owner");
					String taskType = (String) nodeMap.get("NodeType");

					Map subprojectMap = (Map) nodeMap.get("subprojectMap");

					// If Task is a subproject then control will go inside this block
					if (subprojectMap != null) {

						codeRegn = "Creating subproject";
						Map subprojectTaskIndexMap = new HashMap();
						subprojectMap.put("taskIndexMap", subprojectTaskIndexMap);
						String subprojectId = SynchronizeNewProject(context, subprojectMap);

						subprojectTaskIndexMap = (Map) subprojectMap.get("taskIndexMap");
						taskIndexMap.putAll(subprojectTaskIndexMap);

						// used for obtaining a tasks parent given a outlineNumber of the child
						taskLevelMap.put(outlineNumber, subprojectId);
						//used for building resources and dependencies
						//provides the PC taksID based on a MS Project task UID
						taskIndexMap.put(taskUID, subprojectId);

						String parentId;
						String levelId = ProgramCentralConstants.EMPTY_STRING;

						if (outlineNumber.lastIndexOf(".") == -1) {
							parentId = strBusId;
						} else {
							levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
							parentId = (String) taskLevelMap.get(levelId);
						}

						task.setId(parentId);
						//String[] childIds = new String[1];
						//childIds[0] = subprojectId;
						//task.addExisting(context, childIds, parentId);
						task.addExistingForMSProject(context, subprojectId , parentId, relSubTask);

						ProjectIds.add(subprojectId);
					} // if (subprojectMap != null)
					//else if (isProjectSpace(context, taskType) == true) {
					else if(slProjectSpaceSubTypes.contains(taskType)) {
						mspiCreateProject(context, subProject, taskType, taskName, userVault);
						String subprojectId = subProject.getId(context);
						task.setId(subprojectId);

						// used for obtaining a tasks parent given a outlineNumber of the child
						taskLevelMap.put(outlineNumber, subprojectId);
						// used for building resources and dependencies provides the PC taksID based on a MS Project task UID
						taskIndexMap.put(taskUID, subprojectId);

						subProject.setDescription(context, taskDescription);

						codeRegn = "setting the attributes ";
						estStartDate = (String) nodeMap.get("Start");
						estFinishDate = (String) nodeMap.get("Finish");
						String percentComplete = (String) nodeMap.get("PercentComplete");
						String estDuration = (String) nodeMap.get("Duration");
						String actDuration = (String) nodeMap.get("ActualDuration");
						String constraintTypeForSubProject = (String) nodeMap.get("ConstraintType");

						Map attributeMap = new HashMap(); // set the attribute values into a map

						attributeMap.put(ATTRIBUTE_TASK_ESTIMATED_START_DATE, estStartDate);
						attributeMap.put(ATTRIBUTE_TASK_ESTIMATED_FINISH_DATE, estFinishDate);
						attributeMap.put(ATTRIBUTE_DEFAULT_CONSTRAINT_TYPE, constraintTypeForSubProject);

						if (percentComplete != null && !percentComplete.equals("0"))
							attributeMap.put(ATTRIBUTE_PERCENT_COMPLETE, percentComplete);

						if (estDuration != null && estDuration.length() > 0)
							attributeMap.put(ATTRIBUTE_TASK_ESTIMATED_DURATION, estDuration);

						if (actDuration != null && actDuration.length() > 0)
							attributeMap.put(ATTRIBUTE_TASK_ACTUAL_DURATION, actDuration);

						codeRegn = "setting new subproject attribute values ";
						subProject.setAttributeValues(context, attributeMap);
						subProject.setAttributeValue(context, ATTRIBUTE_SCHEDULEBASEDON, sProjectSchduleBasedOn); // set ScheduleBasedOn  value same as Parent Project
						String parentId;

						if (outlineNumber.lastIndexOf(".") == -1) {
							parentId = strBusId;
						} else {
							String levelId = ProgramCentralConstants.EMPTY_STRING;
							levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
							parentId = (String) taskLevelMap.get(levelId);
						}

						task.setId(parentId);
						String[] childIds = new String[1];
						childIds[0] = subprojectId;
						task.addExisting(context, childIds, parentId);

						ProjectIds.add(subprojectId);
					} // else if (isProjectSpace(context,taskType)==true)
					else {

						// START:Added:P6E:16-Aug-2011:PRG:R213:Bug 121547V6R2013
						// task retaining policy of previous task, to get rid off that Initializing task again.
						task = (Task) DomainObject.newInstance(m_ctxUserContext, DomainConstants.TYPE_TASK, DomainConstants.PROGRAM);
						// End:P6E:16-Aug-2011:PRG:R213:Bug 121547V6R2013

						if (outlineNumber.lastIndexOf(".") == -1) {
							// if outlineNumber == "-1" then these are direct children of project
							boolean retValue = mspiCreateTask(context, task, taskType, taskName, project, true);
						} else {
							String levelId = ProgramCentralConstants.EMPTY_STRING;
							levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
							String parentId = (String) taskLevelMap.get(levelId);

							/*if (debug) {
								System.out.println("levelId : " + levelId);
								System.out.println("parentId : " + parentId);
							}*/
							parentTask.setId(parentId);
							boolean retValue = mspiCreateTask(context, task, taskType, taskName, parentTask, false);
						}

						task.setDescription(context, taskDescription);
						if (taskState != null && !taskState.equals(""))
							task.setState(context, taskState);
						task.setOwner(context, owner);

						/*String calendarID = (String) nodeMap.get("taskCalendar");
						if (calendarID != null && !calendarID.isEmpty())
							task.addCalendar(context, calendarID);*/

						String currentTaskId = task.getId(context);
						// used for obtaining a tasks parent given a outlineNumber of the child
						taskLevelMap.put(outlineNumber, currentTaskId);
						//used for building resources and dependencies
						//provides the PC taksID based on a MS Project task UID
						taskIndexMap.put(taskUID, currentTaskId);

						Map attributeMap = new HashMap();
						Iterator<String> taskColKeysIter = taskColKeys.iterator();
						while(taskColKeysIter.hasNext()) {

							Map colSettingMap = new HashMap();
							String sTaskSelectable = taskColKeysIter.next();
							colSettingMap = taskColAttrMap.get(sTaskSelectable);
							String columnName = (String)colSettingMap.get("Name");

							// below keys needs to skip as details of this needs to handle with different API
							if(basicfieldsToIgnoreInSave.contains(columnName)) 
								continue;
							String sValue = (String) nodeMap.get(columnName);
							String sKey = null;
							if(sValue != null && !sValue.equals(""))
							{

								if(sTaskSelectable.contains("attribute")) 
									sKey = sTaskSelectable.substring(sTaskSelectable.indexOf("[") + 1, sTaskSelectable.indexOf("]"));
								else
									sKey = sTaskSelectable;								  
							}
							if(sKey != null) {
								if(scheduleFieldsInSave.contains(columnName)){

									String columnType = (String)colSettingMap.get("MPIColumnType");

									if(columnType.equals("date")) {
										if(sValue.length() > 0)
										{
											Date tempDate = MATRIX_DATE_FORMAT.parse(sValue);
											addUpdate(tasks, currentTaskId, sKey, tempDate);
										}
										else
											attributeMap.put(sKey, "");
									}
									else
										addUpdate(tasks, currentTaskId, sKey, sValue);
								}
								else
									attributeMap.put(sKey, sValue);
							}
						}
						// setting task attribute values
						task.setAttributeValues(context, attributeMap);
					}
				} // while (taskDataItr.hasNext())

				if (dependencyMapList != null) {
					codeRegn = "adding dependency";
					if (debug)
						System.out.println(codeRegn);
					// create dependencies for the project created/updated
					MapList pcDependencyMapList = convertDependency(dependencyMapList, taskIndexMap, null);
					// commenting out the previous fix
					// addDependency(context, pcDependencyMapList, null, taskIndexMap);
					addDependency(context, pcDependencyMapList, null, taskIndexMap, false);
				}

				if (assigneeMapList.size() != 0) {
					// create assignees for project created/updated
					// addAssignees(context, assigneeMapList, resourceIndexMap,taskIndexMap, null, null, null);
					addAssignees(context, assigneeMapList, resourceIndexMap, taskIndexMap, null, null, null/*, taskUnitMap*/);
				}
			} // if(!existingProject)

			// This else-block comes into picture when project is already present in PRG
			else {
				// [added for sub project support]
				//String ctxPersonId = person.getPerson(context).getId(context);
				//person.setId(ctxPersonId);
				String userVault = context.getVault().getName();  //person.getVault();
				// [/added for sub project support]

				Map oldTaskIndexMap = new HashMap();
				MapList oldDependencyMapList = new MapList();
				Map oldProjectMap = readXMLDataForMerge(context, elOldProjectRoot, existingProject, false, oldTaskIndexMap, oldDependencyMapList);

				// Get the data of the old project
				Map oldPrjInfoMap = (Map) oldProjectMap.get("projectData");
				Map oldResourceIndexMap = (Map) oldProjectMap.get("resourceIndexMap");
				// StringList oldResourceList = (StringList) oldProjectMap.get("resourceList");
				MapList oldAssigneeMapList = (MapList) oldProjectMap.get("assigneeMapList");
				MapList oldTaskDataMapList = (MapList) oldProjectMap.get("taskData");
				Map taskLevelMapOld = (Map) oldProjectMap.get("taskLevelMap");

				// Map oldTaskUnitMap = (Map) oldProjectMap.get("taskUnitsDataMap");
				HashMap NextOutlineMap = new HashMap();
				//HashMap TaskLevelMap = new HashMap();
				//HashMap TaskLevelMapOld = new HashMap();
				// check if there is any modification in project name and description
				// and update accordingly -
				// case 1: only the MS Project user modified the project data
				// case 2: only the PC user modified the project data
				//case 3: the PC user as well as the MS Project user modified the project data
				//
				// NOTE: for case 2 and case 3 do nothing MSProject is the master

				// project-
				// Define selectables for each Task object.
				/*StringList busSelects = new StringList(4);
				busSelects.add(SELECT_NAME);
				busSelects.add(SELECT_DESCRIPTION);
				busSelects.add(SELECT_ATTRIBUTE_PROJECT_SCHEDULE_FROM);
				busSelects.add(SELECT_TASK_CONSTRAINT_DATE);*/

				//project.setId(strBusId);
				project.open(context);
				sProjectSchduleBasedOn = (String) prjInfoMap.get("ScheduleBasedOn");

				// for case 2 and case 3 do nothing MSProject is the master
				if(!(oldPrjInfoMap.get("Name")).equals(prjInfoMap.get("Name")))
				{
					project.setName(context, (String) prjInfoMap.get("Name"));				   
				}
				if(!(oldPrjInfoMap.get("Description")).equals(prjInfoMap.get("Description")))
				{
					project.setDescription(context, (String) prjInfoMap.get("Description"));			
				}
				if(prjInfoMap.get("ScheduleFrom").equals("Project Start Date")) {

					project.setAttributeValue(context, ATTRIBUTE_TASK_CONSTRAINT_DATE,(String) prjInfoMap.get("ProjectStart"));				 
				}
				else if(prjInfoMap.get("ScheduleFrom").equals("Project Finish Date")) {

					project.setAttributeValue(context, ATTRIBUTE_TASK_CONSTRAINT_DATE,(String) prjInfoMap.get("ProjectFinish"));				  
				}

				/*String newProjectCalendar = (String)prjInfoMap.get("ProjectCalendar");
				String oldProjectCalendar = (String)oldPrjInfoMap.get("ProjectCalendar");

				if (!newProjectCalendar.isEmpty()&&!oldProjectCalendar.equals(newProjectCalendar)) {

					project.addCalendars(context,  new StringList(newProjectCalendar));
				}*/
				Map projectAttributes = new HashMap();
				if(!(oldPrjInfoMap.get("ScheduleFrom")).equals(prjInfoMap.get("ScheduleFrom")))
				{
					String projectScheduleFrom = (String) prjInfoMap.get("ScheduleFrom");
					String projectConstraintType = "As Soon As Possible";
					if(projectScheduleFrom.equals("Project Finish Date"))
						projectConstraintType = "As Late As Possible";

					projectAttributes.put(ATTRIBUTE_PROJECT_SCHEDULE_FROM, projectScheduleFrom);
					projectAttributes.put(ATTRIBUTE_DEFAULT_CONSTRAINT_TYPE, projectConstraintType);
				}
				Set<String> projectColKeys = new HashSet<String>(projectColAttrMap.keySet());
				Iterator<String> projectColKeysIter = projectColKeys.iterator();
				while(projectColKeysIter.hasNext()) {

					Map colSettingMap = new HashMap();
					String sProjectSelectable = projectColKeysIter.next();
					colSettingMap = projectColAttrMap.get(sProjectSelectable);
					String columnName = (String)colSettingMap.get("Name");

					// below keys needs to skip as details of this needs to handle with different API
					if(basicfieldsToIgnoreInSave.contains(columnName) || columnName.equals("Company") || columnName.equals("ScheduleFrom")
							|| columnName.equals("Start") || columnName.equals("Finish")) 
						continue;

					String sOldValue = (String) oldPrjInfoMap.get(columnName);
					String sNewValue = (String) prjInfoMap.get(columnName);
					String sKey = null;
					if(sProjectSelectable.contains("attribute")) 
						sKey = sProjectSelectable.substring(sProjectSelectable.indexOf("[") + 1, sProjectSelectable.indexOf("]"));
					else
						sKey = sProjectSelectable;

					boolean bTaskValueChanged = false; 
					if(sOldValue != null) 
						bTaskValueChanged = !(sOldValue.equals(sNewValue));

					if(bTaskValueChanged)
						projectAttributes.put(sKey, sNewValue);
				}

				if(projectAttributes.size() > 0)
					project.setAttributeValues(context,projectAttributes);

				project.close(context);
				// get the new data of the project
				MapList newTaskDataMapList = (MapList) newProjectMap.get("taskData");

				MapList addedList = new MapList();
				MapList removedList = new MapList();
				//MapList retainedList = new MapList();
				MapList modifiedList = new MapList();

				// generate a new maplist for comparison of structure the new maplist only consists of taskId and level (outlineNumber)
				// if there is no taskId then there is a new task added
				// if there is change in level then the task has been moved to a different level
				MapList oldStructMapList = new MapList();
				MapList newStructMapList = new MapList();
				HashMap oldDataMap = new HashMap();
				HashMap newDataMap = new HashMap();
				String parentOutline = ProgramCentralConstants.EMPTY_STRING;
				String parentId = ProgramCentralConstants.EMPTY_STRING;

				HashMap OutlineIDMap = new HashMap();
				HashMap OutlineIDMapOld = new HashMap();

				if (oldTaskDataMapList.size() > 0) {
					ListIterator oldTaskDataMapListItr = oldTaskDataMapList.listIterator();
					int i = 0;
					while (oldTaskDataMapListItr.hasNext()) {
						// skip the first value this corresponds to the project details
						HashMap buildMap = new HashMap();
						Map oldTaskMap = (Map) oldTaskDataMapListItr.next();
						if (i != 0) {
							String id = (String) oldTaskMap.get("taskId");
							String outlineNumber = (String) oldTaskMap.get("OutlineNumber");
							buildMap.put("taskId", id);
							buildMap.put("OutlineNumber", outlineNumber);

							if (outlineNumber != null && !outlineNumber.equals("0")) {
								oldStructMapList.add(buildMap);
							}

							if (outlineNumber.indexOf(".") > -1) {
								parentOutline = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
								parentId = (String) taskLevelMapOld.get(parentOutline);
								if (parentId != null)
									buildMap.put("parentTaskId", parentId);
							}
							// build an hashmap to locate the node details based on taskId as key
							// if taskId does not exist then use outlineNumber as key
							if (id != null || !id.equals("")) {
								oldDataMap.put(id, oldTaskMap);
								//TaskLevelMapOld.put(outlineNumber, id);
								OutlineIDMapOld.put(id, outlineNumber);
								Map subprojectmap = (Map) oldTaskMap.get("subprojectMap");
								if (subprojectmap != null)
									AllOldProjectIds.add(id);
							} else {
								oldDataMap.put(outlineNumber, oldTaskMap);
							}
						}
						i++;
					} // while(oldTaskDataMapListItr.hasNext())
				} // if(oldTaskDataMapList.size() > 0)

				String prevOutlineNumber = "aaaaa";

				if (newTaskDataMapList.size() > 0) {
					ListIterator newTaskDataMapListItr = newTaskDataMapList.listIterator();
					int i = 0;
					while (newTaskDataMapListItr.hasNext()) {
						HashMap buildMap = new HashMap();
						Map newTaskMap = (Map) newTaskDataMapListItr.next();
						if (i != 0) {

							String id = (String) newTaskMap.get("taskId");
							String outlineNumber = (String) newTaskMap.get("OutlineNumber");
							buildMap.put("taskId", id);
							buildMap.put("OutlineNumber", outlineNumber);

							if (outlineNumber.indexOf(".") > -1) {
								parentOutline = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
								parentId = (String) taskLevelMap.get(parentOutline);
								if (parentId != null)
									buildMap.put("parentTaskId", parentId);
							}

							NextOutlineMap.put(prevOutlineNumber, outlineNumber);
							prevOutlineNumber = outlineNumber;

							if (outlineNumber != null && !outlineNumber.equals("0")) {
								newStructMapList.add(buildMap);
							}
							// build an hashmap to locate the node details based on taskId as key
							// if taskId does not exist then use outlineNumber as key
							if (id != null && !id.equals("")) {

								newDataMap.put(id, newTaskMap);
								//TaskLevelMap.put(outlineNumber, id);
								OutlineIDMap.put(id, outlineNumber);
							} else {
								newDataMap.put(outlineNumber, newTaskMap);
							}
						} // if(i != 0)
						i++;
					} // while(newTaskDataMapListItr.hasNext())
				} // if(newTaskDataMapList.size() > 0)

				if (oldStructMapList.size() > 0 || newStructMapList.size() > 0) {
					// Get a list of all added items (new - old).
					addedList.addAll(newStructMapList);
					addedList.removeAll(oldStructMapList);

					// Get a list of all removed items (old - new).
					removedList.addAll(oldStructMapList);
					removedList.removeAll(newStructMapList);

					// store the removedList as a reference required while updating the attributes
					MapList refRemovedList = new MapList();
					refRemovedList.addAll(removedList);

					// Get a list of all retained items (new & old).
					//retainedList.addAll(oldStructMapList);
					//retainedList.retainAll(newStructMapList);

					// Get a list of tasks neither added or removed
					// but could have been modified (old - removed).
					// (no structure modification but only attribute modification)
					modifiedList.addAll(newStructMapList);

					//tasks = (Map) new HashMap();

					MapList connectionsList = new MapList();
					StringList taskIDsList = new StringList();
					String[] connectionArray = null;

					if(!addedList.isEmpty()) {
						ListIterator addedListItr = addedList.listIterator();
						StringList busSelect = new StringList();
						busSelect.add(SELECT_TO_RELATIONSHIP_SUBTASK_ID);	

						while (addedListItr.hasNext()) {
							Map addedListMap = (Map) addedListItr.next();
							String taskId = (String) addedListMap.get("taskId");

							if (taskId != null && !taskId.equals("")) {
								//the removedList has entries of same taskId since the outlineLevelNumber get modified 
								//due to structure change. If this task is handled already then remove if from the removedList
								Iterator removeItr = removedList.iterator();
								int i = 0;
								while (removeItr.hasNext()) {
									Map removedMap = (Map) removeItr.next();
									if (taskId.equals(removedMap.get("taskId"))) {
										break;
									}
									i++;
								}
								if (i < removedList.size()) {
									removedList.remove(i);
									refRemovedList.remove(i);
								}
								/*put the connectionID in map and delete them at once*/
								//if (isProjectSpace(context,(String)addedListMap.get("taskType"))== false) {
								Map taskMap = (HashMap) newDataMap.get(taskId);
								if(!slProjectSpaceSubTypes.contains((String)taskMap.get("NodeType"))) {

									//task.setId(taskId);
									//Map taskInfo = task.getInfo(context, busSelect);							  
									//String connectionId = (String) taskInfo.get(SELECT_TO_RELATIONSHIP_SUBTASK_ID);
									//connectionsList.add(connectionId);
									taskIDsList.add(taskId);
								}
							} // if(taskId != null && !taskId.equals(""))
						} // while (addedListItr.hasNext())
						String[] taskIDsArray = (String []) taskIDsList.toArray(new String[] {});
						connectionsList = DomainObject.getInfo(context, taskIDsArray, busSelect);
						connectionArray = new String[connectionsList.size()];

						for(int iItr=0; iItr < connectionsList.size();iItr++) {

							Map mapObjectInfo = (Map)connectionsList.get(iItr);
							connectionArray[iItr] = (String)mapObjectInfo.get(SELECT_TO_RELATIONSHIP_SUBTASK_ID);  
						}
					} // if(addedList != null)

					if(!addedList.isEmpty()) {
						codeRegn = "Merge- Adding the task - disconnecting the connection if there is a structure change ";

						if (connectionArray!= null && connectionArray.length > 0)
						{
							DomainRelationship.disconnect(context, connectionArray);
						}
						codeRegn = "Merge- Adding the task or parent structure change or cut/paste operation";
						ListIterator addedListItr = addedList.listIterator();

						while (addedListItr.hasNext()) {
							if (debug)
								iterationStartTime = System.currentTimeMillis();

							Map addedListMap = (Map) addedListItr.next();
							String taskId = (String) addedListMap.get("taskId");
							String outlineNumber = (String) addedListMap.get("OutlineNumber");

							Map oldTaskValueMap = new HashMap();
							Map newTaskValueMap = new HashMap();
							if ((taskId != null) && !taskId.equals("")) {
								oldTaskValueMap = (Map) oldDataMap.get(taskId);
								newTaskValueMap = (Map) newDataMap.get(taskId);
							} else {
								newTaskValueMap = (Map) newDataMap.get(outlineNumber);
							}

							String levelId = ProgramCentralConstants.EMPTY_STRING;
							String newParentId = ProgramCentralConstants.EMPTY_STRING;

							String taskUID = (String) newTaskValueMap.get("taskUID");

							// if taskUID is not found this is a special case where the addedList contains details of project skip this value
							if (taskUID == null || taskUID.equals(""))
								continue;

							if (taskId != null && !taskId.equals("") && oldTaskValueMap != null) {

								//if (isProjectSpace(context,(String)oldTaskValueMap.get("taskType"))==true)
								if(slProjectSpaceSubTypes.contains((String)oldTaskValueMap.get("NodeType"))) {

									Map newSubprojectmap = (Map) newTaskValueMap.get("subprojectMap");
									Map oldSubprojectmap = (Map) oldTaskValueMap.get("subprojectMap");

									if (newSubprojectmap != null && oldSubprojectmap != null) {

										oldSubprojectmap.put("taskIndexMap", oldTaskIndexMap);
										newSubprojectmap.put("taskIndexMap", taskIndexMap);
										SynchronizeExistingProject(context, taskId, newSubprojectmap, oldSubprojectmap, tasks);
										Map taskIndexMap2 = (Map) newSubprojectmap.get("taskIndexMap");
										Map oldTaskIndexMap2 = (Map) oldSubprojectmap.get("taskIndexMap");
										taskIndexMap.putAll(taskIndexMap2);
										oldTaskIndexMap.putAll(oldTaskIndexMap2);
									}
									// get the releationship id
									subProject.setId(taskId);
									StringList busSelect = new StringList();
									busSelect.add(SELECT_TO_RELATIONSHIP_SUBTASK_ID);
									Map taskInfo = subProject.getInfo(context, busSelect);
									String connectionId = (String) taskInfo.get(SELECT_TO_RELATIONSHIP_SUBTASK_ID);
									DomainRelationship.disconnect(context, connectionId);

									if (!outlineNumber.equals(oldTaskValueMap.get("OutlineNumber"))) {

										// structure modified for an existing subproject
										if (outlineNumber.lastIndexOf(".") == -1) {
											newParentId = strBusId;
										} else {
											levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
											newParentId = (String) taskLevelMap.get(levelId);
										}

										//task.setId(strBusId);
										task.setId(newParentId);

										/*String[] childIds = new String[1];
										childIds[0] = taskId;*/
										String nextTaskId = getNextTaskId(outlineNumber, NextOutlineMap, taskLevelMap, taskLevelMapOld, OutlineIDMap, OutlineIDMapOld);
										if (nextTaskId == null) {
											nextTaskId = newParentId;
										}
										//task.addExisting(context, childIds, nextTaskId);
										task.addExistingForMSProject(context, taskId , nextTaskId, relSubTask);
									} // if(!outlineNumber.equals(oldTaskValueMap.get("OutlineNumber")))
									ProjectIds.add(taskId);
								} // if(isProjectSpace(context,(String)oldTaskValueMap.get("NodeType"))==true)
								else {

									// get the releationship id
									task.setId(taskId);

									//Circular dependency : case 1
									//before modifying the structure of the current task check if
									//currenttask has existing predecessors which on structure change
									//will result in being the current tasks parent
									//since a parent cannot have its childern has a predecessor
									//i.e taskId cannot be a predecessor of newParentId
									MapList predList = task.getPredecessors(context, null, null, null);
									Iterator predListItr = predList.iterator();

									if (debug)
										System.out.println("Checking for Circular Dependency: case 1");

									while (predListItr.hasNext()) {

										Map predecessorObj = (Map) predListItr.next();
										String predecessorId = (String) predecessorObj.get(task.SELECT_ID);
										ArrayList taskLevelKeys = new ArrayList(taskLevelMap.keySet());
										// BUG? []: changed from predecessorObj.keySet() to taskLevelMap.keySet()
										ArrayList taskLevelValues = new ArrayList(taskLevelMap.values());

										String predLevel = null;
										if (taskLevelValues.indexOf(predecessorId) != -1) {
											int predPos = taskLevelValues.indexOf(predecessorId);

											if (taskLevelKeys.size() > predPos) {
												predLevel = (String) taskLevelKeys.get(predPos);
												//if (predLevel != null &&  outlineNumber.indexOf(predLevel) != -1)
												if (predLevel != null &&  outlineNumber.equals(predLevel))
												{
													// removing dependency of a given object
													String predConnectionId = (String) predecessorObj.get(dependency.SELECT_ID);
													task.removePredecessor(context, predConnectionId);
												}
											}
										} // end if
									} // while (predListItr.hasNext())

									// if(! outlineNumber.equals(oldTaskValueMap.get("OutlineNumber")))
									{
										// structure modified for an existing task

										if (outlineNumber.lastIndexOf(".") == -1) {

											newParentId = strBusId;// direct subtask of a project
										} else {

											levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
											newParentId = (String) taskLevelMap.get(levelId);

											// Circular dependency : case 2 before changing the parent of the current task check if
											// current task is a predecessor of the parent task since a parent cannot have its
											// Children has a predecessor i.e taskId cannot not be a predecessor of newParentId
											task.setId(newParentId);
											if (debug)
												System.out.println("Checking for Circular Dependency: case 2");

											MapList predecessorList = task.getPredecessors(context, null, null, null);
											Iterator predecessorItr = predecessorList.iterator();

											while (predecessorItr.hasNext()) {
												Map predecessorObj = (Map) predecessorItr.next();
												String predecessorId = (String) predecessorObj.get(task.SELECT_ID);
												if (predecessorId.equals(taskId)) {
													String depConnectionId = (String) predecessorObj.get(dependency.SELECT_ID);
													task.removePredecessor(context, depConnectionId);
												}
											}
											// task.setId(taskId);
										}
										task.setId(newParentId);
										//String[] childIds = new String[1];
										//childIds[0] = taskId;
										String nextTaskId = getNextTaskId(outlineNumber, NextOutlineMap, taskLevelMap, taskLevelMapOld, OutlineIDMap, OutlineIDMapOld);
										/*if (nextTaskId == null) {
											nextTaskId = newParentId;
										}*/
										task.addExistingForMSProject(context, taskId , nextTaskId, relSubTask);
										taskLevelMap.put(outlineNumber, taskId);
									} // if(! outlineNumber.equals(oldTaskValueMap.get("OutlineNumber")))
								}
							} // if(taskId != null && !taskId.equals("")&& oldTaskValueMap != null)
							else
							{
								String taskName = (String) newTaskValueMap.get("Name");
								if (debug)
								{
									System.out.println("Processing task: " + taskName);
								}
								String taskDesc = (String) newTaskValueMap.get("Description");
								owner = (String) newTaskValueMap.get("Owner");
								String taskType = (String)newTaskValueMap.get("NodeType");
								String taskState = (String)newTaskValueMap.get("State");
								//String percentComplete  = (String) newTaskValueMap.get("percentComplete");
								//estStartDate  = (String) newTaskValueMap.get("estStartDate");
								//estFinishDate  = (String) newTaskValueMap.get("estFinishDate");

								//String estDuration  = (String) newTaskValueMap.get("estDuration");

								//String constraintType=(String) newTaskValueMap.get("constraintType");
								//constraintDate=(String) newTaskValueMap.get("constraintDate");

								//actStartDate = (String) newTaskValueMap.get("actStartDate");
								//actFinishDate = (String) newTaskValueMap.get("actFinishDate");

								//String outlineLevel = (String) newTaskValueMap.get("outlineLevel");
								//String taskReq = (String) newTaskValueMap.get("taskReq");
								Map subprojectmap = (Map) newTaskValueMap.get("subprojectMap");
								//if (subprojectmap == null && isProjectSpace(context, taskType) == true)
								if (subprojectmap == null && slProjectSpaceSubTypes.contains(taskType)) {

									mspiCreateProject(context, subProject, taskType, taskName, userVault);
									String subprojectId = subProject.getId(context);
									task.setId(subprojectId);
									// used for obtaining a tasks parent given a outlineNumber of the child
									taskLevelMap.put(outlineNumber, subprojectId);
									// used for building resources and dependencies provides the PC taksID based on a MSProject task UID
									taskIndexMap.put(taskUID, subprojectId);
									subProject.setDescription(context, taskDesc);

									Map attributeMap = new HashMap();
									attributeMap.putAll(SyncCustomAttributeForNewProject(newTaskValueMap));

									String schedulefromstart = (String)newTaskValueMap.get("ScheduleFrom");

									if(schedulefromstart.equals("Project Start Date"))
										attributeMap.put(ATTRIBUTE_TASK_CONSTRAINT_DATE, (String) newTaskValueMap.get("ProjectStart"));
									else
										attributeMap.put(ATTRIBUTE_TASK_CONSTRAINT_DATE, (String) newTaskValueMap.get("ProjectFinish"));

									codeRegn = "setting subproject attribute values ";
									subProject.setAttributeValues(context, attributeMap);

									if (outlineNumber.lastIndexOf(".") == -1) {
										parentId = strBusId;
									} else {
										levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
										parentId = (String) taskLevelMap.get(levelId);
										parentTask.setId(parentId);
									}

									task.setId(parentId);
									/*String[] childIds = new String[1];
									childIds[0] = subprojectId;*/
									String nextTaskId = getNextTaskId(outlineNumber, NextOutlineMap, taskLevelMap, taskLevelMapOld, OutlineIDMap, OutlineIDMapOld);
									/*if (nextTaskId == null) {
										nextTaskId = parentId;
									}*/
									//task.addExisting(context, childIds, nextTaskId);
									task.addExistingForMSProject(context, subprojectId, nextTaskId, relSubTask);

									ProjectIds.add(subprojectId);
								} // if (isProjectSpace(context,taskType)==true)
								else {

									if (subprojectmap != null) {

										String subprojectId = SynchronizeNewProject(context, subprojectmap);
										Map subprojectTaskIndexMap = (Map) subprojectmap.get("taskIndexMap");
										taskIndexMap.putAll(subprojectTaskIndexMap);

										// used for obtaining a tasks parent given a outlineNumber of the child
										taskLevelMap.put(outlineNumber, subprojectId);
										//used for building resources and dependencies
										//provides the PC taksID based on a MS Project task UID
										taskIndexMap.put(taskUID, subprojectId);

										if (outlineNumber.lastIndexOf(".") == -1) {
											parentId = strBusId;
										} else {
											levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
											parentId = (String) taskLevelMap.get(levelId);
										}

										String nextTaskId = getNextTaskId(outlineNumber, NextOutlineMap, taskLevelMap, taskLevelMapOld, OutlineIDMap, OutlineIDMapOld);
										task.setId(parentId);
										/*String[] childIds = new String[1];
										childIds[0] = subprojectId;*/
										//task.addExisting(context, childIds, nextTaskId);
										task.addExistingForMSProject(context, subprojectId, nextTaskId, relSubTask);

										ProjectIds.add(subprojectId);
									} else {

										task = (Task) DomainObject.newInstance(m_ctxUserContext, DomainConstants.TYPE_TASK, DomainConstants.PROGRAM);// IR-185394V6R2013x
										String nextTaskId = getNextTaskId(outlineNumber, NextOutlineMap, taskLevelMap, taskLevelMapOld, OutlineIDMap, OutlineIDMapOld);

										String taskParentId = null;
										//project.setId(strBusId);

										if (outlineNumber.lastIndexOf(".") == -1) {
											// if outlineNumber == "-1" then these are direct children of project
											//taskParentId = strBusId;
											if (debug) {
												System.out.println("Creating task under project ID " + strBusId);
											}
											boolean retValue = mspiCreateTask(context, task, taskType, taskName, project, true, nextTaskId);
										} else {

											levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
											parentId = (String) taskLevelMap.get(levelId);
											parentTask.setId(parentId);
											if (debug)
												System.out.println("creating hierarchial task under " + parentId);
											//task.clear();
											taskParentId = parentId;
											if (nextTaskId == null)
												nextTaskId = taskParentId;
											boolean retValue = mspiCreateTask(context, task, taskType, taskName, parentTask, false, nextTaskId);
										}
										task.setDescription(context, taskDesc);
										if (taskState != null && !taskState.equals(""))
											task.setState(context, taskState);

										task.setOwner(context, owner);

										String newTaskId = task.getId(context);
										taskLevelMap.put(outlineNumber, newTaskId);
										taskIndexMap.put(taskUID, newTaskId);

										// set the attributes of newly created tasks
										Map attributeMap = new HashMap(taskSelectable.size());
										Set<String> taskColKeys = new HashSet<String>(taskColAttrMap.keySet());
										Iterator<String> taskColKeysIter = taskColKeys.iterator();
										while(taskColKeysIter.hasNext()) {

											Map colSettingMap = new HashMap();
											String sTaskSelectable = taskColKeysIter.next();
											colSettingMap = taskColAttrMap.get(sTaskSelectable);
											String columnName = (String)colSettingMap.get("Name");

											// below keys needs to skip as details of this needs to handle with different API
											if(basicfieldsToIgnoreInSave.contains(columnName)) 
												continue;

											String sValue = (String) newTaskValueMap.get(columnName);
											String sKey = null;
											if(sValue != null)
											{
												if(sTaskSelectable.contains("attribute")) 
													sKey = sTaskSelectable.substring(sTaskSelectable.indexOf("[") + 1, sTaskSelectable.indexOf("]"));
												else
													sKey = sTaskSelectable;											  
											}
											if(sKey != null) {
												if(scheduleFieldsInSave.contains(columnName)){

													String columnType = (String)colSettingMap.get("MPIColumnType");

													if(columnType.equals("date")) {
														if(sValue.length() > 0)
														{
															Date tempDate = MATRIX_DATE_FORMAT.parse(sValue);
															addUpdate(tasks, newTaskId, sKey, tempDate);
														}
														else
															attributeMap.put(sKey, "");
													}
													else
														addUpdate(tasks, newTaskId, sKey, sValue);
												}
												else
													attributeMap.put(sKey, sValue);
											}
										}

										task.setAttributeValues(context, attributeMap);									
									}
								} // end else
							}
							if (debug) {
								iterationEndTime = System.currentTimeMillis();
								long iterationTime = iterationEndTime - iterationStartTime;

								System.out.println("TOTAL TIME in Iteration for new tasks (in Secs): "+ (float) iterationTime / 1000);
							}
						} // while (addedListItr.hasNext())
					} // if(addedList != null)

					if (removedList.size() != 0) {
						deleteTasks(context, removedList, taskLevelMap, strBusId);
					}
					if((!removedList.isEmpty()) || (!addedList.isEmpty())) {
						task.reSequence(context, strBusId);
					}

					codeRegn = "Merge - Modify the task attributes";
					ListIterator taskDataMapListItr = taskDataMapList.listIterator();
					Map oldMap = new HashMap();
					Map mspMap = new HashMap();

					while (taskDataMapListItr.hasNext()) {

						mspMap = (Map) taskDataMapListItr.next();
					}

					int taskCounter = taskDataMapList.size();

					while (taskDataMapListItr.hasPrevious()) {
						mspMap = (Map) taskDataMapListItr.previous();

						if (taskCounter == 1) {
							continue;
						}
						taskCounter--;
						String mspTaskId = (String) mspMap.get("taskId");
						if (mspTaskId != null && !mspTaskId.equals("")) {

							ListIterator oldTaskDataMapListItr = oldTaskDataMapList.listIterator();
							while (oldTaskDataMapListItr.hasNext()) {

								oldMap = (Map) oldTaskDataMapListItr.next();
								String oldTaskId = (String) oldMap.get("taskId");
								if (oldTaskId != null && oldTaskId.equals(mspTaskId)) {
									break;
								}
							}
							// need to check whether this shud be there for sub project also
							if (ProjectIds.indexOf(mspTaskId) >= 0) {
								continue;
							}
							Map newSubprojectmap = (Map) mspMap.get("subprojectMap");
							Map oldSubprojectmap = (Map) oldMap.get("subprojectMap");

							if (newSubprojectmap != null && oldSubprojectmap != null) {

								oldSubprojectmap.put("taskIndexMap", oldTaskIndexMap);
								newSubprojectmap.put("taskIndexMap", taskIndexMap);
								SynchronizeExistingProject(context, mspTaskId, newSubprojectmap, oldSubprojectmap, tasks);
								Map taskIndexMap2 = (Map) newSubprojectmap.get("taskIndexMap");
								Map oldTaskIndexMap2 = (Map) oldSubprojectmap.get("taskIndexMap");
								taskIndexMap.putAll(taskIndexMap2);
								oldTaskIndexMap.putAll(oldTaskIndexMap2);
								continue;
							}
						} // if(mspTaskId != null && !mspTaskId.equals(""))
					} // while (taskDataMapListItr.hasPrevious())
					MapList addedDependencyList = new MapList();
					MapList removedDependencyList = new MapList();
					//MapList retainedDependencyList = new MapList();

					StringList SFDependentTaskList = new StringList();
					// update dependencies
					if (oldDependencyMapList.size() > 0 || dependencyMapList.size() > 0) {
						if (debug)
							System.out.println("update dependencies");
						// the values contained in the maplist is using uid from MS Project
						// convert it to ids of PC and compare the two maplist
						MapList pcDependencyMapList = convertDependency(dependencyMapList, taskIndexMap, SFDependentTaskList);
						MapList pcOldDependencyMapList = convertDependency(oldDependencyMapList, oldTaskIndexMap, null);
						// ready for comparison
						// Get a list of all added items (new - old).
						addedDependencyList.addAll(pcDependencyMapList);
						addedDependencyList.removeAll(pcOldDependencyMapList);
						// Get a list of all removed items (old - new).
						removedDependencyList.addAll(pcOldDependencyMapList);
						removedDependencyList.removeAll(pcDependencyMapList);
						// Get a list of all retained items (new & old).
						//retainedDependencyList.addAll(pcOldDependencyMapList);
						//retainedDependencyList.retainAll(pcDependencyMapList);
						MapList updatedRemoveDependencyList = new MapList();

						if (addedDependencyList != null) {

							// newly added or modified dependency
							updatedRemoveDependencyList = addDependency(context, addedDependencyList, removedDependencyList, taskIndexMap, true);
							if (debug)
								System.out.println("back from addDependency()");
						}
						if (updatedRemoveDependencyList.size() != 0) {
							// removed dependency
							removeDependency(context, updatedRemoveDependencyList, taskIndexMap);
							if (debug)
								System.out.println("back from removeDependency()");
						}
					} // if (oldDependencyMapList.size() > 0 || dependencyMapList.size() > 0)

					// check if the task attributes are modified and set them
					codeRegn = "Merge - Modify the task attributes";

					// get to the end of the map list the maplist is top-down wrt to the project tasks
					// when we try to save the attributes of a task if we set the parents percentage as 100% PC's trigger will block the
					// event (since the child is still 0%) so go to the end of the list and
					// start the attribute setting from the child then going upwards
					taskDataMapListItr = taskDataMapList.listIterator();
					while (taskDataMapListItr.hasNext()) {
						mspMap = (Map) taskDataMapListItr.next();
					}

					taskCounter = taskDataMapList.size();
					while (taskDataMapListItr.hasPrevious()) {
						mspMap = (Map) taskDataMapListItr.previous();
						if (taskCounter == 1) {
							continue;
						}
						taskCounter--;
						String mspTaskId = (String) mspMap.get("taskId");
						Iterator refRemovedItr = refRemovedList.iterator();
						boolean nodeInRemovedList = false;
						while (refRemovedItr.hasNext()) {
							Map refRemovedMap = (Map) refRemovedItr.next();

							if (mspTaskId.equals(refRemovedMap.get("taskId"))) {
								nodeInRemovedList = true;
								break;
							}
						}
						if (nodeInRemovedList) {
							continue;
						}

						if (mspTaskId != null && !mspTaskId.equals("")) {
							ListIterator oldTaskDataMapListItr = oldTaskDataMapList.listIterator();
							while (oldTaskDataMapListItr.hasNext()) {
								oldMap = (Map) oldTaskDataMapListItr.next();
								String oldTaskId = (String) oldMap.get("taskId");
								if (oldTaskId != null && oldTaskId.equals(mspTaskId)) {
									break;
								}
							}

							// need to check whether this should be there for sub project also
							if (ProjectIds.indexOf(mspTaskId) >= 0) {
								continue;
							}
							task.setId(mspTaskId);
							// task data when the project was downloaded
							String oldTaskName = (String) oldMap.get("Name");
							String oldTaskDesc = (String) oldMap.get("Description");
							String oldTaskOwner = (String) oldMap.get("Owner");
							String oldTaskType = (String)oldMap.get("NodeType");
							String oldTaskCurrent = (String) oldMap.get("State");
							//String oldTaskStart = (String) oldMap.get("estStartDate");
							// String oldTaskFinish = (String)oldMap.get("estFinishDate");
							/*String oldActTaskStart = "";
							String oldActTaskFinish = "";
							String mspActTaskStart = "";
							String mspActTaskFinish = "";
							boolean bActTaskStartChanged = false;
							boolean bActTaskFinishChanged = false;
							if (sProjectSchduleBasedOn.equals("Actual")) {
								if (oldMap.get("actStartDate") != null)
									oldActTaskStart = (String) oldMap.get("actStartDate");
								if (oldMap.get("actFinishDate") != null)
									oldActTaskFinish = (String) oldMap.get("actFinishDate");
							}
							String oldTaskDuration = (String) oldMap.get("estDuration");
							String oldTaskPercent = (String) oldMap.get("percentComplete");
							String oldTaskRequirement = (String) oldMap.get("taskReq");*/
							//[2011x Start: Collect ConstraintType and ConstraintDate from oldMap in String holder]
							String oldTaskConstraintType = (String) oldMap.get("ConstraintType");
							String oldTaskConstraintDate = (String) oldMap.get("ConstraintDate");

							// task Calendar
							//String oldTaskCalendar = (String) oldMap.get("taskCalendar");
							//String mspTaskCalendar = (String) mspMap.get("taskCalendar");

							// task data, as obtained from MS Project
							String mspTaskName = (String) mspMap.get("Name");
							String mspTaskDesc = (String) mspMap.get("Description");
							String mspTaskOwner = (String) mspMap.get("Owner");
							String mspTaskType =(String)mspMap.get("NodeType");
							String mspTaskCurrent = (String) mspMap.get("State");
							//String mspTaskPercent = (String) mspMap.get("percentComplete");
							//String mspTaskStart = (String) mspMap.get("estStartDate");
							// String mspTaskFinish =(String)mspMap.get("estFinishDate");
							/*if (sProjectSchduleBasedOn.equals("Actual")) {
								if (mspMap.get("actStartDate").toString().length() > 0)
									mspActTaskStart = (String) mspMap.get("actStartDate");
								if (mspMap.get("actFinishDate").toString().length() > 0)
									mspActTaskFinish = (String) mspMap.get("actFinishDate");
							}
							String mspTaskDuration = (String) mspMap.get("estDuration");
							String mspTaskRequirement = (String) mspMap.get("taskReq");*/

							String mspTaskConstraintType = (String) mspMap.get("ConstraintType");
							String mspTaskConstraintDate = (String) mspMap.get("ConstraintDate");

							boolean bTaskNameChanged = !(oldTaskName.equals(mspTaskName));

							boolean bTaskDescChanged = !(oldTaskDesc.equals(mspTaskDesc));

							boolean bTaskOwnerChanged = !(oldTaskOwner.equals(mspTaskOwner));

							boolean bTaskTypeChanged = !(oldTaskType.equals(mspTaskType));

							boolean bTaskStateChanged = !(oldTaskCurrent.equals(mspTaskCurrent));

							//boolean bTaskCalendarChanged = !(oldTaskCalendar.equals(mspTaskCalendar));

							boolean bTaskConstraintTypeChanged = !(oldTaskConstraintType.equals(mspTaskConstraintType));

							boolean bTaskConstraintDateChanged = !(oldTaskConstraintDate.equals(mspTaskConstraintDate));

							if(bTaskConstraintDateChanged || bTaskConstraintTypeChanged) {
								if(mspTaskConstraintDate != "") {
									Date tempDate = MATRIX_DATE_FORMAT.parse(mspTaskConstraintDate);
									addUpdate(tasks, mspTaskId, ATTRIBUTE_TASK_CONSTRAINT_DATE, tempDate);
								}
								addUpdate(tasks, mspTaskId, ATTRIBUTE_TASK_CONSTRAINT_TYPE, mspTaskConstraintType);
							}

							Map attributeMap = new HashMap();
							Set<String> taskColKeys = new HashSet<String>(taskColAttrMap.keySet());
							Iterator<String> taskColKeysIter = taskColKeys.iterator();
							while(taskColKeysIter.hasNext()) {

								Map colSettingMap = new HashMap();
								String sTaskSelectable = taskColKeysIter.next();
								colSettingMap = taskColAttrMap.get(sTaskSelectable);
								String columnName = (String)colSettingMap.get("Name");								

								if(basicfieldsToIgnoreInSave.contains(columnName) || 
										// below keys needs to skip as details of this needs to handle with different API
										columnName.equals("ConstraintDate") || columnName.equals("ConstraintType") ||
										// below key needs to skip as its relationship attribute 
										columnName.equals("WBS"))
									continue;

								if(sProjectSchduleBasedOn.equals("Estimated") && 
										(columnName.equals(ATTRIBUTE_TASK_ACTUAL_START_DATE) || columnName.equals(ATTRIBUTE_TASK_ACTUAL_FINISH_DATE))
										|| columnName.equals(ATTRIBUTE_TASK_ACTUAL_DURATION))

									continue; // skip to set actual data for estimated based scheduling project

								String sNewValue = (String) mspMap.get(columnName);
								String sKey = null;

								if(sTaskSelectable.contains("attribute")) 
									sKey = sTaskSelectable.substring(sTaskSelectable.indexOf("[") + 1, sTaskSelectable.indexOf("]"));
								else
									sKey = sTaskSelectable;

								boolean bTaskValueChanged = false; 
								String sOldValue = (String) oldMap.get(columnName);
								if(sOldValue != null) {
									bTaskValueChanged = !(sOldValue.equals(sNewValue));
								}

								if(bTaskValueChanged && sKey != null) {
									if(scheduleFieldsInSave.contains(columnName)){

										String columnType = (String)colSettingMap.get("MPIColumnType");								  

										if(columnType.equals("date")) {

											if(!sNewValue.equals("")) {
												Date tempDate = MATRIX_DATE_FORMAT.parse(sNewValue);
												//skip date modification if its summary task										  
												if(((String)mspMap.get("Summary")).equals("0"))
												{
													addUpdate(tasks, mspTaskId, sKey, tempDate);
													//start and finish value is changed and no change in constraint type(when we add dependency)
													//if we don't set then constraint type is changed
													if(mspTaskConstraintDate != "") {
														tempDate = MATRIX_DATE_FORMAT.parse(mspTaskConstraintDate);
														addUpdate(tasks, mspTaskId, ATTRIBUTE_TASK_CONSTRAINT_DATE, tempDate);
													}
													addUpdate(tasks, mspTaskId, ATTRIBUTE_TASK_CONSTRAINT_TYPE, mspTaskConstraintType);
												}											  
											}
											else
												attributeMap.put(sKey, "");
										}
										else if(columnType.equals("duration")) {							  

											//skip duration modification if its summary task
											if(((String)mspMap.get("Summary")).equals("0")) {

												addUpdate(tasks, mspTaskId, sKey, sNewValue);
												//need to pass constraint type even if its not changed
												//(case: if duration is changed and if we dont pass constraint type then SNET is set.
												addUpdate(tasks, mspTaskId, ATTRIBUTE_TASK_CONSTRAINT_TYPE, mspTaskConstraintType);
											}
										}
										else
											addUpdate(tasks, mspTaskId, sKey, sNewValue);
									}
									else
										attributeMap.put(sKey, sNewValue);
								}
							}

							if (bTaskNameChanged || bTaskDescChanged || bTaskOwnerChanged || bTaskStateChanged
									|| bTaskTypeChanged /*|| bTaskCalendarChanged*/) {

								//task.open(context);

								if(bTaskNameChanged) {
									task.setName(context, mspTaskName);
								}
								if(bTaskDescChanged) {
									task.setDescription(context, mspTaskDesc);
								}
								if(bTaskOwnerChanged) {
									task.setOwner(context, mspTaskOwner);
								}

								/*if (bTaskCalendarChanged) {

									if(!oldTaskCalendar.isEmpty())
										task.removeCalendar(context);
									if(!mspTaskCalendar.isEmpty())
										task.addCalendar(context, mspTaskCalendar);
								}*/

								if(bTaskStateChanged) {
									// IR-069442V6R2011x Begin -- added try catch for setState
									// String state = getStateName(context, mspTaskCurrent);
									String sWellFormedMessage = "";
									try {
										task.setState(context, mspTaskCurrent);
									} catch (Exception ex) {
										if (debug)
											System.out.println("[emxMSProjectIntegration.executeSynchronizeMerge] Notice: \nPlease Take appropriate actions manually to Complete the Gate ERROR : " + ex.getMessage());
										if (mspTaskCurrent.equals(task.STATE_PROJECT_SPACE_COMPLETE))// IR-072641V6R2012
											sWellFormedMessage = ex.getMessage() + "\nNotice: Please Take appropriate actions manually to Complete the Gate";
										else
											sWellFormedMessage = ex.getMessage();
										throw new Exception(sWellFormedMessage);
									}
									// IR-069442V6R2011x End
								}
								if(bTaskTypeChanged) {
									task.updateTaskType(context, mspTaskId, mspTaskType);
								}
							} // if

							if (attributeMap.size() > 0) {
								task.setAttributeValues(context, attributeMap);
							}
						} // if(mspTaskId != null && !mspTaskId.equals(""))
					} // while (taskDataMapListItr.hasPrevious())
				} // if (oldStructMapList.size() > 0 || newStructMapList.size() > 0 )

				if(!assigneeMapList.isEmpty() || !oldAssigneeMapList.isEmpty()) {
					if (debug)
						System.out.println("add new assignee or update existing assignees");
					addAssignees(context, assigneeMapList, resourceIndexMap, taskIndexMap, oldAssigneeMapList, oldResourceIndexMap, oldTaskIndexMap/*, taskUnitMap*/);
				}
			}

			if(!tasks.isEmpty()) {
				String message = task.updateDates(context, tasks, true, true);
				if(!message.equals("false")) //false means everything is updated.
					throw new MatrixException(codeRegn + " " + message);
			}

			task = (com.matrixone.apps.program.Task) DomainObject.newInstance(context, TYPE_TASK, DomainConstants.PROGRAM); // added new line, suggested by KYP
			task.setId(strBusId);
			task.rollupAndSave(context);

			codeRegn = "Done with merge";
			if (debug)
				System.out.println(codeRegn);
			// Get the latest data for the current project and display in MSP by reusing findForCheckOut function
			//Generate response such that to get the latest using findForCheckOut
			Element elFFCRoot = new Element("transaction");
			elFFCRoot.setAttribute("cname", "findforcheckout");

			// now create placeholder for response
			Element elResponseArgumentsNode = new Element("arguments");
			elFFCRoot.addContent(elResponseArgumentsNode);

			// create the busid argument placeholder
			Element elBusIdArgument = new Element("argument");
			elBusIdArgument.setAttribute("name", "busid");
			elBusIdArgument.setText(strBusId);
			elResponseArgumentsNode.addContent(elBusIdArgument);

			// create the edit status argument placeholder
			// on Merge to ematrix the edit flag will be reset to false
			// the user will have to explicitly "Launch the project in Edit mode inorder to make any further changes
			Element elEditStatusArgument = new Element("argument");
			elEditStatusArgument.setAttribute("name", "foredit");
			elEditStatusArgument.setText("true");
			elResponseArgumentsNode.addContent(elEditStatusArgument);

			String fileName = dumpTransactionXMLForServlet(elFFCRoot);
			if (debug)
				System.out.println("done dumping the transaction xml file");
			codeRegn = "Commiting transaction in executeSynchronizeMerge ";		
			ContextUtil.commitTransaction(context);

			if (debug) {

				mergeEndTime = System.currentTimeMillis();
				long totalMergeTime = mergeEndTime - mergeStartTime;
				System.out.println("TOTAL MERGE TIME (in Secs): " + (float) totalMergeTime / 1000);
				System.out.println("================ END executeSynchronizeMerge ================");
			}

			//get the latest for this current project and display it in MSP
			return executeFindForCheckout(context, new String[]{fileName});
		} catch (Exception e) {
			e.printStackTrace();
			throw new MatrixException(codeRegn + " " + e.getMessage());
		}
	}

	private Map SyncCustomAttributeForNewProject(Map prjInfoMap) {

		Map projectAttribute = new HashMap();
		Set<String> prjColKeys = new HashSet<String>(projectColAttrMap.keySet());	  

		Iterator<String> prjColKeysIter = prjColKeys.iterator();

		//project custom attribute values support
		while(prjColKeysIter.hasNext()) {

			Map colSettingMap = new HashMap();
			String sProjectSelectable = prjColKeysIter.next();
			colSettingMap = projectColAttrMap.get(sProjectSelectable);

			String columnName = (String)colSettingMap.get("Name");

			if(columnName.equals("Owner") || columnName.equals("Description") ||
					columnName.equals("NodeType") || columnName.equals("Name") || columnName.equals("Company"))
				continue;
			if((String) prjInfoMap.get(columnName) != null)
			{
				String sProjKey = null;
				if(sProjectSelectable.contains("attribute")) 
					sProjKey = sProjectSelectable.substring(sProjectSelectable.indexOf("[") + 1, sProjectSelectable.indexOf("]"));
				else
					sProjKey = sProjectSelectable;
				projectAttribute.put(sProjKey, (String) prjInfoMap.get(columnName));
			}
		}
		return projectAttribute;
	}

	public String executeValidateResource(Context context, String[] args) {

		if (debug) {
			System.out.println("inside executeValidateResource");
			StartValidateResourceTime = System.currentTimeMillis();
		}

		try {

			Element elResourcesRoot = null;

			Element elCommandRoot = loadXMLSentFromServlet(args[0]);
			if (debug)
				System.out.println("executeValidateResource Read the xml sent from client...done");

			// get the ResourceXml
			Element elCommandArguments = elCommandRoot.getChild("arguments");

			List lArguments = elCommandArguments.getChildren("argument");
			ListIterator litCtr = lArguments.listIterator();

			while (litCtr.hasNext()) {

				Element elArgument = (Element) litCtr.next();

				if (elArgument.getAttributeValue("name").equals("validatexml")) {
					elResourcesRoot = elArgument.getChild("Resources");
				}
			} // while (litCtr.hasNext())

			codeRegn = "Read XML for getting Resource Name";
			ArrayList ResourceNamesList = readXMLDataForValidateResource(elResourcesRoot);

			Iterator<String> ResourceNameItr = ResourceNamesList.iterator();
			ArrayList<String> MatchedResourceNamesList = new ArrayList<String>();

			while (ResourceNameItr.hasNext()) {
				String strResourceName = ResourceNameItr.next();
				if (_personInfo != null && _personInfo.get(strResourceName) == null) {
					// found new Last Name First Name, add to cache
					addLastFirstNameToCache(context, strResourceName);
				}

				// get the personName from cache map
				String personName = (String) _personInfo.get(strResourceName);

				if (personName == null || personName.equals("")) {
					MatchedResourceNamesList.add(strResourceName);
					System.out.println(strResourceName + " personName does not exist");
				}
			}
			String xmlOut = executeResponseForValidateResource(args, MatchedResourceNamesList, "success");

			if (debug) {

				EndValidateResourceTime = System.currentTimeMillis();
				long totalValidateResourceTime = EndValidateResourceTime - StartValidateResourceTime;
				System.out.println("TOTAL TIME in executeValidateResource (in Secs) : " + totalValidateResourceTime / 1000);
				System.out.println("================ END executeValidateResource ================");
			}

			return xmlOut;
		} catch (Exception e) {
			// throw new MatrixException(e.getMessage());
			System.out.println(e.getMessage());
			return "Failure";
		}
	}

	public String executeResponseForValidateResource(String[] args, ArrayList ResourceNamesList,
			String result) throws MatrixException {

		if (debug)
			System.out.println("================ START executeResponseForValidateResource ================");
		codeRegn = "inside executeResponseForValidateResource";

		try {
			Element elCommandRoot = loadXMLSentFromServlet(args[0]);
			Element elResponseRoot = new Element("transaction");

			elResponseRoot.setAttribute("cname", elCommandRoot.getAttributeValue("cname"));

			// now create placeholder for response
			Element elResponseArgumentsNode = new Element("arguments");
			elResponseRoot.addContent(elResponseArgumentsNode);

			Element elArgument = new Element("argument");
			elArgument.setAttribute("name", "validatexml");
			elResponseArgumentsNode.addContent(elArgument);

			Element elResourceArgument = new Element("Resources");
			elArgument.addContent(elResourceArgument);

			Iterator<String> ResourceNameItr = ResourceNamesList.iterator();
			String strResourceName;
			while (ResourceNameItr.hasNext()) {
				strResourceName = ResourceNameItr.next();
				Element elCurrentResourceNode = new Element("Resource");
				elCurrentResourceNode.setText(strResourceName);
				elResourceArgument.addContent(elCurrentResourceNode);
			}

			elResponseRoot.setAttribute("result", result/* "success" */);
			String xmlOut = dumpTransactionXMLForServlet(elResponseRoot);

			if (debug)
				System.out.println("================ END executeResponseForValidateResource ================");
			return xmlOut;// "Success";
		} catch (Exception e) {
			// e.printStackTrace();
			System.out.println("{Exception} : " + codeRegn + " " + e.getMessage());
			throw new MatrixException(e.getMessage());
		}
	}

	public String SynchronizeNewProject(Context context, Map newProjectMap) throws MatrixException {

		if (debug)
			System.out.println("================ START SynchronizeNewProject ================");
		String strBusId = "";

		try {

			// obtain data from the map project info, task info, resource map, assignments
			Map prjInfoMap = (Map) newProjectMap.get("projectData");
			Map resourceIndexMap = (Map) newProjectMap.get("resourceIndexMap");
			MapList assigneeMapList = (MapList) newProjectMap.get("assigneeMapList");
			MapList taskDataMapList = (MapList) newProjectMap.get("taskData");
			Map taskLevelMap = (Map) newProjectMap.get("taskLevelMap");
			Map taskIndexMap = new HashMap();

			String owner = null;
			String estStartDate = null;
			String estFinishDate = null;
			//String actStartDate = null;
			//String actFinishDate = null;

			taskLevelMap.clear();
			String projectName = (String) prjInfoMap.get("Name");
			String description = (String) prjInfoMap.get("Description");
			String schedulefromstart = (String) prjInfoMap.get("ScheduleFrom");
			owner = (String) prjInfoMap.get("Owner");

			if (debug)
				System.out.println("Not an existing sub project...");

			String userVault = context.getVault().getName();

			String projectType = "";
			ListIterator Itr = taskDataMapList.listIterator();
			if (Itr.hasNext()) {
				Map projectMap = (Map) Itr.next();
				projectType = (String) projectMap.get("NodeType");
			}
			mspiCreateProject(context, project, projectType, projectName, userVault);

			codeRegn = "created new sub project ";
			if (debug)
				System.out.println(codeRegn);

			project.setDescription(context, description);
			project.setAttributeValue(context, ATTRIBUTE_PROJECT_SCHEDULE_FROM, schedulefromstart);
			strBusId = project.getId(context);

			Map subProjectAttributes = new HashMap();
			subProjectAttributes.putAll(SyncCustomAttributeForNewProject(prjInfoMap));

			if (schedulefromstart.equals("Project Start Date"))
				subProjectAttributes.put(ATTRIBUTE_TASK_CONSTRAINT_DATE, (String) prjInfoMap.get("ProjectStart"));
			else
				subProjectAttributes.put(ATTRIBUTE_TASK_CONSTRAINT_DATE, (String) prjInfoMap.get("ProjectFinish"));

			project.setAttributeValues(context, subProjectAttributes);

			ListIterator taskDataItr = taskDataMapList.listIterator();
			String outlineNumber = null;
			String taskUID = null;
			//String taskReq = null;
			if (taskDataItr.hasNext()) // special case for summary node
			{
				project.setId(strBusId);
				Map nodeMap = (Map) taskDataItr.next();

				codeRegn = "setting the attributes ";
				estStartDate = (String) nodeMap.get("Start");
				estFinishDate = (String) nodeMap.get("Finish");
				String percentComplete = (String) nodeMap.get("PercentComplete");
				String estDuration = (String) nodeMap.get("Duration");
				String actDuration = (String) nodeMap.get("ActualDuration");

				Map attributeMap = new HashMap(5); // set the attribute values into a map

				attributeMap.put(ATTRIBUTE_TASK_ESTIMATED_START_DATE, estStartDate);
				attributeMap.put(ATTRIBUTE_TASK_ESTIMATED_FINISH_DATE, estFinishDate);

				if (percentComplete != null && !percentComplete.equals("0"))
					attributeMap.put(ATTRIBUTE_PERCENT_COMPLETE, percentComplete);

				if (estDuration != null && estDuration.length() > 0)
					attributeMap.put(ATTRIBUTE_TASK_ESTIMATED_DURATION, estDuration);

				if (actDuration != null && actDuration.length() > 0)
					attributeMap.put(ATTRIBUTE_TASK_ACTUAL_DURATION, actDuration);

				codeRegn = "setting new sub project attribute values ";
				if (debug)
					System.out.println(codeRegn);

				project.setAttributeValues(context, attributeMap);
				// To set Project Schedule Based on option to Actual
				//project.setAttributeValue(context, ATTRIBUTE_SCHEDULEBASEDON, sProjectSchduleBasedOn);
			}

			codeRegn = "create tasks";
			while (taskDataItr.hasNext()) {

				project.setId(strBusId);
				Map nodeMap = (Map) taskDataItr.next();
				taskUID = (String) nodeMap.get("taskUID");
				String taskName = (String) nodeMap.get("Name");

				String taskDescription = (String) nodeMap.get("Description");
				outlineNumber = (String) nodeMap.get("OutlineNumber");

				if (debug) {
					System.out.println("creating subproject task with name: " + taskName);
					System.out.println("outlineNumber : " + outlineNumber);
				}

				String taskState = (String) nodeMap.get("State");
				owner = (String) nodeMap.get("Owner");
				String taskType = (String) nodeMap.get("NodeType");

				codeRegn = "Creating subproject";
				Map subprojectMap = (Map) nodeMap.get("subprojectMap");
				if (subprojectMap != null) {

					Map subprojectTaskIndexMap = new HashMap();
					subprojectMap.put("taskIndexMap", subprojectTaskIndexMap);
					String subprojectId = SynchronizeNewProject(context, subprojectMap);
					subprojectTaskIndexMap = (Map) subprojectMap.get("taskIndexMap");
					taskIndexMap.putAll(subprojectTaskIndexMap);

					taskLevelMap.put(outlineNumber, subprojectId);
					taskIndexMap.put(taskUID, subprojectId);

					String parentId;
					String levelId = null;

					if (outlineNumber.lastIndexOf(".") == -1) {
						parentId = strBusId;
					} else {
						levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
						parentId = (String) taskLevelMap.get(levelId);
					}

					task.setId(parentId);
					/*String[] childIds = new String[1];
					childIds[0] = subprojectId;*/
					//task.addExisting(context, childIds, parentId);
					task.addExistingForMSProject(context, subprojectId , parentId, relSubTask);

					ProjectIds.add(subprojectId);
				} // if (subprojectMap != null)
				if(slProjectSpaceSubTypes.contains(taskType))
				{
					mspiCreateProject(context, subProject, taskType, taskName, userVault);
					String subprojectId = subProject.getId(context);
					task.setId(subprojectId);

					taskLevelMap.put(outlineNumber, subprojectId);
					taskIndexMap.put(taskUID, subprojectId);
					subProject.setDescription(context, taskDescription);

					estStartDate = (String) nodeMap.get("Start");
					estFinishDate = (String) nodeMap.get("Finish");
					String percentComplete = (String) nodeMap.get("PercentComplete");
					String estDuration = (String) nodeMap.get("Duration");
					String actDuration = (String) nodeMap.get("ActualDuration");

					codeRegn = "set the attribute values into a map";
					Map attributeMap = new HashMap(5);

					attributeMap.put(ATTRIBUTE_TASK_ESTIMATED_START_DATE, estStartDate);
					attributeMap.put(ATTRIBUTE_TASK_ESTIMATED_FINISH_DATE, estFinishDate);

					if (percentComplete != null && !percentComplete.equals("0"))
						attributeMap.put(ATTRIBUTE_PERCENT_COMPLETE, percentComplete);

					if (estDuration != null && estDuration.length() > 0)
						attributeMap.put(ATTRIBUTE_TASK_ESTIMATED_DURATION, estDuration);

					if (actDuration != null && actDuration.length() > 0)
						attributeMap.put(ATTRIBUTE_TASK_ACTUAL_DURATION, actDuration);

					codeRegn = "setting new subproject attribute values ";

					subProject.setAttributeValues(context, attributeMap);

					String parentId;

					if (outlineNumber.lastIndexOf(".") == -1) {
						parentId = strBusId;
					} else {
						String levelId = null;
						levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
						parentId = (String) taskLevelMap.get(levelId);
					}

					task.setId(parentId);
					/*String []childIds = new String[1];
				  	childIds[0] = subprojectId;*/
					//task.addExisting(context, childIds , parentId);
					task.addExistingForMSProject(context, subprojectId , parentId, relSubTask);

					ProjectIds.add(subprojectId);
				} // else if (isProjectSpace(context,taskType)==true)
				else {
					// START:Added:P6E:16-Aug-2011:PRG:R213:Bug 121547V6R2013
					// task retaining policy of previous task, to get rid off that Initializing task again.
					task = (Task) DomainObject.newInstance(m_ctxUserContext, DomainConstants.TYPE_TASK, DomainConstants.PROGRAM);
					// End:P6E:16-Aug-2011:PRG:R213:Bug 121547V6R2013

					if (outlineNumber.lastIndexOf(".") == -1) {

						boolean retValue = mspiCreateTask(context, task, taskType, taskName, project, true);
					}
					else {

						String levelId = null;
						levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
						String parentId = (String) taskLevelMap.get(levelId);
						if (debug) {
							System.out.println("levelId : " + levelId);
							System.out.println("parentId : " + parentId);
						}
						parentTask.setId(parentId);
						boolean retValue = mspiCreateTask(context, task, taskType, taskName, parentTask, false);
					}

					task.setDescription(context, taskDescription);
					if (taskState != null && !taskState.equals(""))
						task.setState(context, taskState);
					task.setOwner(context, owner);

					String currentTaskId = task.getId(context);
					taskLevelMap.put(outlineNumber, currentTaskId);
					taskIndexMap.put(taskUID, currentTaskId);

					//task custom attribute values support begin
					Map attributeMap = new HashMap();
					Set<String> taskColKeys = new HashSet<String>(taskColAttrMap.keySet());
					Iterator<String> taskColKeysIter = taskColKeys.iterator();

					while(taskColKeysIter.hasNext()) {

						Map colSettingMap = new HashMap();
						String sTaskSelectable = taskColKeysIter.next();
						colSettingMap = taskColAttrMap.get(sTaskSelectable);
						String columnName = (String)colSettingMap.get("Name");						

						// below keys needs to skip as details of this needs to handle with different API
						if(basicfieldsToIgnoreInSave.contains(columnName)) 
							continue;
						String sValue = (String) nodeMap.get(columnName);
						String sKey = null;
						if(sValue != null && !sValue.equals(""))
						{

							if(sTaskSelectable.contains("attribute")) 
								sKey = sTaskSelectable.substring(sTaskSelectable.indexOf("[") + 1, sTaskSelectable.indexOf("]"));
							else
								sKey = sTaskSelectable;								  
						}
						if(sKey!= null) {
							if(scheduleFieldsInSave.contains(columnName)){

								String columnType = (String)colSettingMap.get("MPIColumnType");

								if(columnType.equals("date")) {
									if(sValue.length() > 0)
									{
										Date tempDate = MATRIX_DATE_FORMAT.parse(sValue);
										addUpdate(tasks, currentTaskId, sKey, tempDate);
									}
									else
										attributeMap.put(sKey, "");
								}
								else
									addUpdate(tasks, currentTaskId, sKey, sValue);
							}
							else
								attributeMap.put(sKey, sValue);
						}
					}						
					// setting task attribute values
					task.setAttributeValues(context, attributeMap);
				}
			} // while (taskDataItr.hasNext())

			newProjectMap.put("taskIndexMap", taskIndexMap);

			if(!assigneeMapList.isEmpty()) {
				if (debug)
					System.out.println("Adding Assignees");
				// create assignees for project created/updated
				// addAssignees(context, assigneeMapList, resourceIndexMap, taskIndexMap, null, null, null);
				addAssignees(context, assigneeMapList, resourceIndexMap, taskIndexMap, null, null, null/*, taskUnitMap*/);
			}
			if (debug)
				System.out.println("Adding Assignees...done");
		} catch (Exception e) {
			ContextUtil.abortTransaction(context);
			if (e.toString().indexOf("well-formed character") != -1) {
				String wellFormedMessage = "One of the tasks in the project contains characters that is not supported, Check the task names and the notes. \n";
				throw new MatrixException(wellFormedMessage + e.getMessage());
			} else {
				throw new MatrixException(codeRegn + " " + e.getMessage());
			}
		}
		if (debug)
			System.out.println("================ END SynchronizeNewProject ================" + strBusId);

		return strBusId;
	}

	public void SynchronizeExistingProject(Context context, String strBusId, Map newProjectMap, Map oldProjectMap,
			Map tasks) throws MatrixException {

		codeRegn = "inside SynchronizeExistingProject";
		if (debug) {
			System.out.println("================ START SynchronizeExistingProject ================");
			mergeStartTime = System.currentTimeMillis();
		}
		try {
			// obtain data from the map project info, task info, resource map, assignments
			Map prjInfoMap = (Map) newProjectMap.get("projectData");
			Map resourceIndexMap = (Map) newProjectMap.get("resourceIndexMap");
			MapList assigneeMapList = (MapList) newProjectMap.get("assigneeMapList");
			MapList taskDataMapList = (MapList) newProjectMap.get("taskData");
			Map taskLevelMap = (Map) newProjectMap.get("taskLevelMap");
			Map taskIndexMap = (Map) newProjectMap.get("taskIndexMap");
			//Map taskUnitMap = (Map) newProjectMap.get("taskUnitsDataMap");

			if (debug)
				System.out.println("taskLevelMap : " + taskLevelMap);

			codeRegn = "accessed the map values ";

			String owner = null;

			String userVault = context.getVault().getName();// person.getVault();

			codeRegn = "Reading XML for Exisiting PC Project";

			// get project info, task info, resource map, assignments
			Map oldPrjInfoMap = (Map) oldProjectMap.get("projectData");
			Map oldResourceIndexMap = (Map) oldProjectMap.get("resourceIndexMap");
			MapList oldAssigneeMapList = (MapList) oldProjectMap.get("assigneeMapList");
			MapList oldTaskDataMapList = (MapList) oldProjectMap.get("taskData");
			Map oldTaskIndexMap = (Map) oldProjectMap.get("taskIndexMap");

			HashMap NextOutlineMap = new HashMap();

			// check if there is any modification in project name and description and update accordingly -
			// case 1: only the MS Project user modified the project data
			// case 2: only the PC user modified the project data
			// case 3: the PC user as well as the MS Project user modified the project data
			//
			// NOTE: for case 2 and case 3 do nothing MSProject is the master

			project.setId(strBusId);
			project.open(context);

			// for case 2 and case 3 do nothing MSProject is the master
			if(!(oldPrjInfoMap.get("Name")).equals(prjInfoMap.get("Name")))
			{
				project.setName(context, (String) prjInfoMap.get("Name"));
			}
			if(!(oldPrjInfoMap.get("Description")).equals(prjInfoMap.get("Description")))
			{
				project.setDescription(context, (String) prjInfoMap.get("Description"));
			}

			Map projectAttributes = new HashMap();
			if(prjInfoMap.get("ScheduleFrom").equals("Project Start Date"))
			{
				projectAttributes.put(ATTRIBUTE_TASK_CONSTRAINT_DATE,(String) prjInfoMap.get("ProjectStart"));			

			}
			else if(prjInfoMap.get("ScheduleFrom").equals("Project Finish Date"))
			{
				projectAttributes.put(ATTRIBUTE_TASK_CONSTRAINT_DATE,(String) prjInfoMap.get("ProjectFinish"));
			}

			if(!(oldPrjInfoMap.get("ScheduleFrom")).equals(prjInfoMap.get("ScheduleFrom")))
			{
				String projectScheduleFrom=(String) prjInfoMap.get("ScheduleFrom");
				String projectConstraintType="As Soon As Possible";
				if(projectScheduleFrom.equals("Project Finish Date"))
					projectConstraintType="As Late As Possible";

				projectAttributes.put(ATTRIBUTE_PROJECT_SCHEDULE_FROM, projectScheduleFrom);
				projectAttributes.put(ATTRIBUTE_DEFAULT_CONSTRAINT_TYPE, projectConstraintType);
			}

			projectAttributes.putAll(SyncCustomAttributeForExistingProject(oldPrjInfoMap,prjInfoMap));		

			project.setAttributeValues(context, projectAttributes);
			project.close(context);

			MapList newTaskDataMapList = (MapList) newProjectMap.get("taskData");

			MapList addedList = new MapList();
			MapList removedList = new MapList();
			//MapList modifiedList = new MapList();

			//generate new maplist for comparison of structure. 
			// the new maplist only consists of taskId and level (outlineNumber)
			// if there is no taskId then there is a new task added
			// if there is change in level then the task has been moved to a different level
			MapList oldStructMapList = new MapList();
			MapList newStructMapList = new MapList();
			HashMap oldDataMap = new HashMap();
			HashMap newDataMap = new HashMap();

			HashMap OIDMap = new HashMap();
			HashMap OIDMapOld = new HashMap();
			HashMap TaskLevelMap = new HashMap();
			HashMap TaskLevelMapOld = new HashMap();
			String parentOutline = null;
			String parentId = null;

			if (oldTaskDataMapList.size() > 0) {

				ListIterator oldTaskDataMapListItr = oldTaskDataMapList.listIterator();
				int i = 0;
				while (oldTaskDataMapListItr.hasNext()) {
					// skip the first value this corresponds to the project details
					HashMap buildMap = new HashMap();
					Map oldTaskMap = (Map) oldTaskDataMapListItr.next();

					if (i != 0) {

						String id = (String) oldTaskMap.get("taskId");
						String outlineNumber = (String) oldTaskMap.get("OutlineNumber");
						buildMap.put("taskId", id);
						buildMap.put("OutlineNumber", outlineNumber);

						if (outlineNumber != null && !outlineNumber.equals("0")) {
							oldStructMapList.add(buildMap);
						}
						if (outlineNumber.indexOf(".") > -1) {
							parentOutline = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
							parentId = (String) TaskLevelMapOld.get(parentOutline);
							if (parentId != null)
								buildMap.put("parentTaskId", parentId);
						}
						// build an hashmap to locate the node details based on taskId as key
						// if taskId does not exist then use outlineNumber as key
						if (id != null || !id.equals("")) {
							oldDataMap.put(id, oldTaskMap);
							TaskLevelMapOld.put(outlineNumber, id);
							OIDMapOld.put(id, outlineNumber);
							Map subprojectmap = (Map) oldTaskMap.get("subprojectMap");
							if (subprojectmap != null)
								AllOldProjectIds.add(id);
						} else {
							oldDataMap.put(outlineNumber, oldTaskMap);
						}
					} // if(i != 0)
					i++;
				} // while(oldTaskDataMapListItr.hasNext())
			} // if(oldTaskDataMapList.size() > 0)

			String prevOutlineNumber = "aaaaa";

			if (newTaskDataMapList.size() > 0) {
				ListIterator newTaskDataMapListItr = newTaskDataMapList.listIterator();
				int i = 0;
				while (newTaskDataMapListItr.hasNext()) {
					HashMap buildMap = new HashMap();
					Map newTaskMap = (Map) newTaskDataMapListItr.next();
					if (i != 0) {
						String id = (String) newTaskMap.get("taskId");
						String outlineNumber = (String) newTaskMap.get("OutlineNumber");
						buildMap.put("taskId", id);
						buildMap.put("OutlineNumber", outlineNumber);

						if (outlineNumber.indexOf(".") > -1) {
							parentOutline = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
							parentId = (String) TaskLevelMap.get(parentOutline);
							if (parentId != null)
								buildMap.put("parentTaskId", parentId);
						}

						NextOutlineMap.put(prevOutlineNumber, outlineNumber);
						prevOutlineNumber = outlineNumber;

						if (outlineNumber != null && !outlineNumber.equals("0")) {
							newStructMapList.add(buildMap);
						}
						// build an hashmap to locate the node details based on taskId as key
						// if taskId does not exist then use outlineNumber as key
						if (id != null && !id.equals("")) {
							newDataMap.put(id, newTaskMap);
							TaskLevelMap.put(outlineNumber, id);
							OIDMap.put(id, outlineNumber);
						} else {
							newDataMap.put(outlineNumber, newTaskMap);
						}
					} // if(i != 0)
					i++;
				} // while(newTaskDataMapListItr.hasNext())
			} // if(newTaskDataMapList.size() > 0)

			if (oldStructMapList.size() > 0 || newStructMapList.size() > 0) {

				// Get a list of all added items (new - old).
				addedList.addAll(newStructMapList);
				addedList.removeAll(oldStructMapList);

				// Get a list of all removed items (old - new).
				removedList.addAll(oldStructMapList);
				removedList.removeAll(newStructMapList);

				// store the removedList as a reference
				// required while updating the attributes
				MapList refRemovedList = new MapList();
				refRemovedList.addAll(removedList);

				// Get a list of all retained items (new & old).
				//retainedList.addAll(oldStructMapList);
				//retainedList.retainAll(newStructMapList);

				// Get a list of tasks neither added or removed
				// but could have been modified (old - removed).
				// (no structure modification but only attribute modification)
				//modifiedList.addAll(newStructMapList);

				if (addedList != null) {
					ListIterator addedListItr = addedList.listIterator();

					while (addedListItr.hasNext()) {
						Map addedListMap = (Map) addedListItr.next();
						String taskId = (String) addedListMap.get("taskId");

						if (taskId != null && !taskId.equals("")) {
							// the removedList has entries of same taskId since
							// the outlineLevelNumber get modified due to structure change
							// if this task is handled already then remove if from the removedList
							Iterator removeItr = removedList.iterator();
							int i = 0;
							while (removeItr.hasNext()) {
								Map removedMap = (Map) removeItr.next();
								if (taskId.equals(removedMap.get("taskId"))) {
									break;
								}
								i++;
							}
							if (i < removedList.size()) {
								removedList.remove(i);
								refRemovedList.remove(i);
							}
						} // if(taskId != null && !taskId.equals(""))
					} // while (addedListItr.hasNext())
				} // if(addedList != null)

				if(!addedList.isEmpty()) {
					codeRegn = "Existing SubProject : Merge- Adding the task";

					ListIterator addedListItr = addedList.listIterator();

					while (addedListItr.hasNext()) {
						if (debug)
							iterationStartTime = System.currentTimeMillis();

						Map addedListMap = (Map) addedListItr.next();
						String taskId = (String) addedListMap.get("taskId");
						String outlineNumber = (String) addedListMap.get("OutlineNumber");

						Map oldTaskValueMap = new HashMap();
						Map newTaskValueMap = new HashMap();

						if ((taskId != null) && !taskId.equals("")) {
							oldTaskValueMap = (Map) oldDataMap.get(taskId);
							newTaskValueMap = (Map) newDataMap.get(taskId);
						} else {
							newTaskValueMap = (Map) newDataMap.get(outlineNumber);
						}

						String levelId = null;
						String newParentId = null;

						String taskUID = (String) newTaskValueMap.get("taskUID");

						// if taskUID is not found this is a special case where
						// the addedList contains details of project skip this value
						if (taskUID == null || taskUID.equals(""))
							continue;

						// [existing task--update structure]
						if (taskId != null && !taskId.equals("") && oldTaskValueMap != null) {
							// taskLevelMap.put(outlineNumber, taskId);
							//if (isProjectSpace(context, (String) oldTaskValueMap.get("taskType")) == true) {
							if(slProjectSpaceSubTypes.contains((String)oldTaskValueMap.get("NodeType"))) {
								Map newSubprojectmap = (Map) newTaskValueMap.get("subprojectMap");
								Map oldSubprojectmap = (Map) oldTaskValueMap.get("subprojectMap");

								if (newSubprojectmap != null && oldSubprojectmap != null) {

									oldSubprojectmap.put("taskIndexMap", oldTaskIndexMap);
									newSubprojectmap.put("taskIndexMap", taskIndexMap);
									SynchronizeExistingProject(context, taskId, newSubprojectmap, oldSubprojectmap, tasks);
									Map taskIndexMap2 = (Map) newSubprojectmap.get("taskIndexMap");
									Map oldTaskIndexMap2 = (Map) oldSubprojectmap.get("taskIndexMap");
									taskIndexMap.putAll(taskIndexMap2);
									oldTaskIndexMap.putAll(oldTaskIndexMap2);
								}
								// get the releationship id
								subProject.setId(taskId);
								StringList busSelect = new StringList();
								busSelect.add("to[" + RELATIONSHIP_SUBTASK + "].id");
								Map taskInfo = subProject.getInfo(context, busSelect);
								String connectionId = (String) taskInfo.get("to[" + RELATIONSHIP_SUBTASK + "].id");
								DomainRelationship.disconnect(context, connectionId);

								if (!outlineNumber.equals(oldTaskValueMap.get("OutlineNumber"))) {
									// structure modified for an existing subproject
									if (outlineNumber.lastIndexOf(".") == -1) {
										// direct subtask of a project
										newParentId = strBusId;
									} else {
										levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
										newParentId = (String) taskLevelMap.get(levelId);
									}
									//task.setId(strBusId);
									//task.reSequence(context, strBusId);

									task.setId(newParentId);
									String nextTaskId = getNextTaskId(outlineNumber, NextOutlineMap, TaskLevelMap, TaskLevelMapOld, OIDMap, OIDMapOld);

									task.addExistingForMSProject(context, taskId , nextTaskId, relSubTask);

								} // if(! outlineNumber.equals(oldTaskValueMap.get("OutlineNumber")))
								ProjectIds.add(taskId);
							} // if (isProjectSpace(context,(String)oldTaskValueMap.get("NodeType"))==true)
							else
							{
								// get the releationship id
								task.setId(taskId);
								StringList busSelect = new StringList();
								busSelect.add(SELECT_TO_RELATIONSHIP_SUBTASK_ID);	 
								Map taskInfo = task.getInfo(context, busSelect);
								String connectionId = (String) taskInfo.get(SELECT_TO_RELATIONSHIP_SUBTASK_ID);		 
								DomainRelationship.disconnect(context, connectionId);

								//Circular dependency : case 1
								//before modifying the structure of the current task check if
								// currenttask has existing predecessors which on structure change
								// will result in being the current tasks parent
								//since a parent cannot have its children has a predecessor
								// i.e taskId cannot not be a predecessor of newParentId
								MapList predList = task.getPredecessors(context, null, null, null);
								Iterator predListItr = predList.iterator();

								if (debug)
									System.out.println("Checking for Circular Dependency: case 1");

								while (predListItr.hasNext()) {

									Map predecessorObj = (Map) predListItr.next();
									String predecessorId = (String) predecessorObj.get(task.SELECT_ID);
									ArrayList taskLevelKeys = new ArrayList(taskLevelMap.keySet());
									// BUG? []: changed from predecessorObj.keySet() to taskLevelMap.keySet()
									ArrayList taskLevelValues = new ArrayList(taskLevelMap.values());

									String predLevel = null;
									if (taskLevelValues.indexOf(predecessorId) != -1) {
										int predPos = taskLevelValues.indexOf(predecessorId);
										if (taskLevelKeys.size() > predPos) {
											predLevel = (String) taskLevelKeys.get(predPos);
											if (predLevel != null &&  outlineNumber.equals(predLevel)) {
												// removing dependency of a given object
												String predConnectionId = (String) predecessorObj.get(dependency.SELECT_ID);
												task.removePredecessor(context, predConnectionId);
											}
										}
									} // end if
								} // while (predListItr.hasNext())

								// if(!outlineNumber.equals(oldTaskValueMap.get("OutlineNumber")))
								{
									// structure modified for an existing task
									if (outlineNumber.lastIndexOf(".") == -1) {
										// direct subtask of a project
										newParentId = strBusId;
									} else {
										levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
										newParentId = (String) taskLevelMap.get(levelId);
										// Circular dependency : case 2 before changing the parent of the
										// current task check if currenttask is a predecessor of the parent task
										// since a parent cannot have its children has a predecessor
										// i.e taskId cannot not be a predecessor of newParentId
										task.setId(newParentId);
										if (debug)
											System.out.println("Checking for Circular Dependency: case 2");

										MapList predecessorList = task.getPredecessors(context, null, null, null);
										Iterator predecessorItr = predecessorList.iterator();

										while (predecessorItr.hasNext()) {
											Map predecessorObj = (Map) predecessorItr.next();
											String predecessorId = (String) predecessorObj.get(task.SELECT_ID);
											if (predecessorId.equals(taskId)) {
												String depConnectionId = (String) predecessorObj.get(dependency.SELECT_ID);
												task.removePredecessor(context, depConnectionId);
											}
										}
									}
									task.setId(newParentId);
									String nextTaskId = getNextTaskId(outlineNumber, NextOutlineMap, TaskLevelMap, TaskLevelMapOld, OIDMap, OIDMapOld);
									task.addExistingForMSProject(context, taskId , nextTaskId, relSubTask);
								} // if(! outlineNumber.equals(oldTaskValueMap.get("OutlineNumber")))
							} // else
						} // if(taskId != null && !taskId.equals(""))
						else
						{
							String taskName = (String) newTaskValueMap.get("Name");
							if (debug)
							{
								System.out.println("Processing task: " + taskName);
							}
							String taskDesc = (String) newTaskValueMap.get("Description");
							owner = (String) newTaskValueMap.get("Owner");
							String taskType = (String)newTaskValueMap.get("NodeType");
							String taskState = (String)newTaskValueMap.get("State");


							Map subprojectmap = (Map) newTaskValueMap.get("subprojectMap");
							//if (subprojectmap == null && isProjectSpace(context,taskType)==true)
							if (subprojectmap == null && slProjectSpaceSubTypes.contains(taskType))
							{
								mspiCreateProject(context, subProject, taskType, taskName, userVault);

								Map attributeMap = new HashMap(); 
								attributeMap.putAll(SyncCustomAttributeForNewProject(newTaskValueMap));

								String subprojectId = subProject.getId(context);
								task.setId(subprojectId);

								taskLevelMap.put(outlineNumber, subprojectId);
								taskIndexMap.put(taskUID, subprojectId);

								subProject.setDescription(context, taskDesc);

								String scheduleFromStart = (String)newTaskValueMap.get("ScheduleFrom");
								if(scheduleFromStart.equals("Project Start Date"))
									attributeMap.put(ATTRIBUTE_TASK_CONSTRAINT_DATE, (String) newTaskValueMap.get("ProjectStart"));
								else
									attributeMap.put(ATTRIBUTE_TASK_CONSTRAINT_DATE, (String) newTaskValueMap.get("ProjectFinish"));

								codeRegn = "setting project attribute values ";
								subProject.setAttributeValues(context, attributeMap);

								if (outlineNumber.lastIndexOf(".") == -1) {
									parentId = strBusId;
								} else {
									levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
									parentId = (String) taskLevelMap.get(levelId);
									parentTask.setId(parentId);
								}
								task.setId(parentId);
								String nextTaskId = getNextTaskId(outlineNumber, NextOutlineMap, TaskLevelMap, TaskLevelMapOld, OIDMap, OIDMapOld);
								task.addExistingForMSProject(context, subprojectId , nextTaskId, relSubTask);

								ProjectIds.add(subprojectId);
							} // if (isProjectSpace(context,taskType)==true)
							else {
								if (subprojectmap != null) {
									String subprojectId = SynchronizeNewProject(context, subprojectmap);
									Map subprojectTaskIndexMap = (Map) subprojectmap.get("taskIndexMap");
									taskIndexMap.putAll(subprojectTaskIndexMap);

									taskLevelMap.put(outlineNumber, subprojectId);
									taskIndexMap.put(taskUID, subprojectId);

									if (outlineNumber.lastIndexOf(".") == -1) {
										parentId = strBusId;
									} else {
										levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
										parentId = (String) taskLevelMap.get(levelId);
									}

									String nextTaskId = getNextTaskId(outlineNumber, NextOutlineMap, TaskLevelMap, TaskLevelMapOld, OIDMap, OIDMapOld);
									task.setId(parentId);
									task.addExistingForMSProject(context, subprojectId , nextTaskId, relSubTask);

									ProjectIds.add(subprojectId);
								}
								//new task creation
								else {

									task = (Task) DomainObject.newInstance(m_ctxUserContext, DomainConstants.TYPE_TASK, DomainConstants.PROGRAM);// IR-185394V6R2013x
									String nextTaskId = getNextTaskId(outlineNumber, NextOutlineMap, TaskLevelMap, TaskLevelMapOld, OIDMap, OIDMapOld);									

									String taskParentId = null;
									project.setId(strBusId);

									if (outlineNumber.lastIndexOf(".") == -1) {
										taskParentId = strBusId;
										if (debug) {
											System.out.println("Creating task under project ID " + strBusId);
										}

										boolean retValue = mspiCreateTask(context, task, taskType, taskName, project, true, nextTaskId);
									} // if(outlineNumber.lastIndexOf(".") == -1)
									else {

										levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
										parentId = (String) taskLevelMap.get(levelId);
										parentTask.setId(parentId);
										//task.clear();
										taskParentId = parentId;
										if (debug) {
											System.out.println("creating hierarchial task under " + parentId);
										}
										if (nextTaskId == null)
											nextTaskId = taskParentId;
										boolean retValue = mspiCreateTask(context, task, taskType, taskName, parentTask, false, nextTaskId);

										if (debug) {
											System.out.println("Task creation completed");
										}
									} // else
									task.setDescription(context, taskDesc);
									if (taskState != null && !taskState.equals(""))
										task.setState(context, taskState);
									task.setOwner(context, owner);
									String newTaskId = task.getId(context);
									taskLevelMap.put(outlineNumber, newTaskId);
									taskIndexMap.put(taskUID, newTaskId);

									Map attributeMap = new HashMap();// set the attributes of newly created tasks

									Set<String> taskColKeys = new HashSet<String>(taskColAttrMap.keySet());
									Iterator<String> taskColKeysIter = taskColKeys.iterator();

									while(taskColKeysIter.hasNext()) {

										Map colSettingMap = new HashMap();
										String sTaskSelectable = taskColKeysIter.next();
										colSettingMap = taskColAttrMap.get(sTaskSelectable);
										String columnName = (String)colSettingMap.get("Name");										

										// below keys needs to skip as details of this needs to handle with different API
										if(basicfieldsToIgnoreInSave.contains(columnName)) 
											continue;
										String sValue = (String) newTaskValueMap.get(columnName);
										String sKey = null;
										if(sValue != null && !sValue.equals(""))
										{

											if(sTaskSelectable.contains("attribute")) 
												sKey = sTaskSelectable.substring(sTaskSelectable.indexOf("[") + 1, sTaskSelectable.indexOf("]"));
											else
												sKey = sTaskSelectable;								  
										}
										if(sKey!= null) {
											if(scheduleFieldsInSave.contains(columnName)){

												String columnType = (String)colSettingMap.get("MPIColumnType");

												if(columnType.equals("date")) {
													if(sValue.length() > 0)
													{
														Date tempDate = MATRIX_DATE_FORMAT.parse(sValue);
														addUpdate(tasks, newTaskId, sKey, tempDate);
													}
													else
														attributeMap.put(sKey, "");
												}
												else
													addUpdate(tasks, newTaskId, sKey, sValue);
											}
											else
												attributeMap.put(sKey, sValue);
										}
									}

									codeRegn = "Existing Subproject setting task attribute ";
									task.setAttributeValues(context, attributeMap);
								}
							}
						}

						if (debug) {
							iterationEndTime = System.currentTimeMillis();
							long iterationTime = iterationEndTime - iterationStartTime;
							System.out.println("TOTAL TIME in Iteration for new tasks (in Secs): " + (float) iterationTime / 1000);
						}
					} // while (addedListItr.hasNext())
				} // if(addedList != null)

				if (!removedList.isEmpty()) {					
					deleteTasks(context, removedList, taskLevelMap, strBusId);
				}

				codeRegn = "Merge - Modify the task attributes of subproject";
				Map oldMap = new HashMap();
				Map mspMap = new HashMap();
				ListIterator taskDataMapListItr = taskDataMapList.listIterator();

				// get to the end of the map list the maplist is top-down wrt to the project tasks
				// when we try to save the attributes of a task if we set the
				// parents percentage as 100% PC's trigger will block the event
				// (since the child is still 0%) so go to the end of the list and
				// start the attribute setting from the child then going upwards
				while (taskDataMapListItr.hasNext()) {
					mspMap = (Map) taskDataMapListItr.next();
				}

				int taskCounter = taskDataMapList.size();

				while (taskDataMapListItr.hasPrevious()) {

					mspMap = (Map) taskDataMapListItr.previous();
					if (taskCounter == 1) {
						continue;
					}
					taskCounter--;
					String mspTaskId = (String) mspMap.get("taskId");
					if (mspTaskId != null && !mspTaskId.equals("")) {
						ListIterator oldTaskDataMapListItr = oldTaskDataMapList.listIterator();
						while (oldTaskDataMapListItr.hasNext()) {
							oldMap = (Map) oldTaskDataMapListItr.next();
							String oldTaskId = (String) oldMap.get("taskId");
							if (oldTaskId != null && oldTaskId.equals(mspTaskId)) {
								break;
							}
						}
						// need to check whether this shud be there for sub project also
						if (ProjectIds.indexOf(mspTaskId) >= 0) {
							continue;
						}

						Map newSubprojectmap = (Map) mspMap.get("subprojectMap");
						Map oldSubprojectmap = (Map) oldMap.get("subprojectMap");

						if (newSubprojectmap != null && oldSubprojectmap != null) {
							oldSubprojectmap.put("taskIndexMap", oldTaskIndexMap);
							newSubprojectmap.put("taskIndexMap", taskIndexMap);
							SynchronizeExistingProject(context, mspTaskId, newSubprojectmap, oldSubprojectmap, tasks);
							Map taskIndexMap2 = (Map) newSubprojectmap.get("taskIndexMap");
							Map oldTaskIndexMap2 = (Map) oldSubprojectmap.get("taskIndexMap");
							taskIndexMap.putAll(taskIndexMap2);
							oldTaskIndexMap.putAll(oldTaskIndexMap2);
							continue;
						}
					} // if(mspTaskId != null && !mspTaskId.equals(""))
				} // while (taskDataMapListItr.hasPrevious())

				// check if the task attributes are modified and set them
				codeRegn = "Existing SubProject Merge - Modify the task attributes";

				// get to the end of the map list the maplist is top-down wrt to the project tasks
				// when we try to save the attributes of a task if we set the
				// parents percentage as 100% PC's trigger will block the event
				// (since the child is still 0%) so go to the end of the list and
				// start the attribute setting from the child then going upwards
				taskDataMapListItr = taskDataMapList.listIterator();
				while (taskDataMapListItr.hasNext()) {
					mspMap = (Map) taskDataMapListItr.next();
				}

				taskCounter = taskDataMapList.size();

				while (taskDataMapListItr.hasPrevious()) {
					mspMap = (Map) taskDataMapListItr.previous();
					if (taskCounter == 1) {
						continue;
					}
					taskCounter--;
					String mspTaskId = (String) mspMap.get("taskId");
					Iterator refRemovedItr = refRemovedList.iterator();

					boolean nodeInRemovedList = false;
					while (refRemovedItr.hasNext()) {
						Map refRemovedMap = (Map) refRemovedItr.next();
						if (mspTaskId.equals(refRemovedMap.get("taskId"))) {
							nodeInRemovedList = true;
							break;
						}
					}
					if (nodeInRemovedList) {
						continue;
					}

					if (mspTaskId != null && !mspTaskId.equals("")) {

						Map attributeMap = new HashMap();

						ListIterator oldTaskDataMapListItr = oldTaskDataMapList.listIterator();

						while (oldTaskDataMapListItr.hasNext()) {
							oldMap = (Map) oldTaskDataMapListItr.next();
							String oldTaskId = (String) oldMap.get("taskId");

							if (oldTaskId != null && oldTaskId.equals(mspTaskId)) {
								break;
							}
						}
						// need to check whether this shud be there for sub project also
						if (ProjectIds.indexOf(mspTaskId) >= 0) {
							continue;
						}
						task.setId(mspTaskId);
						// task data when the project was downloaded
						String oldTaskName = (String) oldMap.get("Name");
						String oldTaskDesc = (String) oldMap.get("Description");
						String oldTaskOwner = (String) oldMap.get("Owner");
						String oldTaskType = (String)oldMap.get("NodeType");
						String oldTaskCurrent = (String) oldMap.get("State");
						String oldTaskConstraintType= (String)oldMap.get("ConstraintType");
						String oldTaskConstraintDate= (String)oldMap.get("ConstraintDate");


						// task data, as obtained from MS Project
						String mspTaskName = (String) mspMap.get("Name");
						String mspTaskDesc = (String) mspMap.get("Description");
						String mspTaskOwner = (String) mspMap.get("Owner");
						String mspTaskType = (String)mspMap.get("NodeType");
						String mspTaskCurrent = (String) mspMap.get("State");
						String mspTaskConstraintType = (String)mspMap.get("ConstraintType");
						String mspTaskConstraintDate = (String)mspMap.get("ConstraintDate");

						boolean bTaskNameChanged = !(oldTaskName.equals(mspTaskName));
						boolean bTaskDescChanged =  !(oldTaskDesc.equals(mspTaskDesc));
						boolean bTaskOwnerChanged = !(oldTaskOwner.equals(mspTaskOwner));
						boolean bTaskStateChanged =  !(oldTaskCurrent.equals(mspTaskCurrent));
						boolean bTaskTypeChanged = !(oldTaskType.equals(mspTaskType));

						boolean bTaskConstraintTypeChanged = !(oldTaskConstraintType.equals(mspTaskConstraintType));
						boolean bTaskConstraintDateChanged = !(oldTaskConstraintDate.equals(mspTaskConstraintDate));
						if(bTaskConstraintDateChanged || bTaskConstraintTypeChanged) {
							if(mspTaskConstraintDate != "") {
								Date tempDate = MATRIX_DATE_FORMAT.parse(mspTaskConstraintDate);
								addUpdate(tasks, mspTaskId, ATTRIBUTE_TASK_CONSTRAINT_DATE, tempDate);
							}
							addUpdate(tasks, mspTaskId, ATTRIBUTE_TASK_CONSTRAINT_TYPE, mspTaskConstraintType);
						}
						Set<String> taskColKeys = new HashSet<String>(taskColAttrMap.keySet());
						Iterator<String> taskColKeysIter = taskColKeys.iterator();
						while(taskColKeysIter.hasNext()) {

							Map colSettingMap = new HashMap();
							String sTaskSelectable = taskColKeysIter.next();
							colSettingMap = taskColAttrMap.get(sTaskSelectable);
							String columnName = (String)colSettingMap.get("Name");

							if(basicfieldsToIgnoreInSave.contains(columnName) || 
									// below keys needs to skip as details of this needs to handle with different API
									columnName.equals("ConstraintDate") || columnName.equals("ConstraintType") ||
									// below key needs to skip as its relationship attribute 
									columnName.equals("WBS"))
								continue;

							if(sProjectSchduleBasedOn.equals("Estimated") && 
									(columnName.equals(ATTRIBUTE_TASK_ACTUAL_START_DATE) || columnName.equals(ATTRIBUTE_TASK_ACTUAL_FINISH_DATE))
									|| columnName.equals(ATTRIBUTE_TASK_ACTUAL_DURATION))

								continue; // skip to set actual data for estimated based scheduling project

							String sNewValue = (String) mspMap.get(columnName);
							String sKey = null;

							if(sTaskSelectable.contains("attribute")) 
								sKey = sTaskSelectable.substring(sTaskSelectable.indexOf("[") + 1, sTaskSelectable.indexOf("]"));
							else
								sKey = sTaskSelectable;

							boolean bTaskValueChanged = false; 
							String sOldValue = (String) oldMap.get(columnName);
							if(sOldValue != null) {
								bTaskValueChanged = !(sOldValue.equals(sNewValue));
							}

							if(bTaskValueChanged) {
								if(scheduleFieldsInSave.contains(columnName)){

									String columnType = (String)colSettingMap.get("MPIColumnType");								  

									if(columnType.equals("date")) {									  

										if(!sNewValue.equals("")) {
											Date tempDate = MATRIX_DATE_FORMAT.parse(sNewValue);
											//skip date modification if its summary task										  
											//if(sKey.equals(ATTRIBUTE_TASK_ESTIMATED_START_DATE) && ((String)mspMap.get("Summary")).equals("0"))
											if(((String)mspMap.get("Summary")).equals("0"))
											{
												//if(SFDependentTaskList.indexOf(mspTaskId) < 0) {
												addUpdate(tasks, mspTaskId, sKey, tempDate);
												//start and finish value is changed and no change in constraint type(when we add dependency)
												//if we dont set then constraint type is changed
												if(mspTaskConstraintDate != "") {
													tempDate = MATRIX_DATE_FORMAT.parse(mspTaskConstraintDate);
													addUpdate(tasks, mspTaskId, ATTRIBUTE_TASK_CONSTRAINT_DATE, tempDate);
												}
												addUpdate(tasks, mspTaskId, ATTRIBUTE_TASK_CONSTRAINT_TYPE, mspTaskConstraintType);
												//}
											}											  
										}
										else
											attributeMap.put(sKey, "");

									}
									else if(columnType.equals("duration")) {							  

										//skip duration modification if its summary task
										if(((String)mspMap.get("Summary")).equals("0")) {

											addUpdate(tasks, mspTaskId, sKey, sNewValue);
											//need to pass constraint type even if its not changed
											//(case: if duration is changed and if we dont pass constraint type then SNET is set.
											addUpdate(tasks, mspTaskId, ATTRIBUTE_TASK_CONSTRAINT_TYPE, mspTaskConstraintType);
										}
									}
									else
										addUpdate(tasks, mspTaskId, sKey, sNewValue);
								}
								else
									attributeMap.put(sKey, sNewValue);
							}
						}

						if(bTaskNameChanged || bTaskDescChanged || bTaskOwnerChanged || 
								bTaskStateChanged || bTaskTypeChanged)
						{
							if(bTaskNameChanged) {
								task.setName(context, mspTaskName);
							}
							if(bTaskDescChanged) {
								task.setDescription(context, mspTaskDesc);
							}
							if(bTaskOwnerChanged) {
								task.setOwner(context, mspTaskOwner);
							}
							if(bTaskStateChanged) {
								//IR-069442V6R2011x Begin -- added try catch for setState
								String sWellFormedMessage = "";
								try {
									task.setState(context, mspTaskCurrent);
								}
								catch(Exception ex) {
									if(debug)
										System.out.println("[emxMSProjectIntegration.executeSynchronizeMerge] Notice: \nPlease Take appropriate actions manually to Complete the Gate ERROR : " + ex.getMessage());
									if(mspTaskCurrent.equals(task.STATE_PROJECT_SPACE_COMPLETE))//IR-072641V6R2012 
										sWellFormedMessage = ex.getMessage() + "\nNotice: Please Take appropriate actions manually to Complete the Gate";
									else
										sWellFormedMessage = ex.getMessage();
									throw new Exception(sWellFormedMessage);
								}
								//IR-069442V6R2011x End
							}
							if(bTaskTypeChanged) {
								task.updateTaskType(context, mspTaskId, mspTaskType);
							}
						}
						if(attributeMap.size() > 0) {
							//task.setId(mspTaskId);
							task.setAttributeValues(context, attributeMap);
						}
					}//if(mspTaskId != null && !mspTaskId.equals(""))
				} // while (taskDataMapListItr.hasPrevious())

				if(!assigneeMapList.isEmpty() || !oldAssigneeMapList.isEmpty()) {
					// add new assignee or update existing assignees
					if (debug) {
						System.out.println("Existing SubProject add new assignee or update existing assignees");
					}
					addAssignees(context, assigneeMapList, resourceIndexMap, taskIndexMap, oldAssigneeMapList, oldResourceIndexMap, oldTaskIndexMap/*, taskUnitMap*/);
				}
			} // if (oldStructMapList.size() > 0 || newStructMapList.size() > 0)

			// Get the latest data for the current project and display in MSP by reusing findForCheckOut function
			// Generate response to get the latest using findForCheckOut
			Element elFFCRoot = new Element("transaction");
			elFFCRoot.setAttribute("cname", "findforcheckout");

			// now create placeholder for response
			Element elResponseArgumentsNode = new Element("arguments");
			elFFCRoot.addContent(elResponseArgumentsNode);

			// create the busid argument placeholder
			Element elBusIdArgument = new Element("argument");
			elBusIdArgument.setAttribute("name", "busid");
			elBusIdArgument.setText(strBusId);
			elResponseArgumentsNode.addContent(elBusIdArgument);

			// create the edit status argument placeholder on Merge to ematrix the edit flag will be reset to false
			// the user will have to explicitly "Launch the project in Edit mode"
			// inorder to make any further changes
			Element elEditStatusArgument = new Element("argument");
			elEditStatusArgument.setAttribute("name", "foredit");
			elEditStatusArgument.setText("true");
			elResponseArgumentsNode.addContent(elEditStatusArgument);

			String fileName = dumpTransactionXMLForServlet(elFFCRoot);
			if (debug) {
				System.out.println("done dumping the transaction xml file for SynchronizeExistingProject");
				mergeEndTime = System.currentTimeMillis();
				long totalMergeTime = mergeEndTime - mergeStartTime;

				System.out.println("TOTAL MERGE TIME (in SynchronizeExistingProject Secs): " + (float) totalMergeTime / 1000);
				System.out.println("================ END SynchronizeExistingProject ================");
			}

		} catch (Exception e) {
			ContextUtil.abortTransaction(context);
			throw new MatrixException(codeRegn + " " + e.getMessage());
		}
	}

	private Map SyncCustomAttributeForExistingProject(Map oldPrjInfoMap, Map prjInfoMap) {

		Map projectAttributes = new HashMap();
		//custom attribute sync
		Set<String> projectColKeys = new HashSet<String>(projectColAttrMap.keySet());
		Iterator<String> projectColKeysIter = projectColKeys.iterator();
		while(projectColKeysIter.hasNext()) {

			Map colSettingMap = new HashMap();
			String sProjectSelectable = projectColKeysIter.next();
			colSettingMap = projectColAttrMap.get(sProjectSelectable);
			String columnName = (String)colSettingMap.get("Name");

			// below keys needs to skip as details of this needs to handle with different API
			if(basicfieldsToIgnoreInSave.contains(columnName) || columnName.equals("Company") || columnName.equals("ScheduleFrom")
					|| columnName.equals("Start") || columnName.equals("Finish")) 
				continue;

			String sOldValue = (String) oldPrjInfoMap.get(columnName);
			String sNewValue = (String) prjInfoMap.get(columnName);
			String sKey = null;
			if(sProjectSelectable.contains("attribute")) 
				sKey = sProjectSelectable.substring(sProjectSelectable.indexOf("[") + 1, sProjectSelectable.indexOf("]"));
			else
				sKey = sProjectSelectable;

			boolean bTaskValueChanged = false; 
			if(sOldValue != null) 
				bTaskValueChanged = !(sOldValue.equals(sNewValue));


			if(bTaskValueChanged)
				projectAttributes.put(sKey, sNewValue);
		}
		return projectAttributes;
	}

	/*
	 * JPO Entry point from servlet
	 */
	public String dumpTransactionXMLForJPO(Context context, String[] args) throws Exception {

		eMatrixDateFormat.setEMatrixDateFormat(context);
		if (debug)
			System.out.println("================ START dumpTransactionXMLForJPO ================");

		String xmlOutPut = null;

		try {
			userLanguage = args[0];

			String XMLInputString = args[1];

			Element elCommandRoot = loadXMLSentFromServlet(XMLInputString);
			String strRequestName = elCommandRoot.getAttributeValue("cname");
			if (debug) {
				System.out.println("[dumpTransactionXMLForJPO] Request Name : " + strRequestName);
			}

			// Now invoke the respective method
			// Open a project and reload existing case
			if (strRequestName.equals("findforcheckout")) {
				xmlOutPut = executeFindForCheckout(context, new String[] { XMLInputString });
			}
			/*else if (strRequestName.equals("synchronizetoemx")) {
				xmlOutPut = executeSynchronizeToeMatrix(context, new String[] { XMLInputString });
			}*/
			// reload existing or User clicks view/edit in MSP from WBS page of browser
			/*else if (strRequestName.equals("synchronizefromemx")) {
				xmlOutPut = executeSynchronizeFromeMatrix(context, new String[] { XMLInputString });
			}*/
			// save
			else if (strRequestName.equals("synchronizemerge")) {
				xmlOutPut = executeSynchronizeMerge(context, new String[] { XMLInputString });
			}
			else if (strRequestName.equals("validateresource")) {
				xmlOutPut = executeValidateResource(context, new String[] { XMLInputString });
			}
			// To chk project existence
			else if (strRequestName.equals("isprojectexist")) {
				xmlOutPut = executeProjectExistenceCheck(context, new String[] { XMLInputString });
			}
			if (xmlForClient != null)
				xmlOutPut = xmlForClient;
		} catch (Exception ee) {
			// ee.printStackTrace();
			System.out.println("[[dumpTransactionXMLForJPO EXCEPTION]] :  " + ee.getMessage());
			throw new Exception(ee.getMessage());
		}
		if (debug)
			System.out.println("================ END dumpTransactionXMLForJPO ================");
		return xmlOutPut;
	}

	/**
	 * Get the Transaction XML file dumped by the servlet by directly reading
	 * from a local file or by checking it out.
	 * @param sXMLInputString  Name of the transaction xml file
	 */
	private Element loadXMLSentFromServlet(String sXMLInputString) throws Exception {

		SAXBuilder dombCommandLoader = new SAXBuilder();
		Document dCommand = dombCommandLoader.build(new StringReader(sXMLInputString));

		Element elCommandRoot = dCommand.getRootElement();
		if (elCommandRoot == null) {
			throw new Exception("Root element in loadXMLSentFromServlet() was: " + dCommand);
		}

		return elCommandRoot;
	}

	/**
	 * Dump the Transaction XML file for the servlet.
	 */
	private String dumpTransactionXMLForServlet(Element elResponseRoot) throws Exception {

		XMLOutputter xmloResponse = new XMLOutputter();
		Document dResponse = new Document(elResponseRoot);
		dResponse.setDocType(null);

		xmlForClient = xmloResponse.outputString(dResponse);

		return xmlForClient;
	}

	private void addToParent(Element elParentNode, String tagName, String nodeContent) {
		Element elCurrentNode = new Element(tagName);
		elCurrentNode.setText(nodeContent);
		elParentNode.addContent(elCurrentNode);
	}
	
	/**
	 * Converts the predecessor type from FF, FS,... format to Microsoft predecessor format and viceversa
	 * @param preType can be either FF, FS, SF, SS or 0, 1, 2, 3
	 * @param convertToMSProject true/false
	 *   true : change from PC based values to MS Project based predecessor Types
	 *   false: change from MS Project based values to PC based predecessor Types
	 */
	private String getPredecessorType(String preType, boolean convertToMSProject) {

		String mspPreType = null;
		if (convertToMSProject) {
			mspPreType = "1"; // default type
			if (preType.equals("FF"))
				mspPreType = "0";
			else if (preType.equals("FS"))
				mspPreType = "1";
			else if (preType.equals("SF"))
				mspPreType = "2";
			else if (preType.equals("SS"))
				mspPreType = "3";
		} else {
			if (preType.equals("0"))
				mspPreType = "FF";
			else if (preType.equals("1"))
				mspPreType = "FS";
			else if (preType.equals("2"))
				mspPreType = "SF";
			else if (preType.equals("3"))
				mspPreType = "SS";
		}
		return mspPreType;
	}

	private void addLastFirstNameToCache(Context context, String userLastNameFirstName) throws FrameworkException {

		if (debug)
			System.out.println("================ START addLastFirstNameToCache ================");
		String vaultFilter = "*";
		StringList busSelects = new StringList();

		busSelects.addElement(person.SELECT_ID);
		busSelects.addElement(person.SELECT_NAME);
		busSelects.addElement(person.SELECT_FIRST_NAME);
		busSelects.addElement(person.SELECT_LAST_NAME);
		busSelects.addElement("to[Member].from.type.kindof[Organization]");// IR-016606V6R2012 fix

		// value supplied is for example "Everything Test"
		// if the user specified in the defined format ignore the value
		if (userLastNameFirstName.indexOf(" ") != -1) {

			String lastName = userLastNameFirstName.substring(0, userLastNameFirstName.indexOf(" "));
			String firstName = userLastNameFirstName.substring(userLastNameFirstName.lastIndexOf(" ")).trim();

			String whereClause = person.SELECT_FIRST_NAME + " match '*" + firstName + "'";
			whereClause += " && " + person.SELECT_LAST_NAME + " match '" + lastName + "*" + "'";

			MapList ml = findObjects(
					context, // eMatrix context
					TYPE_PERSON, // type pattern
					"*", // name pattern
					"*", // revision pattern
					"*", // owner pattern
					vaultFilter, // vault pattern
					whereClause, // where expression
					false, // expand type
					busSelects); // object selects

			Iterator mlitr = ml.iterator();

			while (mlitr.hasNext()) {
				Map map = (Map) mlitr.next();

				String personFullName = (String) map.get(person.SELECT_LAST_NAME) + " " + map.get(person.SELECT_FIRST_NAME);

				if (personFullName.equals(userLastNameFirstName)) {
					// IR-016606V6R2012 fix
					String isItPresentInOrg = (String) map.get("to[Member].from.type.kindof[Organization]");
					if (isItPresentInOrg != null) {
						// add the values to the cache
						_personInfo.put(userLastNameFirstName, map.get(person.SELECT_NAME));
					}
					break;
				}
			}
		}
		if (debug)
			System.out.println("================ END addLastFirstNameToCache ================");
	}

	/**
	 * Read the project node and fetch all the details in a maplist for
	 * processing merge command
	 */
	private Map readXMLDataForMerge(Context context, Element projectNode, boolean existingProject, boolean projectxml,
			Map taskIndexMap, MapList taskMapListForDependency)
					throws MatrixException {

		codeRegn = "Inside readXMLDataForMerge";
		if (debug) {
			System.out.println("================ START readXMLDataForMerge ================");
			xmlDataForMerge_BeginTime = System.currentTimeMillis();
		}
		try {

			String constraintType = null;
			String constraintTypeShortValue = null;
			//String prjCalendar = "";
			String scheduleFromStart = null;

			SimpleDateFormat mspDate = new SimpleDateFormat("yyyy-M-d'TO'H:mm:ss");

			Map projectInfoMap = new HashMap();
			Map taskLevelMap = new HashMap();
			Map ProjectSpaceMap = new HashMap();
			Map CWBS2WBSMap = new HashMap();
			Map WBS2ChildCountMap = new HashMap();
			Map seqNoMap = new HashMap();

			Set<String> prjColKeys = new HashSet<String>(projectColAttrMap.keySet());

			Iterator<String> prjColKeysIter = prjColKeys.iterator();

			while(prjColKeysIter.hasNext()) {

				Map colSettingMap = new HashMap();
				String sKey = prjColKeysIter.next();
				colSettingMap = projectColAttrMap.get(sKey);

				String columnName = (String)colSettingMap.get("Name");
				String columnType = (String)colSettingMap.get("MPIColumnType");

				if(projectNode.getChild(columnName) != null)
				{
					if(projectNode.getChild(columnName).getName().equals("Name")) {
						// considering title value as a project name
						projectInfoMap.put(columnName, projectNode.getChild("Title").getText());
					}					
					else if(projectNode.getChild(columnName).getName().equals("ScheduleFrom")) {
						scheduleFromStart = (String)projectNode.getChild("ScheduleFrom").getText();
						if(scheduleFromStart.equals("True"))
							scheduleFromStart ="Project Start Date";
						else
							scheduleFromStart ="Project Finish Date";
						projectInfoMap.put(columnName, scheduleFromStart);
					}
					else if(columnType != null && columnType != "") {
						String content = projectNode.getChild(columnName).getText();
						content = getDetailsAsPerFormat(columnType.toLowerCase(), content, mspDate);
						projectInfoMap.put(columnName, content);					
					}
					else
						projectInfoMap.put(columnName, projectNode.getChild(columnName).getText());
				}
			}	

			// Project Calendar
			/*if (projectNode.getChild("Calendar") != null)
				prjCalendar = (String) projectNode.getChild("Calendar").getText();

			projectInfoMap.put("ProjectCalendar", prjCalendar);*/

			// projectInfoMap.put("company", projectNode.getChild("Company").getText());

			Element elTasksNode = projectNode.getChild("Tasks");

			List lTasks = elTasksNode.getChildren("Task");

			ListIterator litTaskCtr = lTasks.listIterator();
			int i = 0;
			int WBSCounter = 1;
			String strSeqNo = null;
			int seqNo = 0;
			String ParentChildCount;
			String ParentCWBS;
			String ParentWBS;

			Set<String> taskColKeys = new HashSet<String>(taskColAttrMap.keySet());

			MapList taskInfoMapList = new MapList();
			while (litTaskCtr.hasNext()) {
				Map subProjectMap = null;
				//the first task is the summary task of the project, this has only
				//few details like duration, %age complete etc
				Element elNextArgumentNode = (Element) litTaskCtr.next();
				Map taskMap = new HashMap();

				//this portion is common for project (first value in the iterator) as well as task
				String outlineNumber = elNextArgumentNode.getChild("OutlineNumber").getText();				
				taskMap.put("Summary", elNextArgumentNode.getChild("Summary").getText());

				//[Changes made to support creation of Projects of Sub types from MSProject]
				Element elProjectNode = elNextArgumentNode.getChild("Project");
				if (elProjectNode != null) {
					subProjectMap = new HashMap();
					subProjectMap = readXMLDataForMerge(context, elProjectNode, existingProject, projectxml, taskIndexMap, taskMapListForDependency);

					if (subProjectMap != null) {
						taskMap.put("subprojectMap", subProjectMap);
					}
				}

				Iterator<String> taskColKeysIter = taskColKeys.iterator();
				while(taskColKeysIter.hasNext()) {

					Map colSettingMap = new HashMap();
					String sKey = taskColKeysIter.next();
					colSettingMap = taskColAttrMap.get(sKey);

					String columnName = (String)colSettingMap.get("Name");
					String columnType = (String)colSettingMap.get("MPIColumnType");

					String sIgnoreForServer = (String)colSettingMap.get("MPIIgnoreForServer"); 

					if(sIgnoreForServer != null && sIgnoreForServer.equals("true"))
						continue;

					if(elNextArgumentNode.getChild(columnName) != null) {

						if(elNextArgumentNode.getChild(columnName).getName().equals("WBS") || 
								elNextArgumentNode.getChild(columnName).getName().equals("OutlineNumber"))
							continue;

						if(columnType != null && columnType != "") {
							String content = elNextArgumentNode.getChild(columnName).getText();
							content = getDetailsAsPerFormat(columnType.toLowerCase(), content, mspDate);
							taskMap.put(columnName, content);					
						}
						else 
							taskMap.put(columnName, (String)elNextArgumentNode.getChild(columnName).getText());
					}
					else
						taskMap.put(columnName, "");
				}

				if (i != 0) {

					String WBS = null;
					String prjSpaceOutlineNumber = null;

					/*Element taskCalendar = elNextArgumentNode.getChild("Calendar");

					if (taskCalendar != null)
						taskMap.put("taskCalendar", taskCalendar.getText());
					else
						taskMap.put("taskCalendar", "");*/

					if (outlineNumber.indexOf(".") < 0) {
						WBS = Integer.toString(WBSCounter);
						WBSCounter++;
						CWBS2WBSMap.put(outlineNumber, WBS);
						WBS2ChildCountMap.put(WBS, "0");
					} else {
						ParentCWBS = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
						ParentWBS = (String) CWBS2WBSMap.get(ParentCWBS);
						ParentChildCount = (String) WBS2ChildCountMap.get(ParentWBS);

						WBS = ParentWBS + "." + (Integer.valueOf(ParentChildCount) + 1);
						CWBS2WBSMap.put(outlineNumber, WBS);
						WBS2ChildCountMap.put(ParentWBS, Integer.toString(Integer.valueOf(ParentChildCount) + 1));
						WBS2ChildCountMap.put(WBS, "0");
					}
					//taskMap.put("WBS", WBS);
					outlineNumber = WBS;
					//if(isProjectSpace(context, taskType))
					String taskType = elNextArgumentNode.getChild("NodeType").getText();
					if(slProjectSpaceSubTypes.contains(taskType))
					{
						ProjectSpaceMap.put(outlineNumber, outlineNumber);
						seqNoMap.put(outlineNumber, "0");
					}else if (outlineNumber.lastIndexOf(".") > -1) {

						prjSpaceOutlineNumber = (String) ProjectSpaceMap
								.get(outlineNumber.substring(0, outlineNumber.lastIndexOf(".")));
						if (prjSpaceOutlineNumber != null) {
							ProjectSpaceMap.put(outlineNumber, prjSpaceOutlineNumber);
						}
					}
					if (outlineNumber.lastIndexOf(".") == -1) {
						WBS = outlineNumber;
					} else {

						String levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
						prjSpaceOutlineNumber = (String) ProjectSpaceMap.get(levelId);

						if (prjSpaceOutlineNumber == null) {
							WBS = outlineNumber;
						} else
							WBS = outlineNumber.substring(prjSpaceOutlineNumber.length() + 1, outlineNumber.length());
					}

					if (outlineNumber.lastIndexOf(".") > -1) {
						String levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));
						prjSpaceOutlineNumber = (String) ProjectSpaceMap.get(levelId);

						if (prjSpaceOutlineNumber == null || prjSpaceOutlineNumber.equals("")) {
							seqNo++;
							taskMap.put("SeqNo", Integer.toString(seqNo));
						} else {
							strSeqNo = (String) seqNoMap.get(prjSpaceOutlineNumber);
							taskMap.put("SeqNo", Integer.toString(Integer.valueOf(strSeqNo) + 1));
							seqNoMap.put(prjSpaceOutlineNumber, Integer.toString(Integer.valueOf(strSeqNo) + 1));
						}
					}
					else {
						seqNo++;
						taskMap.put("SeqNo", Integer.toString(seqNo));
					}
					taskMap.put("WBS", WBS);
					taskMap.put("OutlineNumber", outlineNumber);
					taskMap.put("taskUID", elNextArgumentNode.getChild("UID").getText());

					codeRegn = "Reading PredLink";

					List lPreds = elNextArgumentNode.getChildren("PredecessorLink");
					ListIterator listPredsCtr = lPreds.listIterator();

					while (listPredsCtr.hasNext()) {
						Element predecessorElement = (Element) listPredsCtr.next();
						Element predecessorUIDElement = (Element) predecessorElement.getChild("PredecessorUID");

						if (predecessorUIDElement != null) {

							String predecessorUID = predecessorElement.getChild("PredecessorUID").getText();
							String preType = predecessorElement.getChild("Type").getText();
							// convert the pretype into PC based based pretype values
							String pcPreType = getPredecessorType(preType, false);
							String linkLag = predecessorElement.getChild("LinkLag").getText();
							// the default format is in hours
							// convert it into days
							Double iLinkLag;
							if (null != linkLag && !"".equals(linkLag)) {
								iLinkLag = new Double(Double.valueOf(linkLag).doubleValue());
								// in case of prevproject xml, this conversion not reqd as its already done when loaded from PMC to MSP
								/*if (projectxml) {
									linkLag = Double.toString(iLinkLag.doubleValue() / (8 * 60));
								} else*/
								linkLag = Double.toString(iLinkLag.doubleValue());
							} else {
								linkLag = "0";
							}
							// 332795
							Double dLinkLag = Double.parseDouble(linkLag) * 100;

							linkLag = Double.toString(Math.rint(dLinkLag) / 100);

							Map dependencyMap = new HashMap();
							dependencyMap.put("taskUID", elNextArgumentNode.getChild("UID").getText());
							dependencyMap.put("preUID", predecessorUID);
							dependencyMap.put("linkLag", linkLag);
							dependencyMap.put("pcPreType", pcPreType);

							// store the values in a maplist for creating dependency at a later stage
							taskMapListForDependency.add(dependencyMap);
						} // if(predecessorUIDElement != null)
					} // while (listPredsCtr.hasNext())
				} // if(i != 0)

				// if existing project then the taskIds of the task is available in MS Project
				// generate a list for adding/deleting/modifying structure on merge
				codeRegn = "done with dependency, assignee, resources. Reading taskUID";

				if (existingProject && i != 0) {
					Element elExtendedAttrib = elNextArgumentNode.getChild("ExtendedAttribute");
					String currentTaskId = elExtendedAttrib.getChild("Value").getText();
					taskLevelMap.put(outlineNumber, currentTaskId);
					taskIndexMap.put(elNextArgumentNode.getChild("UID").getText(), currentTaskId);
					taskMap.put("taskId", currentTaskId);
				}

				taskInfoMapList.add(taskMap);
				i++;
			} // while (litTaskCtr.hasNext())

			// build the resource list
			codeRegn = "fetch resources";
			Map resourceIndexMap = new HashMap();
			Map resourceNameMap = new HashMap();
			Element elResources = projectNode.getChild("Resources");
			List lResources = elResources.getChildren("Resource");

			ListIterator listResourceCtr = lResources.listIterator();

			int k = 1;
			StringList resourceList = new StringList();
			while (listResourceCtr.hasNext()) {
				Element elResource = (Element) listResourceCtr.next();
				if (k == 1) {
					// the first set of values is the summary node of MSP datamodel
					// ignore the same for PC model
					k++;
					continue;
				}
				String resourceUID = elResource.getChild("UID").getText();
				String userLastFirstName = elResource.getChild("Name").getText();

				// the resourceIndexMap generated above has the lastName (space) firstName
				// for the resourcename (as mentioned by the user in MSP)
				// convert the lastName (space) firstName into personId
				// find the person id of the person with the given Last name First Name
				// if it is not found then add to the _personInfo for caching
				if (_personInfo != null && _personInfo.get(userLastFirstName) == null) {
					// found new Last Name First Name, add to cache
					addLastFirstNameToCache(context, userLastFirstName);
				}

				// get the personName from cache map
				String personName = (String) _personInfo.get(userLastFirstName);
				resourceNameMap.put(resourceUID, userLastFirstName);
				if (personName != null && !personName.equals("")) {
					String personId = person.getPerson(context, personName).getId(context);
					resourceIndexMap.put(resourceUID, personId);
				} else {
					resourceIndexMap.put(resourceUID, "");
				}
				if (!userLastFirstName.equals(""))
					resourceList.add(userLastFirstName);
			} // while (listResourceCtr.hasNext())

			Element elAssignments = projectNode.getChild("Assignments");

			List lAssignment = elAssignments.getChildren("Assignment");

			MapList assigneeMapList = new MapList();
			ListIterator listAssignmentCtr = lAssignment.listIterator();

			//Map taskUnitsDataMap = new HashMap();

			while (listAssignmentCtr.hasNext()) {
				Element elAssignment = (Element) listAssignmentCtr.next();
				Map assigneeMap = new HashMap();

				String taskUID = elAssignment.getChild("TaskUID").getText();
				String resourceUID = elAssignment.getChild("ResourceUID").getText();

				String units = elAssignment.getChild("Units").getText();
				//boolean firstTime = true;

				//if (firstTime) {
				//taskUnitsDataMap.put("taskUID", taskUID);
				//taskUnitsDataMap.put("resourceUID", resourceUID);
				//taskUnitsDataMap.put("units", units);
				//firstTime = false;
				//}

				assigneeMap.put("taskUID", taskUID);
				assigneeMap.put("resourceUID", resourceUID);

				assigneeMap.put("units", units);
				assigneeMapList.add(assigneeMap);
			}

			Map projectDataMap = new HashMap();
			projectDataMap.put("projectData", projectInfoMap);
			projectDataMap.put("taskData", taskInfoMapList);
			projectDataMap.put("resourceIndexMap", resourceIndexMap);
			projectDataMap.put("assigneeMapList", assigneeMapList);
			projectDataMap.put("taskLevelMap", taskLevelMap);
			projectDataMap.put("resourceNameMap", resourceNameMap);

			if (debug)
			{
				xmlDataForMerge_EndTime = System.currentTimeMillis();
				long total_xmlDataForMerge_Time = xmlDataForMerge_EndTime - xmlDataForMerge_BeginTime;
				System.out.println("================ END readXMLDataForMerge ================");
			}
			return projectDataMap;

		} catch (Exception e) {
			throw new MatrixException(codeRegn + " " + e.toString());
		}
	}

	private String getDetailsAsPerFormat(String columnType, String content, SimpleDateFormat mspDate) throws Exception {

		if(columnType.equals("date") && !content.equals("")) {
			Date date = mspDate.parse(content);	
			content = MATRIX_DATE_FORMAT.format(date);
		}
		/*else if(columnType.equals("percent")) {
			//return as it is
		}*/
		else if(columnType.equals("duration")) {
			content = getDurationInReqrdForm(content);
		}
		else if(columnType.equals("constraint")) {  			
			content = GetConstraintNameMap.get(content);
		}
		else if(columnType.equals("user")) {
			if(_personInfo != null && _personInfo.get(content) == null)
			{
				//found new Last Name First Name, add to cache
				addLastFirstNameToCache(m_ctxUserContext, content);  				
			}
			String personName = (String) _personInfo.get(content);
			if(personName != null && !personName.equals("")) 
			{
				content = personName;
			}
		}

		return content;
	}

	private String getDurationInReqrdForm(String durnContent) {

		if(durnContent != "") {

			String actHrsDuration, actMinsDuration;
			actHrsDuration = durnContent.substring(2, durnContent.indexOf("H"));
			actMinsDuration = durnContent.substring(durnContent.indexOf("H") + 1,durnContent.indexOf("M"));
			durnContent = Double.toString((Double.valueOf(actHrsDuration) / 8 + Double.valueOf(actMinsDuration) / (60 * 8) ));
			Double dEstimated = Double.parseDouble(durnContent) * 100;

			Double dEstimated1 = Math.rint(dEstimated);
			Double dEstimated2 = dEstimated1 / 100;
			durnContent = Double.toString(dEstimated2);	
		}
		return durnContent;
	}

	private ArrayList readXMLDataForValidateResource(Element ResourceNode) throws MatrixException {

		try {
			List lResource = ResourceNode.getChildren("Resource");
			ArrayList<String> Resourcelist = new ArrayList<String>();

			ListIterator listResourceCtr = lResource.listIterator();

			while (listResourceCtr.hasNext()) {

				Element elResource = (Element) listResourceCtr.next();
				String sResourceName = elResource.getText();
				Resourcelist.add(sResourceName);
			}

			return Resourcelist;
		} catch (Exception e) {
			throw new MatrixException(e.toString());			
		}
	}

	/**
	 * Create dependencies for a given task
	 *
	 * @param dependencyMapList  Maplist of contents that needs to added or modified
	 * @param removedDependencyMapList Maplist of contents that needs to be deleted
	 *   true : change from PC based values to MS Project based predecessor Types
	 *   false: change from MS Project based values to PC based predecessor Types
	 */
	private MapList addDependency(Context context, MapList dependencyMapList, MapList removedDependencyList, Map taskIndexMap, boolean projectExists) throws MatrixException
	{
		codeRegn = "Inside addDependency";
		if (debug)
			System.out.println("================ START addDependency ================");
		try {

			MapList tempRemovedDependencyList = new MapList();

			if (removedDependencyList != null) {
				tempRemovedDependencyList.addAll(removedDependencyList);
			}
			ListIterator dependencyItr = dependencyMapList.listIterator();

			StringList busSelects = new StringList(1);
			StringList relSelects = new StringList(1);

			busSelects.add(task.SELECT_ID);
			relSelects.add(dependency.SELECT_DEPENDENCY_TYPE);
			relSelects.add(dependency.SELECT_LAG_TIME);

			while (dependencyItr.hasNext())
			{
				Map dependencyMap = (Map) dependencyItr.next();
				String preTaskId = (String)dependencyMap.get("preId");
				String taskId = (String)dependencyMap.get("taskId");
				String pcPreType = (String)dependencyMap.get("pcPreType");
				String linkLag = (String)dependencyMap.get("linkLag");

				boolean addPred = false;

				//this task might have been deleted
				//check if this task exists if it exists then remove the assignee
				if(taskIndexMap.containsValue(taskId))
				{
					// task exists
					task.setId(taskId);
					if (projectExists) {

						MapList predecessorList = task.getPredecessors(context, busSelects, relSelects, null);

						// if no predecessors exist then add it
						if (predecessorList.size() == 0) {
							addPred = true;
						}
						else {
							//check if this pred already exists
							//if it exists then check if the values are different
							if (debug)
								System.out.println("======== Modifying a predecessor ========");

							addPred = true;
							Iterator predecessorItr = predecessorList.iterator();
							while (predecessorItr.hasNext())
							{
								Map predecessorObj = (Map) predecessorItr.next();
								String predecessorId = (String) predecessorObj.get(task.SELECT_ID);
								if (debug)
									System.out.println("predecessorId: " + predecessorId);
								if (predecessorId.equals(preTaskId))
								{
									String depType = (String) predecessorObj.get(dependency.SELECT_DEPENDENCY_TYPE);
									String depLag = (String) predecessorObj.get(dependency.SELECT_LAG_TIME);
									if (debug)
										System.out.println(" depType: " + depType + " depLag = " + depLag);

									if (!depType.equals(pcPreType) || !depLag.equals(linkLag)) {

										String connectionId = (String) predecessorObj.get(dependency.SELECT_ID);
										HashMap attributes = new HashMap();
										HashMap modifyPredMap = new HashMap();
										attributes.put(dependency.ATTRIBUTE_LAG_TIME, linkLag);
										attributes.put(dependency.ATTRIBUTE_DEPENDENCY_TYPE, pcPreType);
										modifyPredMap.put(connectionId, attributes);
										task.modifyPredecessors(context, (Map) modifyPredMap, false);

										// Begin Code to handle duration keyword IR-031267V6R2012
										String[] argsDependancy = new String[2];
										argsDependancy[0] = connectionId;
										argsDependancy[1] = taskId;
										JPO.invoke(context,"emxDurationKeywordsBase", null, "triggerModifyDependencyDurationKeyword", argsDependancy);
										//End Code to handle duration keyword IR-031267V6R2012										

										// To fix the issue : When direction of the dependency is changed. PBN Issue 95925
										// Remove the task/predecessor from tempRemovedDependencyList since the dependency is modified.
										ListIterator tempDependencyItr = tempRemovedDependencyList.listIterator();
										while (tempDependencyItr.hasNext()) {

											Map _map = (Map) tempDependencyItr.next();
											if (preTaskId.equals((String) _map.get("preId"))) {

												int index = tempRemovedDependencyList.indexOf(_map);
												if (tempRemovedDependencyList.contains(_map) && index >= 0) {

													tempRemovedDependencyList.remove(index);
													break;
												}
											}
										}
									}
									// found the dependency
									addPred = false;
									break;
								}
							}
						}
					} // check if project exists
					else {
						// project does not exist so just add the dependency no need to check
						addPred = true;
					}

					if (addPred) {

						// System.out.println("========Adding new predecessor...");
						Map attributes = new HashMap();
						Map addPredMap = new HashMap();
						attributes.put(dependency.ATTRIBUTE_LAG_TIME, linkLag);
						attributes.put(dependency.ATTRIBUTE_DEPENDENCY_TYPE, pcPreType);
						addPredMap.put(preTaskId, attributes);

						// In previous versions
						// task.addPredecessors(context, (Map) addPredMap, true);

						//adding predecessors in bulk, do not rollup dates for each task
						// rollup the dates only for the last task
						// Fix for faster first time checkin
						task.addPredecessors(context, (Map) addPredMap, false);
						/*if(counter != numDependency - 1)
						{
							if (debug)
								System.out.println("Adding new predecessor - No dates rollup " + counter);
							task.addPredecessors(context, (Map) addPredMap, true);
						}
						else
						{
							if (debug)
								System.out.println("Adding new predecessor - Dates rolling up " + counter);
							// [Changes made in 10.7.SP1.PQ1, Mar 22 07 to fix the BUG:
							// Dates are not merged correctly for dependnt task of the last dependency]
							task.addPredecessors(context, (Map) addPredMap, true);
							// [/Changes made in 10.7.SP1.PQ1, Mar 22 07 to fix the BUG:
							// Dates are not merged correctly for dependnt task of the last dependency]
						}
						counter++;*/
					} // add predecessor
				} else { // existing predecessor

					// on comparing the existing dependencyMapList with oldDependencyMapList, if the value
					// of the dependency is modified then it ends up in the removedDependencyMapList,
					// since modifications are already taken care of remove it from the removedDependencyMapList

					if (removedDependencyList != null) {
						Iterator removedDependencyListItr = removedDependencyList.iterator();
						while (removedDependencyListItr.hasNext()) {
							Map dMap = (Map) removedDependencyListItr.next();
							String remPreTaskId = (String) dMap.get("preId");
							String remTaskId = (String) dMap.get("taskId");

							if (remPreTaskId.equals(preTaskId) && remTaskId.equals(taskId)) {
								tempRemovedDependencyList.remove(dMap);
							}
						} // end while
					}
				}
			} // while (dependencyItr.hasNext())
			if (debug)
				System.out.println("================ END addDependency ================");
			return tempRemovedDependencyList; // To fix the issue : When direction of the dependency is changed. PBN Issue 95925
		} // end try
		catch (Exception e) {
			throw new MatrixException(codeRegn + " " + e.getMessage());
		}
	}

	/**
	 * Delete dependencies
	 * @param dependencyMapList : list of dependency
	 * @param taskIndexMap true/false : contains task UID as key and object id as calue
	 */
	private void removeDependency(Context context, MapList dependencyMapList, Map taskIndexMap) throws MatrixException
	{		
		if (debug)
			System.out.println("================ START removeDependency ================");
		try {
			codeRegn = "Deleting dependencies";			
			ListIterator dependencyItr = dependencyMapList.listIterator();

			StringList busSelects = new StringList(1);
			StringList relSelects = new StringList(1);
			busSelects.add(task.SELECT_ID);
			relSelects.add(dependency.SELECT_DEPENDENCY_TYPE);

			while (dependencyItr.hasNext()) {
				Map dependencyMap = (Map) dependencyItr.next();
				String preTaskId = (String) dependencyMap.get("preId");
				String taskId = (String) dependencyMap.get("taskId");

				// this task might have been deleted
				// check if this task exists if it exists then remove the dependency
				if (taskIndexMap.containsValue(taskId)) {
					// task exists set the Id of the task and obtain its dependencies
					task.setId(taskId);

					MapList predecessorList = task.getPredecessors(context, busSelects, relSelects, null);
					Iterator predecessorItr = predecessorList.iterator();
					List<String> listToDelete = new ArrayList<String>();

					while (predecessorItr.hasNext()) {
						Map predecessorObj = (Map) predecessorItr.next();
						String predecessorId = (String) predecessorObj.get(task.SELECT_ID);
						if (predecessorId.equals(preTaskId)) {

							String connectionId = (String) predecessorObj.get(dependency.SELECT_ID);
							listToDelete.add(connectionId);
							//task.removePredecessor(context, connectionId);
							break;
						}
					}
					String[] stringArray = listToDelete.toArray(new String[listToDelete.size()]);
					task.removePredecessors(context, stringArray, false);
				} // end if
			}
		} catch (Exception e) {
			throw new MatrixException(codeRegn + " " + e.getMessage());
		}
		if (debug)
			System.out.println("================ END removeDependency ================");
	}

	/**
	 * Add assignees for a given task
	 *
	 * @param assigneeMapList
	 * @param resourceIndexMap
	 * @param taskIndexMap
	 *
	 */
	private void addAssignees(Context context, MapList assigneeMapList, Map resourceIndexMap, Map taskIndexMap,
			MapList oldAssigneeMapList, Map oldResourceIndexMap, Map oldTaskIndexMap/*, Map taskUnitMap*/) throws MatrixException
	{
		codeRegn = "add assignments";

		if (debug)
		{
			System.out.println("================ START addAssignees ================");
			addAssignees_startTime = System.currentTimeMillis();
		}

		try {
			
			StringList busSelects = new StringList(2);
			MULTI_VALUE_LIST.add(SELECT_TASK_ASSIGNEE_ID);
			MULTI_VALUE_LIST.add(SELECT_RELATIONSHIP_CONNECTION_ID);
			busSelects.add(SELECT_TASK_ASSIGNEE_ID);
			busSelects.add(SELECT_RELATIONSHIP_CONNECTION_ID);
			
			// if oldAssigneeMapList is not null then addAssignees is for merge case of existing project
			// if null then add assignees is called during creation of a brand new project
			if (oldAssigneeMapList != null) {

				MapList comparisonAssigneeMapList = new MapList();
				MapList comparisonOldAssigneeMapList = new MapList();
				Map taskUnitsDataMap = new HashMap();
				Map assigneeUnitsMap = new HashMap();

				// convert the MS Project resource uid and task uid into PC person id and task id and compare if any new
				// assignments have been made or if existing assignments are modified
				ListIterator listAssignmentCtr = assigneeMapList.listIterator();
				while (listAssignmentCtr.hasNext()) {

					Map assigneeMap = (Map) listAssignmentCtr.next();
					String taskUID = (String) assigneeMap.get("taskUID");
					String resourceUID = (String) assigneeMap.get("resourceUID");
					// get the person id for the above resoure uid
					String personId = (String) resourceIndexMap.get(resourceUID);
					// get the task id for the above task uid
					String taskId = (String) taskIndexMap.get(taskUID);
					if (debug)
						System.out.println("**** personId = " + personId);

					String alloUnits = (String) assigneeMap.get("units");

					taskUnitsDataMap = new HashMap();
					taskUnitsDataMap.put("taskUID", taskUID);
					taskUnitsDataMap.put("resourceUID", resourceUID);
					taskUnitsDataMap.put("units", alloUnits);

					if (debug)
						System.out.println("**** setValues1 was called with AM units = " + alloUnits);
					setValues(context, taskId, personId, alloUnits, busSelects);

					Map personMap = new HashMap();
					personMap.put("personId", personId);
					personMap.put("taskId", taskId);

					comparisonAssigneeMapList.add(personMap);
					assigneeUnitsMap.put(personMap, taskUnitsDataMap);
				}

				ListIterator listOldAssignmentCtr = oldAssigneeMapList.listIterator();
				while (listOldAssignmentCtr.hasNext()) {

					Map oldAssigneeMap = (Map) listOldAssignmentCtr.next();
					String taskUID = (String) oldAssigneeMap.get("taskUID");
					String resourceUID = (String) oldAssigneeMap.get("resourceUID");
					// get the person id for the above resoure uid
					String personId = (String) oldResourceIndexMap.get(resourceUID);
					// get the task id for the above task uid
					String taskId = (String) oldTaskIndexMap.get(taskUID);

					String alloUnits = (String) oldAssigneeMap.get("units");

					taskUnitsDataMap = new HashMap();
					taskUnitsDataMap.put("taskUID", taskUID);
					taskUnitsDataMap.put("resourceUID", resourceUID);
					taskUnitsDataMap.put("units", alloUnits);

					Map personMap = new HashMap();
					personMap.put("personId", personId);
					personMap.put("taskId", taskId);
					comparisonOldAssigneeMapList.add(personMap);
					assigneeUnitsMap.put(personMap, taskUnitsDataMap);
				}
				// now iterate through the comparisonAssigneeMapList, check if each element
				// already exists in comparisonOldAssigneeMapList
				ListIterator comparisonAssigneeMapListItr = comparisonAssigneeMapList.listIterator();
				while (comparisonAssigneeMapListItr.hasNext()) {

					Map assigneeMap = (Map) comparisonAssigneeMapListItr.next();
					if (!(comparisonOldAssigneeMapList.contains(assigneeMap))) {

						// newly added or modified assingnee
						String taskId = (String) assigneeMap.get("taskId");
						if (ProjectIds.indexOf(taskId) >= 0) {
							continue;
						}
						String personId = (String) assigneeMap.get("personId");
						Map _taskUnitsDataMap = (Map) assigneeUnitsMap.get(assigneeMap);
						task.setId(taskId);
						// if the user specified name is not found then personId is "" in the map ignore this input
						if (personId != null && personId != "") {

							String units = (String) _taskUnitsDataMap.get("units");
							Float s = new Float((1.0 * 100) * (Double.valueOf(units)).doubleValue());
							units = s.toString();

							task.addAssignee(context, personId, null, units);
						}
					} else {
						// no change in the map remove it from the maplist
						comparisonOldAssigneeMapList.remove(assigneeMap);
					}
				}
				// after iterating the list the values not removed in the comparisonOldAssigneeMapList
				// are assignees removed from a given task, so remove the assignees
				ListIterator comparisonOldAssigneeMapListItr = comparisonOldAssigneeMapList.listIterator();

				while (comparisonOldAssigneeMapListItr.hasNext()) {
					Map assigneeMap = (Map) comparisonOldAssigneeMapListItr.next();
					// newly added or modified assignee
					String taskId = (String) assigneeMap.get("taskId");
					String personId = (String) assigneeMap.get("personId");

					// this task might have been deleted check if this task exists if it exists then remove the assignee
					if (taskIndexMap.containsValue(taskId)) {

						// task exists
						task.setId(taskId);

						// find the membership id
						StringList busSelect = new StringList();
						StringList relSelect = new StringList();
						busSelect.add(person.SELECT_ID);
						relSelect.add(assignee.SELECT_ID);
						MapList assigneeInfo = task.getAssignees(context, busSelect, relSelect, null);
						ListIterator assigneeInfoItr = assigneeInfo.listIterator();
						String membershipId = null;
						while (assigneeInfoItr.hasNext()) {

							Map aMap = (Map) assigneeInfoItr.next();
							if (aMap.get(person.SELECT_ID).equals(personId)) {
								membershipId = (String) aMap.get(assignee.SELECT_ID);
								break;
							}
						}
						if (personId != null && personId != "" && membershipId != null) {
							task.removeAssignee(context, membershipId);
						}
					}
				}
			} 
			else
			{
				// brand new project no comparisons required just add the assignees
				ListIterator listAssignmentCtr = assigneeMapList.listIterator();

				while (listAssignmentCtr.hasNext()) {
					Map assigneeMap = (Map) listAssignmentCtr.next();
					String taskUID = (String) assigneeMap.get("taskUID");
					String resourceUID = (String) assigneeMap.get("resourceUID");

					// get the person id for the above resoure uid
					String personId = (String) resourceIndexMap.get(resourceUID);
					// get the task id for the above task uid
					String taskId = (String) taskIndexMap.get(taskUID);

					if (ProjectIds.indexOf(taskId) >= 0) {
						continue;
					}

					task.setId(taskId);
					// if the user specified name is not found then personId is "" in the map ignore this input
					if (personId != null && personId != "") {
						if (debug)
							System.out.println("15 - Assignee Added");

						// task.addAssignee(context, personId, null);

						String units = (String) assigneeMap.get("units");
						Float s = new Float((1.0 * 100) * (Double.valueOf(units)).doubleValue());
						units = s.toString();
						task.addAssignee(context, personId, null, units);
					}
				}
			}
			if (debug) {
				addAssignees_endTime = System.currentTimeMillis();
				long addAssignees_totalTime = addAssignees_endTime - addAssignees_startTime;

				System.out.println("TOTAL TIME IN addAssignees (in Secs): " + addAssignees_totalTime);
				System.out.println("================ END addAssignees ================");
			}
		} catch (Exception e) {
			throw new MatrixException(codeRegn + " " + e.getMessage());
		}
	}

	/**
	 * Deletes the objects specified by the ids.
	 *
	 * @param context the eMatrix <code>Context</code> object
	 * @param objectIds the ids of the objects to delete
	 * @throws FrameworkException if the operation fails
	 * @since PC 10.0.0.0
	 * @grade 0
	 */
	private void deleteTasks(Context context, MapList removedList, Map taskLevelMap, String parentId)
			throws FrameworkException {

		codeRegn = "Deleting the task";
		if (debug)
			System.out.println("================ START deleteTasks ================");
		try {
			com.matrixone.apps.program.Task object = (com.matrixone.apps.program.Task) DomainObject.newInstance(context,
					TYPE_TASK, DomainConstants.PROGRAM);
			ListIterator removedListItr = removedList.listIterator();

			int j = 0;
			int listSize = removedList.size();
			String[] taskIds = new String[listSize];
			String[] outlineNumbers = new String[listSize];
			String taskState = DomainConstants.EMPTY_STRING;

			while (removedListItr.hasNext()) {

				Map mspMap = (Map) removedListItr.next();
				taskIds[j] = (String) mspMap.get("taskId");
				outlineNumbers[j] = (String) mspMap.get("OutlineNumber");
				j++;
			}
			StringList busSelects = new StringList(3);
			busSelects.add(DomainConstants.SELECT_CURRENT);
			busSelects.add(DomainConstants.SELECT_ID);
			busSelects.add(DomainConstants.SELECT_NAME);
			MapList taskInfoList = DomainObject.getInfo(context, taskIds, busSelects);
			StringList taskInCreate = new StringList();
			StringList taskInNonCreate = new StringList();

			for (int k = 0; k < listSize; k++) {

				Map infoMap = (Map) taskInfoList.get(k);
				taskState = (String) infoMap.get(DomainObject.SELECT_CURRENT);
				String taskId = (String) infoMap.get(DomainConstants.SELECT_ID);
				String taskName = (String) infoMap.get(DomainConstants.SELECT_NAME);

				if (AllOldProjectIds.indexOf(taskId) >= 0 )
				{
					subProject.setId(taskId);
					StringList busSelect = new StringList();
					busSelect.add("to[" + RELATIONSHIP_SUBTASK + "].id");
					Map taskInfo = subProject.getInfo(context, busSelect);
					String connectionId = (String) taskInfo.get("to[" + RELATIONSHIP_SUBTASK + "].id");
					DomainRelationship.disconnect(context, connectionId);
					continue;
				}	

				if (!"Create".equalsIgnoreCase(taskState)) {
					taskInNonCreate.add(taskName);
					taskLevelMap.remove(outlineNumbers[k]);
				} else {
					taskInCreate.add(taskId);
				}
			}
			String[] tasksToDelete = (String[]) taskInCreate.toArray(new String[taskInCreate.size()]);

			if (tasksToDelete.length > 0) {
				object.setId(parentId);
				object.delete(context, tasksToDelete);
			}
			if (taskInNonCreate.size() > 0) {
				StringBuilder errorMessage = new StringBuilder(
						"Unable to delete listed task(s). Task is beyond Create state: \n [");
				int taskListSize = taskInNonCreate.size();
				for (int k = 0; k < taskListSize; k++) {

					errorMessage.append(taskInNonCreate.get(k));
					if (k <= taskListSize - 2) {
						errorMessage.append(",");
					}
				}
				errorMessage.append("]");
				throw new Exception(errorMessage.toString());
			}
		} catch (Exception e) {
			ContextUtil.abortTransaction(context);
			throw (new FrameworkException(e));
		}
		if (debug)
			System.out.println("================ END deleteTasks ================");
	}

	/**
	 * The values contained in the dependency maplist is MS Project uids these
	 * uids change with each operation This function converts the uid into PC
	 * taskIds
	 *
	 * @param context the user context object for the current session.
	 * @throws FrameworkException if operation fails.
	 * @since AEF 10.0.0.0
	 * @grade 0
	 */
	private MapList convertDependency(MapList dependencyMapList, Map taskIndexMap, StringList SFDependentTaskList)
			throws FrameworkException {

		if (debug)
			System.out.println("================ START convertDependency ================");

		MapList pcDependencyMapList = new MapList();
		// the values contained in the maplist is using uid from MS Project
		// convert it to ids of PC and compare the two maplist
		if (SFDependentTaskList == null) {

			ListIterator dependencyItr = dependencyMapList.listIterator();

			while (dependencyItr.hasNext()) {
				Map dependencyMap = (Map) dependencyItr.next();
				String preUID = (String) dependencyMap.get("preUID");
				String taskUID = (String) dependencyMap.get("taskUID");
				String pcPreType = (String) dependencyMap.get("pcPreType");
				String linkLag = (String) dependencyMap.get("linkLag");

				// get the dependency taskId from the map
				String preTaskId = (String) taskIndexMap.get(preUID);
				String taskId = (String) taskIndexMap.get(taskUID);

				// store the map back in terms of pc taskId and predIds
				Map pcDependencyMap = new HashMap();
				pcDependencyMap.put("preId", preTaskId);
				pcDependencyMap.put("taskId", taskId);
				pcDependencyMap.put("pcPreType", pcPreType);
				pcDependencyMap.put("linkLag", linkLag);
				pcDependencyMapList.add(pcDependencyMap);
			}
		} else {

			ListIterator dependencyItr = dependencyMapList.listIterator();

			while (dependencyItr.hasNext()) {
				Map dependencyMap = (Map) dependencyItr.next();
				String preUID = (String) dependencyMap.get("preUID");
				String taskUID = (String) dependencyMap.get("taskUID");
				String pcPreType = (String) dependencyMap.get("pcPreType");
				String linkLag = (String) dependencyMap.get("linkLag");

				// get the dependency taskId from the map
				String preTaskId = (String) taskIndexMap.get(preUID);
				String taskId = (String) taskIndexMap.get(taskUID);
				if (pcPreType.equals("SF"))
					SFDependentTaskList.add(taskId);

				// store the map back in terms of pc taskId and predIds
				Map pcDependencyMap = new HashMap();
				pcDependencyMap.put("preId", preTaskId);
				pcDependencyMap.put("taskId", taskId);
				pcDependencyMap.put("pcPreType", pcPreType);
				pcDependencyMap.put("linkLag", linkLag);
				pcDependencyMapList.add(pcDependencyMap);
			}
		}

		if (debug)
			System.out.println("================ END convertDependency ================");
		return pcDependencyMapList;
	}

	/**
	 * The values contained in the dependency maplist is MS Project uids these
	 * uids change with each operation This function converts the uid into PC
	 * taskIds
	 *
	 * @param context the user context object for the current session.
	 * @throws FrameworkException if operation fails.
	 * @since AEF 10.0.0.0
	 * @grade 0
	 */
	private String getPersonLastNameFirstName(Context context, String userName) throws FrameworkException {

		// get the last name " " first name for the owner
		Set userList = new HashSet();
		userList.add(userName);

		StringList personSelect = new StringList();
		String ownerLFName = null;
		personSelect.add(person.SELECT_FIRST_NAME);
		personSelect.add(person.SELECT_LAST_NAME);
		Map ownerInfo = person.getPersonsFromNames(context, userList, personSelect);
		Map ownerMap = (Map) ownerInfo.get(userName);

		if (ownerMap != null) {
			ownerLFName = ownerMap.get(person.SELECT_LAST_NAME) + " " + ownerMap.get(person.SELECT_FIRST_NAME);
		}
		return ownerLFName;
	}

	/**
	 * This method will build the list of all - start date, end date and duration for modification.
	 * @param tasks Map of tasks
	 * @param taskId the bus-id of the task
	 * @param attribute the attribute to be modified
	 * @param value attribute value to be modified
	 */
	static public void addUpdate(Map tasks, String taskId, String attribute, Object value)
	{
		Map taskInfo = (Map) tasks.get(taskId);		

		if(taskInfo == null)
		{
			taskInfo = (Map) new HashMap();
			tasks.put(taskId, taskInfo);
		}

		taskInfo.put(attribute, value);
	}

	/**
	 * This method retrieves allocation percentage of the assigned resource from Program Central for modification.
	 * @param taskId : task id on which resource is present
	 * @param personName: name of the resource present on a task
	 */
	public String getAllocationPercent(Context context, String taskId, String personName) throws Exception {

		if (debug)
			System.out.println("================ START getAllocationPercent ================");

		String allo = null;

		StringList relationshipSelects = new StringList();
		String ATTRIBUTE_PERCENT_ALLOCATION = (String)PropertyUtil.getSchemaProperty(context,"attribute_PercentAllocation");
		String SELECT_ATTRIBUTE_PERCENT_ALLOCATION = "attribute["+ATTRIBUTE_PERCENT_ALLOCATION+"]";
		relationshipSelects.add(SELECT_ATTRIBUTE_PERCENT_ALLOCATION);

		String sWhere = "name==" + "'" + personName + "'";

		task.setId(taskId);		
		MapList mapList =  task.getRelatedObjects(context,
				ProgramCentralConstants.RELATIONSHIP_ASSIGNED_TASKS,
				DomainConstants.TYPE_PERSON,
				null,
				relationshipSelects,
				true,				// getTo
				false,				// getFrom
				(short)1,			// recurseToLevel
				sWhere,				// objectWhere
				"",					// relationshipWhere
				0);					//limit
		allo = (String)((Map)mapList.get(0)).get(SELECT_ATTRIBUTE_PERCENT_ALLOCATION);

		if (debug)
			System.out.println("================ END getAllocationPercent ================");
		return allo;
	}

	/**
	 * Sets the attribute values for resource allocation
	 *
	 * @param context the user context object for the current session.
	 * @param taskId the taskId for the task
	 * @param value the value to be set in the attribute
	 * @throws FrameworkException if operation fails.
	 * @since AEF 10.0.0.0
	 * @grade 0
	 */
	private void setValues(Context context, String taskId, String personId, String value, StringList busSelects) throws MatrixException {

		if (debug) {
			System.out.println("[setValues] taskId :" + taskId);
			System.out.println("[setValues] personId :" + personId);
			System.out.println("[setValues] allocation value :" + value);
		}

		task.setId(taskId);

		// Convert the percent value to float
		Float s = new Float((1.0 * 100) * (Double.valueOf(value)).doubleValue());
		value = s.toString();

		Map assigneeMap = (Map)task.getInfo(context, busSelects);
		Object taskAssigneeID = assigneeMap.get(SELECT_TASK_ASSIGNEE_ID);	  

		if(taskAssigneeID != null) {
			StringList taskAssigneeIDs = new StringList();
			StringList taskAssigneeIDConn = new StringList();

			if(taskAssigneeID instanceof StringList) {
				taskAssigneeIDs.addAll((StringList)assigneeMap.get(SELECT_TASK_ASSIGNEE_ID));
				taskAssigneeIDConn.addAll((StringList)assigneeMap.get(SELECT_RELATIONSHIP_CONNECTION_ID));
			}
			for (int iAssignee = 0; iAssignee < taskAssigneeIDs.size(); iAssignee++)
			{
				String idConn =(String)taskAssigneeIDConn.get(iAssignee);
				String id = (String) taskAssigneeIDs.get(iAssignee);
				try
				{
					DomainRelationship dr = new DomainRelationship(idConn);
					if (id.equalsIgnoreCase(personId))
					{
						/*if(debug)
						{
							System.out.println("In if - the assigneeName :" + id + " and currentUserName :" + personId);
							System.out.println("In if - allocation value :" + value);
						}*/
						dr.setAttributeValue(context, ProgramCentralConstants.ATTRIBUTE_PERCENT_ALLOCATION, value);
					}
				}
				catch (Exception e)
				{
					throw new MatrixException(codeRegn + " " + e.getMessage());
				}
			}
		}
	}

	private boolean mspiCreateProject(Context context, ProjectSpace project, String projectType, String projectName,
			String vault) throws Exception {

		if (debug)
			System.out.println("================ START mspiCreateProject ================");
		boolean retVal = true;
		if (projectType == null || projectType.length() == 0) {
			// In 2011x PRG's Default Project Policy is "Project Space Hold Cancel". However in MS Project there is no support for "Project
			// Space Hold Cancel", therefore String projectPolicy is replaced by DomainConstants.TYPE_PROJECT_SPACE

			// String projectPolicy = project.getDefaultPolicy(context,DomainConstants.TYPE_PROJECT_SPACE);
			// project.create(context,DomainConstants.TYPE_PROJECT_SPACE, projectName, projectPolicy, vault);

			project.create(context, DomainConstants.TYPE_PROJECT_SPACE, projectName, DomainConstants.TYPE_PROJECT_SPACE, vault);
		} 
		else {
			boolean doesProjectTypeExist = slProjectSpaceSubTypes.contains(projectType);

			if (doesProjectTypeExist) {
				//&& isDerivedType(context, DomainConstants.TYPE_PROJECT_SPACE, projectType) == true) {
				// String projectPolicy = project.getDefaultPolicy(context,projectType);
				// project.create(context, projectType, projectName, projectPolicy, vault);
				project.create(context, projectType, projectName, DomainConstants.TYPE_PROJECT_SPACE, vault);
			}
			else {
				project.create(context, DomainConstants.TYPE_PROJECT_SPACE, projectName, DomainConstants.TYPE_PROJECT_SPACE, vault);
			}
		}

		// To set currency to project as per user's set currency
		String sPreferredCurrency = PersonUtil.getCurrency(context);

		if (sPreferredCurrency != null) {
			if (sPreferredCurrency.equals("") || sPreferredCurrency.equals("As Entered") || sPreferredCurrency.equals("Unassigned"))
				project.setAttributeValue(context, ATTRIBUTE_CURRENCY, "Dollar");
			else
				project.setAttributeValue(context, ATTRIBUTE_CURRENCY, sPreferredCurrency);
		}

		if (debug)
			System.out.println("================ END mspiCreateProject ================");
		return retVal;
	}

	// new task creation in new project structure
	private boolean mspiCreateTask(Context context, Task task, String taskType, String taskName, Object obj,
			boolean isProject) throws Exception {
		
		if (debug)
			ifTaskCreate = System.currentTimeMillis();

		boolean retVal = true;

		if (taskType == null || taskType.length() == 0) {
			String taskPolicy = task.getDefaultPolicy(context, DomainConstants.TYPE_TASK);
			// Fix for [Issue ID: 92434] : Project having multilevel tasks
			// cannot be merged to PMC (New Project creation).

			if (isProject) {
				ProjectSpace project = (ProjectSpace) obj;
				task.create(context, DomainConstants.TYPE_TASK, taskName, taskPolicy, project);
			} else {
				Task pTask = (Task) obj;
				task.create(context, DomainConstants.TYPE_TASK, taskName, taskPolicy, pTask);
			}
		} else {

			boolean doesTaskTypeExist = slProjectTaskSubTypes.contains(taskType);// checkTaskTypeinDB(context, taskType);

			if (doesTaskTypeExist) {
				String taskPolicy = (String) tasktypeDefaultPolicyMap.get(taskType);// [: check in the cache]

				if (taskPolicy == null || taskPolicy.length() == 0) {
					taskPolicy = task.getDefaultPolicy(context, taskType);
					tasktypeDefaultPolicyMap.put(taskType, taskPolicy);// [:cache default task policy,avoid repeated call to task.getDefaultPolicy()]
				}

				if (isProject) {
					ProjectSpace project = (ProjectSpace) obj;
					task.create(context, taskType, taskName, taskPolicy, project);
				} else {
					Task pTask = (Task) obj;
					task.create(context, taskType, taskName, taskPolicy, pTask);
				}
			} else {

				String taskPolicy = task.getDefaultPolicy(context, DomainConstants.TYPE_TASK);

				if (isProject) {
					ProjectSpace project = (ProjectSpace) obj;
					task.create(context, DomainConstants.TYPE_TASK, taskName, taskPolicy, project);
				} else {
					Task pTask = (Task) obj;
					task.create(context, DomainConstants.TYPE_TASK, taskName, taskPolicy, pTask);
				}
			}
		}
		if (debug) {
			ifTaskCreated = System.currentTimeMillis();
			float timeToCreate = (float) (ifTaskCreated - ifTaskCreate) / 1000;
			System.out.println("Total Time to create task (in secs): " + taskName + " is " + timeToCreate);
		}
		return retVal;
	}

	// new task creation in existing project structure
	private boolean mspiCreateTask(Context context, Task task, String taskType, String taskName, Object obj,
			boolean isProject, String nextTaskId) throws Exception {

		if (nextTaskId != null && nextTaskId.equals("")) {
			nextTaskId = null;
		}
		if (debug)
			ifTaskCreate = System.currentTimeMillis();

		boolean retVal = true;
		if (taskType == null || taskType.length() == 0) {
			//String taskPolicy = task.getDefaultPolicy(context, DomainConstants.TYPE_TASK);
			String taskPolicy = (String) tasktypeDefaultPolicyMap.get(DomainConstants.TYPE_TASK);

			// Fix for [Issue ID: 92434] : Project having multilevel tasks cannot be merged to PMC (New Project creation).
			if (isProject) {
				ProjectSpace project = (ProjectSpace) obj;
				task.create(context, DomainConstants.TYPE_TASK, taskName, taskPolicy, project, nextTaskId);
			} else {
				Task pTask = (Task) obj;
				task.create(context, DomainConstants.TYPE_TASK, taskName, taskPolicy, pTask, nextTaskId);
			}
		} else {
			boolean doesTaskTypeExist = slProjectTaskSubTypes.contains(taskType);// checkTaskTypeinDB(context, taskType);

			if (doesTaskTypeExist) {
				String taskPolicy = (String) tasktypeDefaultPolicyMap.get(taskType);// [: check in the cache]

				if (taskPolicy == null || taskPolicy.length() == 0) {
					taskPolicy = task.getDefaultPolicy(context, taskType);
					tasktypeDefaultPolicyMap.put(taskType, taskPolicy);// [:cache default task policy, avoid repeated call to task.getDefaultPolicy()]
				}

				if (isProject) {
					ProjectSpace project = (ProjectSpace) obj;
					task.create(context, taskType, taskName, taskPolicy, project, nextTaskId);
				} else {

					Task pTask = (Task) obj;
					task.create(context, taskType, taskName, taskPolicy, pTask, nextTaskId);
				}
			} else {
				String taskPolicy = (String) tasktypeDefaultPolicyMap.get(DomainConstants.TYPE_TASK);
				if (isProject) {
					ProjectSpace project = (ProjectSpace) obj;
					task.create(context, DomainConstants.TYPE_TASK, taskName, taskPolicy, project, nextTaskId);
				} else {
					Task pTask = (Task) obj;
					task.create(context, DomainConstants.TYPE_TASK, taskName, taskPolicy, pTask, nextTaskId);
				}
			}
		}
		if (debug) {
			ifTaskCreated = System.currentTimeMillis();
			float timeToCreate = (float) (ifTaskCreated - ifTaskCreate) / 1000;
			System.out.println("Total time to create task in secs: " + taskName + " is " + timeToCreate);
		}
		return retVal;
	}

	// 374646 Begin
	String getNextTaskId(String outlineNumber, Map NextOutlineMap, Map TaskLevelMap, Map TaskLevelMapOld, Map OIDMap, Map OIDMapOld) {

		String NextOutlineNo = (String) NextOutlineMap.get(outlineNumber);
		String nextTaskId = null;
		String nextLevelId;
		String levelId = null;
		String level = null;
		String p1 = null;
		String p2 = null;

		if (outlineNumber.lastIndexOf(".") > 0)
			levelId = outlineNumber.substring(0, outlineNumber.lastIndexOf("."));

		while (NextOutlineNo != null) {
			boolean sibs = false;
			if (NextOutlineNo.lastIndexOf(".") == -1 && outlineNumber.lastIndexOf(".") == -1) {
				sibs = true;
			}

			else if (NextOutlineNo.lastIndexOf(".") != -1 && outlineNumber.lastIndexOf(".") != -1) {

				nextLevelId = NextOutlineNo.substring(0, NextOutlineNo.lastIndexOf("."));
				if (nextLevelId.equals(levelId))
					sibs = true;
			}
			if (sibs) {
				nextTaskId = (String) TaskLevelMap.get(NextOutlineNo);

				if (nextTaskId == null || nextTaskId.trim() == "") {
					NextOutlineNo = (String) NextOutlineMap.get(NextOutlineNo);
				} else {
					String OL = (String) OIDMap.get(nextTaskId);
					String OLOld = (String) OIDMapOld.get(nextTaskId);
					if (OL != null && OLOld != null) {

						if (OLOld.equals(OL)) {

							if (OL.indexOf(".") != -1) {
								level = OL.substring(0, OL.lastIndexOf("."));
								p1 = (String) TaskLevelMap.get(level);
								p2 = (String) TaskLevelMapOld.get(level);
								if (p1 == null || p2 == null || p1.equals(p2))
									break;
								else
									NextOutlineNo = (String) NextOutlineMap.get(NextOutlineNo);
							} else {
								break;
							}
						} else {
							NextOutlineNo = (String) NextOutlineMap.get(NextOutlineNo);
						}
					} else
						NextOutlineNo = (String) NextOutlineMap.get(NextOutlineNo);
				}
			} else {
				NextOutlineNo = (String) NextOutlineMap.get(NextOutlineNo);
			}
		}

		if (NextOutlineNo == null || NextOutlineNo.equals("")) {
			nextTaskId = null;
		}
		return nextTaskId;
	}
	// 374646 end
	
	public MapList getAllUserProjects(Context context, String[] args) throws Exception
	{
		String busWhere = "type!=" + "'" + ProgramCentralConstants.TYPE_PROJECT_SNAPSHOT + "'";
		Person person = Person.getPerson(context);
		Pattern typePattern = new Pattern(TYPE_PROJECT_SPACE);
		StringList busSelects = new StringList(1);
		busSelects.add(SELECT_ID);
		MapList projectUserList = getProjects(context, person, typePattern.getPattern(), busSelects, null, busWhere, "", true); //showSubTypes = true

		return projectUserList;
	}
}

