#########################################################################*2013
#
# @progdoc      emxSpinnerAgent.tcl vMV6R2013
#
# @Description: Dynamic scripter for schema using tab-delimited text files.
#               Functionality includes add, modify, delete w/registrations.
#
# @Parameters:  Arg 1: Settings File (optional); Arg 2: Spinner Directory (optional)
#
# @Usage:       Run this program in an MQL command window w/data files in directories:
#
#               exec prog emxSpinnerAgent.tcl [Settings File] [Spinner Directory]
#
#               . (current dir)         Spinner directory
#               ./Business              Business data files
#               ./Business/Policy       Policy access data files
#               ./Business/Rule         Rule access data files
#               ./Business/SourceFiles  Database program files
#               ./Business/PageFiles    Database page files
#               ./Export/[SCHEMA TYPE]  Export files from Bus Doc Generator program
#               ./Objects               Business Object data files
#               ./Objects/Files         Business Object Files data files
#               ./Objects/Grants        Business Object Grants data files
#               ./Pix                   Icon files for thick client
#               ./Relationships         Relationship data files
#               ./System                System data files
#
# @progdoc      Copyright (c) ENOVIA Inc., June 26, 2002
#
#########################################################################
#
# @Modifications: See SchemaAgent_ReadMe.htm
#
#########################################################################
tcl;
mql verb off
eval {
   if {[info host] == "l1509dsc" } {
      source "c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl"
      set cmd "debugger_eval"
      set xxx [debugger_init]
   } else {
      set cmd "eval"
   }
}
$cmd {
# Read arguments
   set sSpinnerPath [mql get env 1]
   set sArg1 [string tolower $sSpinnerPath]
   set sSpinnerSetting [mql get env 2]
   set sArg2 [string tolower $sSpinnerSetting]
   set sArg3 [string tolower [mql get env 3]]
   set bScan FALSE
   set bReset FALSE
   if {$sArg3 == "scan"} {
      set bScan TRUE
   } elseif {$sArg3 == "reset" || $sArg3 == "force"} {
      set bReset TRUE
   } elseif {$sArg2 == "scan"} {
      set bScan TRUE
      set sSpinnerSetting ""
   } elseif {$sArg2 == "reset" || $sArg2 == "force"} {
      set bReset TRUE
      set sSpinnerSetting ""
   } elseif {$sArg1 == "scan"} {
      set bScan TRUE
      set sSpinnerPath ""
      set sSpinnerSetting ""
   } elseif {$sArg1 == "reset" || $sArg1 == "force"} {
      set bReset TRUE
      set sSpinnerPath ""
      set sSpinnerSetting ""
   }
   if {$bScan} {mql set env SPINNERSCANMODE TRUE}
   if {$sSpinnerPath == ""} {
      set sSpinnerPath "."
   } else {
      if {[catch {cd $sSpinnerPath} sMsg] != 0} {
      	 puts "\nERROR:  Path '$sSpinnerPath' does not exist or permission denied"
      	 exit 1
      	 return
      }
   }
# Read settings
   if {$sSpinnerSetting == ""} {set sSpinnerSetting emxSpinnerSettings.tcl}
   if {[catch {
      if {[file exists "$sSpinnerPath/$sSpinnerSetting"] == 1} {
         set iFileSet [open "$sSpinnerPath/$sSpinnerSetting" r]
         eval [read $iFileSet]
         close $iFileSet
         set sSettingLoc "file '$sSpinnerPath/$sSpinnerSetting'"
      } elseif {[mql list program $sSpinnerSetting] != ""} {
         eval [mql print program $sSpinnerSetting select code dump]
         set sSettingLoc "database program '$sSpinnerSetting'"
      } else {
      	 puts "ERROR:  Spinner Settings file missing.  Load 'emxSpinnerSettings.tcl' in database or place in Spinner path"
      	 exit 1
      	 return
      }
   } sMsg] != 0} {
      puts "\nERROR: Problem with settings file '$sSpinnerSetting'\n$sMsg"
      exit 1
      return
   }
   set lsSetting [list sParentChild bUseAssignmentField bUseAccessField bRetainBusObject bImportOverwrite bBusObjOverwrite bBusRelOverwrite bTriggerAdd bTriggerMod bTriggerDel bTriggerChk sReplaceSymbolic sDelimiter sRangeDelim bShowModOnly bStreamLog bShowTransaction bOverlay bCompile lsSubDirSequence lsFileExtSkip rRefreshLog bAbbrCue iBusObjCommit bForeignVault bContinueOnError bChangeAttrType bPersonOverwrite bCDM bOut]
   set bSetErr FALSE
   foreach sSetting $lsSetting {
      if {[info exists "$sSetting"]} {
      } else {
         puts "ERROR:  Setting '$sSetting' is not defined.  Add parameter to $sSettingLoc - pull from latest 'emxSpinnerSettings.tcl' program"
         set bSetErr TRUE
      }
   }
   if {$bSetErr} {
      exit 1
      return
   }
   set bExecute TRUE
   if {[mql get env 0] == ""} {set bExecute FALSE}

# Procedure to pull extra quotes generated by Excel saves plus tagged dumper values
   proc pRegSubExcel {sExcel} {
      if {[string range $sExcel 0 0] == "\042" && [string range $sExcel end end] == "\042" && [string length $sExcel] > 2} {
      	 if {[string first "," $sExcel] > -1 || [string first "\042\042" $sExcel] > -1} {
      	    set iLast [expr [string length $sExcel] -2]
      	    set sExcel [string range $sExcel 1 $iLast]
      	    regsub -all "\042\042" $sExcel "\042" sExcel
      	 }
      }
      regsub -all "<ESC>" $sExcel "\134" sExcel
      return $sExcel
   }

# Procedure to pass tcl-type variables in tcl eval commands
   proc pRegSubEvalEscape {sEscape} {
      global sSchemaType
      if {$sSchemaType == "attribute"} {regsub -all "\134\134" $sEscape "\134\134\134" sEscape}
      regsub -all "\134$" $sEscape "\134\134\$" sEscape
      regsub -all "\134\173" $sEscape "\134\134\173" sEscape
      regsub -all "\134\175" $sEscape "\134\134\175" sEscape
      regsub -all "\134\133" $sEscape "\134\134\133" sEscape
      regsub -all "\134\135" $sEscape "\134\134\135" sEscape
      regsub -all "\042" $sEscape "\134\042" sEscape
      # Correct single quote issue in access expression for fixing 359584 - start
      if {$sSchemaType == "command" || $sSchemaType == "menu" || $sSchemaType == "channel" || $sSchemaType == "portal"} {regsub -all "'" $sEscape "\134\134\134\134\047" sEscape} else {regsub -all "'" $sEscape "\047" sEscape}
      # Correct single quote issue in access expression for fixing 359584 - end      
      return $sEscape
   }

# Procedure to convert coded filenames to ENOVIA names
   proc pRemSpecChar {filename} {
      set lChar [list {\134 %5C} {/ %2F} {: %3A} {\* %2A} {\? %3F} {\| %7C}]
      foreach i $lChar {
         set sLabel [lindex $i 1]
         set sValue [lindex $i 0]
         regsub -all -- "$sLabel" $filename "$sValue" filename
         regsub -all "\134\134" $filename "\134\134\134" filename
      }
      return $filename
   }

# Procedure to skip blanks if bOverlay switch is set
   proc pOverlay {lsNumber} {
      global aCol aDat bAdd lsMasterSignatureList 
	   
      foreach sNumber $lsNumber {
        if {$aCol($sNumber) == "<NULL>"} {
           set aCol($sNumber) ""
        } elseif {$bAdd != "TRUE" && $aCol($sNumber) == ""} {
           set aCol($sNumber) $aDat($sNumber)
      	} elseif {$bAdd == "TRUE"} {
      	   set aDat($sNumber) ""
      	}
      }
   }

# Procedure to skip blanks if bOverlay switch is set
   proc pOverlayList {lsPlan lsActual} {
      global lsDel
      if {$lsPlan == "<NULL>"} {
         return ""
      } elseif {$lsPlan == "" || $lsPlan == $lsActual} {
    	   return $lsActual
      } else {
      	 set lsPlan [lindex [pMergeList $lsPlan "" $lsActual "" ""] 0]
         return $lsPlan
      }
   }

# Procedure to merge plan and actual lists for bOverlay switch
   proc pMergeList {lsPlan lsValue lsActual lsTrueValue sType} {
      global lsDel lsPlanTemp lsValueTemp
      pSetValue [list lsDel lsPlanTemp lsValueTemp] ""
      foreach sPlan $lsPlan sValue $lsValue {
         set iLenMinTwo [expr [string length $sPlan] -2]
         if {$sType == "ATTR" && [string first "<>" $sPlan] >= 0} {
            lappend lsDel "[string range $sPlan 0 [string first "^" $sPlan]]"
         } elseif {$sType == "ATTR" && [string first "<<" $sPlan] >= 0 && [string first ">>" $sPlan] == $iLenMinTwo} {
            set iRange [string first "<<" $sPlan]
            set sPrePlan [string range $sPlan 0 [expr $iRange - 1]]
            set sPlan [string range $sPlan $iRange end]
            regsub "<<" $sPlan "" sPlan
            regsub ">>" $sPlan "" sPlan
            set sPlan [string trim $sPlan]
            regsub -all "<SPACE>" $sPlan " " sPlan 
            set sPlan "$sPrePlan$sPlan"
            if {[lsearch $lsActual $sPlan] >= 0} {lappend lsDel $sPlan}
         } elseif {[string first "<<" $sPlan] == 0 && [string range $sPlan $iLenMinTwo end] == ">>"} {
            set sPlan [string range $sPlan 2 [expr $iLenMinTwo - 1]]
            set sPlan [string trim $sPlan]
            regsub -all "<SPACE>" $sPlan " " sPlan 
            if {[lsearch $lsActual $sPlan] >= 0} {lappend lsDel $sPlan}
         } else {
            regsub -all "<SPACE>" $sPlan " " sPlan 
            lappend lsPlanTemp $sPlan
            regsub -all "<SPACE>" $sValue " " sValue 
            lappend lsValueTemp $sValue
         }
      }
      set lsPlan ""
      set lsValue ""
      set iCtrTemp 0
      foreach sActual $lsActual sTrueValue $lsTrueValue {
         if {$lsDel != "" && [lsearch $lsDel $sActual] >= 0} {
         } else {
            set iPlace [lsearch $lsPlanTemp $sActual] 
            if {$sType == "STATE" && $sTrueValue != ""} {
               set iPlaceSt [lsearch $lsValueTemp $sTrueValue]
               if {$iPlaceSt >= 0} {set iPlace $iPlaceSt}
            }
            if {$iPlace >= 0} {
               for {} {$iCtrTemp <= $iPlace} {incr iCtrTemp} {
                  lappend lsPlan [lindex $lsPlanTemp $iCtrTemp]
                  lappend lsValue [lindex $lsValueTemp $iCtrTemp]
               }
            } else {
               lappend lsPlan $sActual
               lappend lsValue $sTrueValue
            }
         } 
      }
      for {} {$iCtrTemp < [llength $lsPlanTemp]} {incr iCtrTemp} {
         lappend lsPlan [lindex $lsPlanTemp $iCtrTemp]
         lappend lsValue [lindex $lsValueTemp $iCtrTemp]
      }
      return [list $lsPlan $lsValue]
   }

# Procedure to check and set attribute values
   proc pCompareAttr {sAttrCurrent sAttrDefault sAttrAlternate bTrueFalse bCol} {
      global bOverlay bAdd
      if {$bCol && $bAdd != "TRUE" && $bOverlay && $sAttrCurrent == ""} {
         return ""
      } elseif {[string tolower $sAttrCurrent] != $sAttrAlternate && [string tolower $sAttrCurrent] != $bTrueFalse} {
         return $sAttrDefault
      } else {
         return $sAttrAlternate
      }
   }

# Procedure to query policy and rule access
   proc pQueryAccess {sSchemaType sSchemaName sSelect} {
      set lsAccessActual ""
      set lsAccessActualTemp [split [pQuery "" "print $sSchemaType \042$sSchemaName\042 select $sSelect"] \n]
      foreach sAccessTemp $lsAccessActualTemp {
         set sAccessTemp [string trim $sAccessTemp]
         if {[string first "access\133" $sAccessTemp] > -1} {
            regsub "access\134\133" $sAccessTemp "|" sAccessTemp
            set sAccessTemp [lindex [split $sAccessTemp |] 1]
            regsub "\134\135" $sAccessTemp "" sAccessTemp
            lappend lsAccessActual $sAccessTemp
         }
      }
      return $lsAccessActual
   }

# Procedure to add range values
   proc pPlanAdd {lsPlan sSchemaType sSchemaName sActionAdd sActionPost} {
      global sSystem aCmdMenuPlan
      set sAppend ""
      set iOrder 1
      foreach sPlan $lsPlan {
      	 if {$sSchemaType == "menu"} {set sActionAdd "add $aCmdMenuPlan($sPlan)"}
      	 if {$sSchemaType == "form" && $sActionAdd == "field bus dummy name"} {
      	    set sActionPost "order $iOrder"
      	    incr iOrder
      	 }
         append sAppend " $sActionAdd \042$sPlan\042 $sActionPost"
      }
      if {$sAppend != ""} {pMqlCmd "mod $sSchemaType \042$sSchemaName\042 $sSystem$sAppend"}
   }

# Procedure to add and remove list elements
   proc pPlanActualAddDel {lsActual lsActualForPlan lsPlan sSchemaType sMidCommand sSchemaName sActionDel sActionAdd sActionAppend} {
      global sSystem aCmdMenuPlan aCmdMenuActual
      if {$lsActualForPlan == ""} {set lsActualForPlan $lsActual}
      set sAppend ""
      foreach sPlan $lsPlan sActual $lsActual {
         if {$sActual != "" && [lsearch $lsPlan $sActual] < 0} {
            if {$sSchemaType == "menu"} {set sActionDel	"remove $aCmdMenuActual($sActual)"}
            append sAppend " $sActionDel \042$sActual\042"
         }
         if {$sPlan != "" && [lsearch $lsActualForPlan $sPlan] < 0} {
            if {$sSchemaType == "menu"} {set sActionAdd "add $aCmdMenuPlan($sPlan)"}
            append sAppend " $sActionAdd \042$sPlan\042$sActionAppend"
            if {$sSchemaType == "type" && $sActionAdd == "add method"} {pDeleteMethod $sSchemaName $sPlan}
         }
      }
      if {$sAppend != ""} {pMqlCmd "mod $sSchemaType $sMidCommand \042$sSchemaName\042 $sSystem$sAppend"}
   }

# Procedure to evaluate queries
   proc pQuery {sDefault sCmd} {
      if {[catch {set sQuery [eval "mql $sCmd"]} sMsg] != 0} {
         return $sDefault
      } else {
         return $sQuery
      }
   }

# Procedure to evaluate queries
   proc pPrintQuery {sDefault sSelect sPipe sSplStr} {
      global sSystem aSchemaElement sSchemaType aCol
      if {[catch {set sQuery [eval "mql print $aSchemaElement($sSchemaType) \042$aCol(0)\042 $sSystem select \042$sSelect\042 dump $sPipe"]} sMsg] != 0} {
         return $sDefault
      } else {
         if {$sSplStr == "str"} {
            set sQuery [string tolower $sQuery]
         } elseif {$sSplStr == "spl"} {
            set sQuery [split $sQuery $sPipe]
         }
         return $sQuery
      }
   }

# Procedure to set values
   proc pSetValue {lsList sValue} {
      foreach sList $lsList {
      	 set iTest [expr [string first "(" $sList] - 1]
      	 if {$iTest > 0} {
      	    eval "global \042[string range $sList 0 $iTest]\042"
      	 } else {
            eval "global \042$sList\042"
         }
         eval "set \042$sList\042 \042$sValue\042"
      }
   }

# Procedure to set action
   proc pSetAction {sActionValue} {
      global sAction bScan bAppend
      if {$bScan != "TRUE"} {
         set sAction $sActionValue
         set bAppend TRUE
      } else {
         set sAction ""
         set bAppend FALSE
      }
   }

# Procedure to trim list ranges
   proc pTrimList {sList} {
      global sRangeDelim bOverlay
      set lsList [split $sList $sRangeDelim]
      set lsListPlan [list ]
      foreach sList $lsList {
         set sList [string trim $sList]
         if {!$bOverlay} {regsub -all "<SPACE>" $sList " " sList}
         lappend lsListPlan $sList
      }
      return $lsListPlan
   }

# Procedure check for name changes on upstream changes
   proc pCheckNameChange {lsList sSchemaElement} {
      global sSchemaType aCol aSchChgName aRepeatChange
      foreach sList $lsList {
	     set sElement "$sSchemaElement|$sList"
         if {[catch {set sTest $aSchChgName($sElement)} sMsg] == 0} {
      	    if {[catch {set sTest1 $aRepeatChange($sElement)} sMsg] != 0} {
               set aRepeatChange($sElement) TRUE
               pWriteWarningMsg "\nWARNING: '$sSchemaType' '$aCol(0)' references '$sSchemaElement' '$sList' with new name '$sTest'.\nChange this reference in the '$sSchemaType' data file to avoid errors on subsequent runs."
            }
            set iIndex [lsearch $lsList $sList ]
            set lsList [lreplace $lsList $iIndex $iIndex $sTest]
         }
      }
      return $lsList
   }

# Procedure to check for multiple entries and duplicate registrations
proc pDuplicate {lsFile} {
   global sSchemaType
   set lsErrorMsg [list ]
   set lsCol1 [list ]
   set lsCol2 [list ]

      ######## Added By SL Team for Policy issue (Policy having branches is screwed up with User Agent being populated etc in Signature approver fields)####### 
   if {$sSchemaType == "state" || $sSchemaType == "signature"} {
   set iReturn [pAnalyzeDataSignature]
  }
   #################################
   foreach sLine $lsFile {
     if {$sLine != "" && [string range $sLine 0 7] != "<HEADER>"} {
         set lsLine [split $sLine \t]
         for {set i 1} {$i < 7} {incr i} {set sCol($i) [string trim [lindex $lsLine [expr $i - 1]]]}
         switch $sSchemaType {
            signature {
               set sCol123 "$sCol(1)|$sCol(2)|$sCol(3)"
               if {[lsearch $lsCol1 $sCol123] > -1} {
                  lappend lsErrorMsg "ERROR: Schema element \042$sSchemaType\042 name \042$sCol(1)\042 state \042$sCol(2)\042 signature \042$sCol(3)\042 is duplicated"
               } else {
                  lappend lsCol1 $sCol123
               }
            } state - column - unit {
               set sCol12 "$sCol(1)|$sCol(2)"
               if {[lsearch $lsCol1 $sCol12] > -1} {
                  set sName2 $sSchemaType
                  lappend lsErrorMsg "ERROR: Schema element \042$sSchemaType\042 name \042$sCol(1)\042 $sName2 \042$sCol(2)\042 is duplicated"
               } else {
                  lappend lsCol1 $sCol12
               }
            } trigger {
               set sCol12345 "$sCol(1)|$sCol(2)|$sCol(3)|$sCol(4)|$sCol(5)"
               if {[lsearch $lsCol1 $sCol12345] > -1} {
                  if {$sCol(1) == "policy"} {
                     lappend lsErrorMsg "ERROR: \042$sSchemaType\042 for schema type \042$sCol(1)\042 name \042$sCol(2)\042 state \042$sCol(3)\042 trigger type \042$sCol(4)$sCol(5)\042 is duplicated"
                  } else {
                     lappend lsErrorMsg "ERROR: \042$sSchemaType\042 for schema type \042$sCol(1)\042 name \042$sCol(2)\042 trigger type \042$sCol(4)$sCol(5)\042 is duplicated"
                  }
               } else {
                  lappend lsCol1 $sCol12345
               }
            } property {
               set sCol12356 "$sCol(1)|$sCol(2)|$sCol(3)|$sCol(5)|$sCol(6)"
               if {[lsearch $lsCol1 $sCol12356] > -1} {
                  lappend lsErrorMsg "ERROR: Property name \042$sCol(3)\ on schema element \042$sCol(1)\042 name \042$sCol(2)\042 is duplicated"
               } else {
                  lappend lsCol1 $sCol12356
               }
            } default {
               if {$sSchemaType != "field"} {
                  if {[lsearch $lsCol1 $sCol(1)] > -1} {
                     lappend lsErrorMsg "ERROR: Schema element \042$sSchemaType\042 name \042$sCol(1)\042 is duplicated"
                  } elseif {$sCol(2) != "" && $sCol(2) != "<NULL>" && [lsearch $lsCol2 $sCol(2)] > -1} {
                     lappend lsErrorMsg "ERROR: Schema element \042$sSchemaType $sCol(1)\042 registry name \042$sCol(2)\042 is duplicated"
                  } else {
                     lappend lsCol1 $sCol(1)
                     if {$sCol(2) != "" && $sCol(2) != "<NULL>"} {
                        lappend lsCol2 $sCol(2)
                     }
                  }
               }
            }
         }
      }
   }
   return $lsErrorMsg
}

# Procedure to return timestamps from file pattern
   proc pTimeStamp {sPattern} {
      global lsFileExtSkip
      set lsMatch [glob -nocomplain $sPattern]
      set lsStamp ""
      foreach sMatch $lsMatch {
         if {[lsearch $lsFileExtSkip [file ext $sMatch]] < 0} {lappend lsStamp "[file tail $sMatch]:[file mtime $sMatch]"}
      }
      set sStamp [join [lsort $lsStamp] >]
      if {$sStamp == ""} {set sStamp 0}
      return $sStamp
   }
   
# Procedure to process mql commands
   proc pMqlCmd {sCmd} {
      global bUpdate bScan
      pAppend "mql $sCmd" FALSE
      if {$bScan != "TRUE"} {eval "mql $sCmd"}
      set bUpdate TRUE
   }

# Procedure to write to log file
   proc pAppend {sString bNoChg} {
      global sFile sAction bAppend bModFlag bStreamLog
      if {$bNoChg} {
         if {$bStreamLog == "TRUE"} {puts "# $sAction$sString\n"}
         append sFile "# $sAction$sString\n"
         set bModFlag FALSE
      } elseif {$bAppend} {
         if {$bModFlag != "TRUE"} {append sFile "\n"}
         if {$bStreamLog == "TRUE"} {puts "# $sAction\n$sString\n"}
         append sFile "# $sAction\n$sString\n"
         set bAppend FALSE
      } else {
         if {$bStreamLog == "TRUE"} {puts "$sString\n"}
         append sFile "$sString\n"
      }
   }

# Procedure for writing Spinner log file
   proc pSpinDone {sSchemaType} {
      global sSpinDone lsSchemaTypeTitle aTimeStamp aTimeStampFile bScan sInstanceProperty bOverlay
      array set aTimeStamp [list $sSchemaType $aTimeStampFile($sSchemaType)]
      set fSpinDone [open $sSpinDone w]
      foreach sSchemaTypeTest $lsSchemaTypeTitle {
         set sSchemaTypeTest [string tolower $sSchemaTypeTest]
         puts $fSpinDone "$sSchemaTypeTest|$aTimeStamp($sSchemaTypeTest)"
         if {$sSchemaTypeTest == "program"} {
            array set aTimeStamp [list sourcefile $aTimeStampFile(sourcefile)]
            puts $fSpinDone "sourcefile|$aTimeStamp(sourcefile)"
         } elseif {$sSchemaTypeTest == "page"} {
            array set aTimeStamp [list pagefile $aTimeStampFile(pagefile)]
            puts $fSpinDone "pagefile|$aTimeStamp(pagefile)"
         }
      }
      puts $fSpinDone "overlay|$bOverlay"
      close $fSpinDone
      if {[mql print person creator select property\133$sInstanceProperty\135.name dump] == "" && $bScan != "TRUE"} {
         catch {mql add property $sInstanceProperty value [file mtime $sSpinDone] on person creator} sMsg
      } elseif {$bScan != "TRUE"} {
         catch {mql mod property $sInstanceProperty value [file mtime $sSpinDone] on person creator} sMsg
      }
   }

# Procedure to write screen cue
   proc pWriteCue {} {
      global iAddCtr iModCtr iDelCtr iErrCtr iTenPercent iPrevAddModDel iPrevError bAbbrCue
      set iAddModDel [expr $iAddCtr + $iModCtr + $iDelCtr - $iPrevAddModDel]
      set iError [expr $iErrCtr - $iPrevError]
      set iPrevAddModDel [expr $iAddCtr + $iModCtr + $iDelCtr]
      set iPrevError $iErrCtr
      set sWrite "..."
      if {$iAddModDel && $iError && $bAbbrCue != "TRUE"} {
         set sWrite "  \050$iAddModDel\: $iError\!\051"
      } elseif {$iAddModDel && $bAbbrCue != "TRUE"} {
         set sWrite "  \050$iAddModDel\:\051"
      } elseif {$iError} {
         set sWrite "  \050$iError\!\051"
      }
      puts -nonewline "$sWrite[expr $iTenPercent * 10]%"
   }

# Procedure to write error to screen and log
   proc pWriteErrorMsg {sMessage} {
      global sLogFileError
      puts $sMessage
      set iLogFileErr [open $sLogFileError a+]
      puts $iLogFileErr $sMessage
      close $iLogFileErr
   }  
      
# Procedure to write warning to screen and log
   proc pWriteWarningMsg {sMessage} {
      global sWarning sFile bOut
      if {$bOut} {puts $sMessage}
      append sWarning "$sMessage\n"
      append sFile "$sMessage\n"
   }  
      
# Main
   if {$bExecute} {
      set sFirstLine [lindex [split [mql print program emxSpinnerAgent.tcl select code dump] \n] 0]
   } elseif {[catch {
      set iSpinFile [open emxSpinnerAgent.tcl r]
      set sFirstLine [gets $iSpinFile]
      close $iSpinFile
   } sMsg] != 0} {
      puts "\nERROR: Program execution halted - Change working directory to location of 'emxSpinnerAgent.tcl'"
      exit 1
      return
   }
   set iEnd [expr [string last "*" $sFirstLine] + 1]
   set sSpinBuild [string range $sFirstLine $iEnd end]
   puts "\nStarting emxSpinnerAgent v$sSpinBuild..."
   puts "   settings loaded from $sSettingLoc"
   set sRegTest1 [mql list program emxRegUnRegSchema.tcl]
   if {$sRegTest1 == ""}  {
      puts "ERROR: Program execution halted - This database is not registered for Spinner"
      exit 1
      return
   }
   set sFirstLine [lindex [split [mql print program emxRegUnRegSchema.tcl select code dump] \n] 0]
   set iEnd [expr [string last "*" $sFirstLine] + 1]
   set rVersion [string range $sFirstLine $iEnd end]
   set rRegVersion 10.58
   if {$rVersion < $rRegVersion} {
      puts "ERROR: Registration program 'emxRegUnRegSchema.tcl' in this database needs to be upgraded to version >= $rRegVersion"
      exit 1
      return
   }
   eval  [mql print program emxRegUnRegSchema.tcl select code dump]
# Scan Mode
   if {$bScan != "TRUE"} {set bScan [mql get env SPINNERSCANMODE]}
   if {$bScan != "TRUE"} {set bScan FALSE}
   if {$bScan} {puts "***SCAN MODE ACTIVATED***"}
   if {$bOverlay} {puts "** Overlay mode activated **"}
# Set static variables
   set rTcl [info tcl]
   pSetValue [list bFirstRun bLogMsg] TRUE 
   set bMultiDir FALSE
   if {[llength $lsSubDirSequence] > 1} {set bMultiDir TRUE}
   set sMxVersion [pQuery "" "version"]

   if {[string first "V6" $sMxVersion] >= 0} {
      set rAppend ""
	  if {[string range $sMxVersion 7 7] == "x"} {set rAppend ".1"}
      set sMxVersion [string range $sMxVersion 3 6]
	  if {$rAppend != ""} {append sMxVersion $rAppend}
   } else {
      set sMxVersion [join [lrange [split $sMxVersion .] 0 1] .]
   }
# Major/Minor Check - ION - 10/1/2012
   if {[catch {
      set sTestMm [mql validate upgrade revisions]
      if {$sTestMm == "" || [string tolower $sTestMm] == "validation of upgrade complete"} {
         set bMm TRUE
	  } else {
	     set bMm FALSE
	  }
   } sMsg] != 0} {
      set bMm FALSE
   }
   set lsBusiness [list Program Group Role Association Attribute Type Relationship Interface "Format" Policy State Signature Command "Menu" Inquiry Table Column WebForm Field Portal Channel Rule Trigger Page Property Rule Expression Dimension Unit]
   set lsNonBusiness [list system policyaccess ruleaccess busobj busgrant busfile busrel person]
   set lsImport [list wizard index report form process resource prog]
   set lsSchemaTypeTitle [list System Program Prog Wizard Role Group Person Association]
   if {$sMxVersion >= 10.7} {set lsSchemaTypeTitle [concat $lsSchemaTypeTitle [list Dimension Unit]]}
   set lsSchemaTypeTitle [concat $lsSchemaTypeTitle [list Attribute Index Type Relationship "Format" Policy State Signature PolicyAccess Command Menu Inquiry Table Column]]
   if {$sMxVersion >= 9.6} {set lsSchemaTypeTitle [concat $lsSchemaTypeTitle [list WebForm Field]]}
   if {$sMxVersion >= 10.5} {set lsSchemaTypeTitle [concat $lsSchemaTypeTitle [list Channel Portal]]}
   if {$sMxVersion >= 10.6} {set lsSchemaTypeTitle [concat $lsSchemaTypeTitle [list Interface Expression]]}
   set lsSchemaTypeTitle [concat $lsSchemaTypeTitle [list Report Form Process Page Resource Rule RuleAccess Trigger Property BusObj BusGrant BusFile BusRel]]
   set lsRangeValue [list ">=" "<=" "!=" "=" "<" ">" "!smatch" "!match" smatch match between uses]
   array set aHiddenIndex [list program 9 group 7 role 7 association 4 attribute 7 type 7 relationship 5 interface 7 expression 4 format 11 policy 5 state "" signature "" command 9 menu 10 inquiry 8 table 4 column 14 webform 4 field 14 channel 10 portal 9 rule 8 trigger "" property "" policyaccess "" ruleaccess "" wizard "" prog "" person "" report "" form "" process "" page 4 resource "" busobj "" busgrant "" busfile "" busrel "" system "" index "" dimension 4 "unit" ""]
# Major/Minor Mod - ION - 10/1/2012
   if {$bMm} {
      set iPolicy 16
      set iState 15
      set iRel 24
   } else {
      set iPolicy 13
      set iState 12
      set iRel 23
   }
   if {$sMxVersion > 2010.1} {
      set iAttr 12
   } elseif {$sMxVersion > 10.8} {
      set iAttr 9
   } else {
      set iAttr 8
   }
   array set aIconIndex [list program 11 group 8 role 9 association 5 attribute $iAttr type 9 relationship $iRel interface 9 expression 5 format 12 policy $iPolicy state $iState signature 8 command 11 menu 11 inquiry 9 table 5 column 15 webform 6 field 15 channel 11 portal 10 rule 9 trigger 7 property 6 policyaccess "" ruleaccess "" wizard "" prog "" person "" report "" form "" process "" page 5 resource "" busobj "" busgrant "" busfile "" busrel "" system "" index "" dimension 5 "unit" 11]
   array set aDescIndex [list program 2 group 2 role 2 association 2 attribute 3 type 4 relationship 2 interface 4 expression 2 format 2 policy 2 state 2 signature 2 command 2 menu 2 inquiry 2 table 2 webform 2 channel 2 portal 2 rule 2 page 2 dimension 2]
   array set aSchemaElement [list system system program program group group role role association association attribute attribute type type relationship relationship interface interface expression expression format format policy policy state policy signature policy command command menu menu inquiry inquiry table table column table webform form field form portal portal channel channel rule rule trigger "" property "" policyaccess policy ruleaccess rule wizard program prog program person person report report form form process process page pageobject resource resource busobj bus busgrant bus busfile bus busrel rel index index dimension dimension "unit" dimension]
   array set aMultiColumn [list group [list 4 5] role [list 4 5] association [list ] attribute [list 5 8] type 5 relationship [list 3 7 8 13 14] interface [list 2 5 6] expression [list ] format [list ] policy [list 6] state [list 6] signature [list ] command [list 6 7 8] menu [list 6 7 8] inquiry [list 7] table [list 3] column [list 7 8 9] webform [list 3 5] field [list 7 8 9] channel [list 6 7 8] portal [list 6 7 8] rule [list ] trigger [list ] dimension [list 3] property [list ] page [list ] resource [list ] process [list ]]
   array set aDelimiter [list tab "\011" pipe "|" comma "," carot "^" tilde "~" newline "\012"]
   array set aRangeDelim [list tab "\011" pipe "|" comma "," carot "^" tilde "~" space " "]
   if {$sDelimiter == $sRangeDelim} {
      puts "Program halted: Delimiter '$sDelimiter' cannot be the same as the range delimiter!\nReset this parameter in the settings file"
      exit 1
      return
   }
   set sRangeDelim $aRangeDelim($sRangeDelim)
   set sSpinnerUser [mql print context]
   regsub " person " $sSpinnerUser "|" slsSpinnerUser
   set sSpinnerUser [lindex [split $slsSpinnerUser |] 1]
   if {[pQuery "none" "print person \042$sSpinnerUser\042 select admin dump"] != "all"} {
      puts "Program halted: Full administrative access is required to run this program"
      exit 1
      return
   }
# Cycle thru multiple directories
   foreach sSubDir $lsSubDirSequence {
      if {$sSubDir == ""} {
         set sSpinDir $sSpinnerPath
      } else {
         set sSpinDir "$sSpinnerPath/$sSubDir"
      }
      # Added this Variable to fix Incident 315943
	    set sSpinnerEnv [mql set env SPINNERPATH $sSpinDir ]
      if {[llength $lsSubDirSequence] == 1 && $sSpinDir == "."} {
      } else {
         puts "\nProcessing directory: $sSpinDir"
      }
      set sLogFileDir "$sSpinDir/logs"
      array set aTSPath [list policyaccess "$sSpinDir/Business/Policy" busobj "$sSpinDir/Objects" busgrant "$sSpinDir/Objects/Grants" busfile "$sSpinDir/Objects/Files" busrel "$sSpinDir/Relationships"]
      set sSuffix [clock format [clock seconds] -format ".%Y%m%dt%H%M"]
      set sProgStart [clock format [clock seconds] -format "%H:%M:%S"]
      if {$bScan} {set sSuffix ".SCAN"}
      pSetValue [list bAppend bModFlag bSkipElement bEscQuote] FALSE
      pSetValue [list resultappend lsSchemaTest sWarning sInstance sInstanceProperty sLogFileMsg] ""
# Set up or read main spinner log file
      set lsPrint [split [pQuery "" "print config"] \n]
      foreach sPrint $lsPrint {
         if {[string first "BOOTFILE=" $sPrint] > -1} {
            set sFirst [expr [string first "=" $sPrint] + 1]
            set sBootFile [string range $sPrint $sFirst end]
            regsub -all "\134\134" $sBootFile "/" sBootFile
            if {[catch {set iBoot [open $sBootFile r]} sMsg] == 0} {
               set sInstance [string range [gets $iBoot] 9 end]
               set sInstanceProperty $sInstance
               if {$sSubDir != "" && $sInstance != ""} {set sInstanceProperty "$sSubDir\_$sInstance"}
               break
            }
         }
      }
      if {$sInstance != ""} {set sLogFileDir "$sLogFileDir/$sInstance"}
      if {[file exists $sLogFileDir] == 0} {
         if {[catch {file mkdir $sLogFileDir} sMsg] != 0} {
            puts "Program halted: Error creating log directory\n$sMsg"
            exit 1
            return
         }
      }
      set sLogFilePath "$sLogFileDir/Spinner$sSuffix.log"
      mql set env SPINNERLOGFILE $sLogFilePath
      if {$bScan && [file exists $sLogFilePath]} {file delete $sLogFilePath}
      set sLogFileError "$sLogFileDir/SpinnerError.log"
      set iLogFileErr [open $sLogFileError w]
      close $iLogFileErr
      mql set env SPINNERERRORLOG $sLogFileError
      set sSpinDone "$sLogFileDir/SpinDone.log"
      if {$bScan != "TRUE"} {
         if {[file exists $sSpinDone] == 1} {
            if {[pQuery "0" "print person creator select property\134\133$sInstanceProperty\134\135.value dump"] != [file mtime $sSpinDone]} {
               file delete -force $sSpinDone
            } elseif {$sSpinDir == $sSpinnerPath && [expr [clock seconds] - [file mtime $sSpinDone]] > [expr $rRefreshLog * 86400]} { 
               file delete -force $sSpinDone
            } elseif {$bReset} {
               file delete -force $sSpinDone
            }
         }
         if {[file exists $sSpinDone] == 0} {
            set fSpinDone [open $sSpinDone w]
            foreach sSchemaTypeTitle $lsSchemaTypeTitle {puts $fSpinDone "[string tolower $sSchemaTypeTitle]|0"}
            puts $fSpinDone "sourcefile|0"
            puts $fSpinDone "pagefile|0"
            close $fSpinDone
         }
         set fSpinDone [open $sSpinDone r]
         while {[eof $fSpinDone] == 0} {
            set sInput [gets $fSpinDone]
            if {$sInput != ""} {
               set lsInput [split $sInput |]
               array set aTimeStamp [list [lindex $lsInput 0] [lindex $lsInput 1]]
            }
         }
         close $fSpinDone
         if {[catch {set aTimeStamp(overlay) $aTimeStamp(overlay)} sMsg] == 0} {
            if {$aTimeStamp(overlay) == "TRUE" && $bOverlay != "TRUE"} {
               puts "Program halted:  Last run was performed with the 'overlay' option activated.\nEither reset option or delete file '$sLogFileDir/SpinDone.log' to process in classic mode"
               exit 1
               return
            }
         }
      }
# Set up data files array
      set lsSchemaType ""
      set bFoundSchema FALSE
      foreach sSchemaTypeTitle $lsSchemaTypeTitle {
         set sSchemaType [string tolower $sSchemaTypeTitle]
         set lsTSFile($sSchemaType) ""
         array set aSchemaTitle [list $sSchemaType $sSchemaTypeTitle]
         if {$sSchemaType == "system"} {
            array set aTimeStampFile [list system [pTimeStamp "$sSpinDir/System/*.*"]]
         } elseif {$sSchemaType == "policyaccess"} {
            array set aTimeStampFile [list policyaccess [pTimeStamp "$sSpinDir/Business/Policy/*.*"]]
         } elseif {$sSchemaType == "ruleaccess"} {
            array set aTimeStampFile [list ruleaccess [pTimeStamp "$sSpinDir/Business/Rule/*.*"]]
         } elseif {$sSchemaType == "busobj"} {
            array set aTimeStampFile [list busobj [pTimeStamp "$sSpinDir/Objects/*.xls"]]
         } elseif {$sSchemaType == "busgrant"} {
            array set aTimeStampFile [list busgrant [pTimeStamp "$sSpinDir/Objects/Grants/*.xls"]]
         } elseif {$sSchemaType == "busfile"} {
            array set aTimeStampFile [list busfile [pTimeStamp "$sSpinDir/Objects/Files/*.xls"]]
         } elseif {$sSchemaType == "busrel"} {
            array set aTimeStampFile [list busrel [pTimeStamp "$sSpinDir/Relationships/*.xls"]]
         } elseif {[lsearch $lsImport $sSchemaType] > -1} {
            array set aTimeStampFile [list $sSchemaType [pTimeStamp "$sSpinDir/Export/$sSchemaType/*.exp"]]
         } elseif {$sSchemaType == "program"} {
            array set aTimeStampFile [list program [pTimeStamp "$sSpinDir/Business/*ProgramData*.*"]]
            array set aTimeStampFile [list sourcefile [pTimeStamp "$sSpinDir/Business/SourceFiles/*"]]
         } elseif {$sSchemaType == "page"} {
            array set aTimeStampFile [list page [pTimeStamp "$sSpinDir/Business/*PageData*.*"]]
            array set aTimeStampFile [list pagefile [pTimeStamp "$sSpinDir/Business/PageFiles/*"]]
         } else {
            array set aTimeStampFile [list $sSchemaType [pTimeStamp "$sSpinDir/Business/*$sSchemaTypeTitle\Data*.*"]]
         }
         if {[catch {
            if {$bScan || $aTimeStamp($sSchemaType) != $aTimeStampFile($sSchemaType)} {
               lappend lsSchemaType $sSchemaType
               set bFoundSchema TRUE
               switch $sSchemaType {
                  role - group {
                     if {[lsearch $lsSchemaTest policy] < 0} {lappend lsSchemaTest person}
                  } attribute {
                     set lsSchemaTest [concat $lsSchemaTest [list type relationship]]
                     if {$sMxVersion >= 10.6} {lappend lsSchemaTest interface}
                  } type {
                     if {[lsearch $lsSchemaTest relationship] < 0} {lappend lsSchemaTest relationship}
                     lappend lsSchemaTest policy
                     if {$sMxVersion >= 10.6 && [lsearch $lsSchemaTest interface] < 0} {lappend lsSchemaTest interface}
                  } format {
                     if {[lsearch $lsSchemaTest policy] < 0} {lappend lsSchemaTest policy}
                  } policy {
                     lappend lsSchemaTest state
                     lappend lsSchemaTest signature
                     lappend lsSchemaTest policyaccess
                  } state {
                     if {[lsearch $lsSchemaTest signature] < 0} {lappend lsSchemaTest signature}
                     if {[lsearch $lsSchemaTest policyaccess] < 0} {lappend lsSchemaTest policyaccess}
                  } command {
                     lappend lsSchemaTest menu
                  } table {
                     lappend lsSchemaTest column
                  } webform {
                     lappend lsSchemaTest field
                  } dimension {
                     lappend lsSchemaTest unit
                  } channel {
                     lappend lsSchemaTest portal
                  } policyaccess - busobj - busgrant - busfile - busrel {
                     if {$bScan != "TRUE"} {
                        set lsTS [split $aTimeStamp($sSchemaType) >]
                        foreach slsTS $lsTS {
                           set lslsTS [split $slsTS :]
                           array set aTS [list [lindex $lslsTS 0] [lindex $lslsTS 1]]
                        }
                        set lsTSTest ""
                        set lsTSF [split $aTimeStampFile($sSchemaType) >]
                        foreach slsTSF $lsTSF {
                           set lslsTSF [split $slsTSF :]
                           array set aTSFile [list [lindex $lslsTSF 0] [lindex $lslsTSF 1]]
                           lappend lsTSTest [lindex $lslsTSF 0]
                        }
                        foreach sTSTest $lsTSTest {
                           if {[catch {
                              if {$aTSFile($sTSTest) != $aTS($sTSTest)} {lappend lsTSFile($sSchemaType) "$aTSPath($sSchemaType)/$sTSTest"}
                           } sMsg] != 0} {
                              lappend lsTSFile($sSchemaType) "$aTSPath($sSchemaType)/$sTSTest"
                           }
                        }
                     } 
                  }
               } 
            } elseif {$sSchemaType == "program" && $aTimeStamp(sourcefile) != $aTimeStampFile(sourcefile)} {
               lappend lsSchemaType program
               set bFoundSchema TRUE
            } elseif {$sSchemaType == "page" && $aTimeStamp(pagefile) != $aTimeStampFile(pagefile)} {
               lappend lsSchemaType page
               set bFoundSchema TRUE
            } elseif {[lsearch $lsSchemaTest $sSchemaType] >= 0 && $aTimeStampFile($sSchemaType) > 0} {
               lappend lsSchemaType $sSchemaType
            }
         } sMsg] != 0} {
            file delete -force $sSpinDone
            pWriteErrorMsg "ERROR: Log file '$sSpinDone' was incompatible with this Spinner version and now deleted. Please restart this program."
            exit 1
            return
         }
      }
      if {$lsSchemaType != ""} {
# Set up arrays for symbolic name mapping
            set bAEF FALSE
            if {[mql list program "eServiceSchemaVariableMapping.tcl"] != ""} {
               puts "Building name to symbolic name mapping arrays..."
               if {$bFirstRun} {
                  set lsPrimitive [list ]
                  set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]
                  set lsPropertyTo [split [mql print program eServiceSchemaVariableMapping.tcl select property.to dump |] |]
               }
               foreach sPropertyName $lsPropertyName sPropertyTo $lsPropertyTo {
                  set sSchemaTest [lindex [split $sPropertyName "_"] 0]
                  if {$sSchemaTest == "form"} {set sSchemaTest "webform"}
                  if {[lsearch $lsPrimitive $sSchemaTest] >= 0} {continue}
                  if {[lsearch $lsSchemaType $sSchemaTest] > -1 || [lsearch $lsSchemaType "property"] > -1} {
                     if {[catch {set bTest $aSchemaTest($sSchemaTest)} sMsg] != 0} {
                        if {[catch {set bTest $aSchemaElement($sSchemaTest)} sMsg] == 0} {
                           set aSchemaTest($sSchemaTest) TRUE
                           puts -nonewline "$sSchemaTest "
                        }
                     }
                     if {$sSchemaTest == "webform"} {set sSchemaTest "form"}
                     set sTypeReplace "$sSchemaTest "
                     if {$sSchemaTest == "attribute"} {set sTypeReplace "att "}
                     regsub $sTypeReplace $sPropertyTo "" sPropertyTo
                     array set aSymbolic [list "$sSchemaTest|$sPropertyTo" $sPropertyName]
                     if {[catch {set sPropertyToTest $aSchemaName($sPropertyName)} sMsg] == 0} {
                        pWriteWarningMsg "\nWARNING: Symbolic name \042$sPropertyName\042 is being used for [join [split $sPropertyTo ,] " and "] in the schema"
                     }
                     array set aSchemaName [list $sPropertyName $sPropertyTo]
                  }
               }
               set lsPrimitive [concat $lsPrimitive $lsSchemaType]
               puts ""
               set bAEF TRUE
            }
            set bFirstRun FALSE
# Process Data Files
         set bProcess TRUE
         while {$bProcess} {
            set bProcess FALSE
            foreach sSchemaType $lsSchemaType {
               set sFile ""
               pSetValue [list iErrCtr iAddCtr iModCtr iDelCtr iSkipCtr iRegisterCounter iPrevError iPrevAddModDel iMultiCtr iAddCtrTot iModCtrTot iDelCtrTot iSkipCtrTot] 0
               set iTenPercent 1
# System, Access, Bus Object, Bus File, and Bus Rel Spinners
               if {[lsearch $lsNonBusiness $sSchemaType] >= 0} {
                  switch $sSchemaType {
                     system {
                        set sSpinnerProg "emxSpinnerSystem.tcl"
                        set sVarError SYSTEMERROR
                     } busobj {
                        set sSpinnerProg "emxSpinnerBusObjects.tcl"
                        mql set env BUSOBJMODIFEXISTS $bBusObjOverwrite
                        mql set env BUSFILELIST $lsTSFile($sSchemaType)
                        mql set env TRIGGERCREATE $bTriggerAdd
                        mql set env TRIGGERMODIFY $bTriggerMod
                        mql set env TRIGGERDELETE $bTriggerDel
                        set sVarError BUSOBJERROR
                     } busgrant {
                        set sSpinnerProg "emxSpinnerBusGrants.tcl"
                        mql set env BUSGRANTLIST $lsTSFile($sSchemaType)
                        set sVarError BUSGRANTERROR
                     } busfile {
                        set sSpinnerProg "emxSpinnerBusFiles.tcl"
                        mql set env FILELIST $lsTSFile($sSchemaType)
                        mql set env CHECKINLIST $lsTSFile($sSchemaType)
                        mql set env TRIGGERCHECKIN $bTriggerChk
                        mql set env CDMAWARE $bCDM
                        set sVarError BUSFILERROR
                     } busrel {
                        set sSpinnerProg "emxSpinnerBusRels.tcl"
                        mql set env BUSRELMODIFEXISTS $bBusRelOverwrite
                        mql set env RELFILELIST $lsTSFile($sSchemaType)
                        mql set env TRIGGERCREATE $bTriggerAdd
                        mql set env TRIGGERMODIFY $bTriggerMod
                        mql set env TRIGGERDELETE $bTriggerDel
                        set sVarError BUSRELERROR
                     } person {
                        set sSpinnerProg "emxSpinnerPerson.tcl"
                        set sVarError PERSONERROR
                        mql set env OVERLAY $bOverlay
                        mql set env PERSONMODIFEXISTS $bPersonOverwrite
                     } default {
                        set sSpinnerProg "emxSpinnerAccess.tcl"
                        mql set env SHOWMODONLY bShowModOnly
                        mql set env FILELIST $lsTSFile($sSchemaType)
                        set sVarError ACCESSERROR
                     }
                  }
                  if {($bExecute && [mql list program $sSpinnerProg] != "") || ($bExecute != "TRUE" && [file exists $sSpinnerProg])} {
                     puts -nonewline "\nProcessing $aSchemaTitle($sSchemaType) data..."
                     if {$bExecute} {
                        set sFirstLine [lindex [split [mql print program $sSpinnerProg select code dump] \n] 0]
                     } else {
                     	set iSpinProg [open "$sSpinnerProg" r]
                     	set sFirstLine [gets $iSpinProg]
                     	close $iSpinProg
                     }
                     set iEnd [expr [string last "*" $sFirstLine] + 1]
                     set rVersion [string range $sFirstLine $iEnd end]
                     mql set env ACCESSTYPE $sSchemaType
                     if {$bExecute} {
                     	mql exec prog "$sSpinnerProg"
                     } else {
                     	mql run "$sSpinnerProg"
                     }
                     set iAccessError [eval mql get env $sVarError]
                     if {$iAccessError > 0} {
                        puts "$iAccessError error(s) generated - Review log file '$sLogFileError', correct problem(s) and restart"
                        if {$bContinueOnError != "TRUE"} {
                           exit 1
                           return
                        }
                     } elseif {$bScan != "TRUE"} {
                        pSpinDone $sSchemaType
                     }
                  } elseif {$aTimeStampFile($sSchemaType) > 0} {
                     puts "\nWARNING: Program '$sSpinnerProg' not present - no $sSchemaType files run"
                  }
# Import Non-Spinner Schema
               } elseif {[lsearch $lsImport $sSchemaType] > -1} {
                  if {$bScan != "TRUE"} {
                     set bPercent FALSE
                     set lsExport [glob -nocomplain "$sSpinDir/Export/$sSchemaType/*.exp"]
                     if {[llength $lsExport] > 0} {
                        if {[llength $lsExport] > 50} {
                           set iPercent [expr [llength $lsExport] / 10]
                           set bPercent TRUE
                        }
                        set sAction ""
                        puts "\nImporting $aSchemaTitle($sSchemaType) items...\n option for 'overwrite': $bImportOverwrite"
                        foreach sExport $lsExport {
                           if {[lsearch $lsFileExtSkip [file ext $sExport]] < 0} {
                              pSetValue [list bSkipImport bUpdate] FALSE
                              pSetValue [list sT sN sR] ""
                              set sT [file root [file tail $sExport]]
                              set sT [pRemSpecChar $sT]
                              set sOut ":"
                              if {[pQuery "" "print $aSchemaElement($sSchemaType) \134\042$sT\134\042"] == ""} {set sOut "+"}
                              if {$bImportOverwrite || $sOut == "+"} {
                                 set sMqlCommand "import $aSchemaElement($sSchemaType) \134\042$sT\134\042 overwrite from file \134\042$sExport\134\042"
                              } else {
                            	    set bSkipImport TRUE
                              }
                              if {$bSkipImport != "TRUE"} {
                                 mql start transaction update
                                 if {[catch {pMqlCmd $sMqlCommand} sMsg] != 0} {
                                    pAppend "TRANSACTION NOT SUCCESSFUL! $sMsg\n" FALSE
                                    mql abort transaction
                                    incr iErrCtr
                                    if {$bPercent != "TRUE"} {puts -nonewline "!"}
                                    set iLogFileErr [open $sLogFileError a+]
                                    puts $iLogFileErr "$sMqlCommand\n$sMsg"
                                    close $iLogFileErr
                                 } else {
                                    mql commit transaction
                                    if {$bPercent != "TRUE"} {puts -nonewline "$sOut"}
                                    incr iAddCtr
                                    if {$sSchemaType == "person"} {pMqlCmd "import workspace * overwrite from file \134\042$sExport\134\042"}
                                 }
                              } else {
                                 if {$bPercent != "TRUE"} {puts -nonewline "."}
                                 incr iSkipCtr
                              }
                              if {$bPercent && $iTenPercent < 10 && [expr $iAddCtr + $iSkipCtr + $iErrCtr] > [expr $iTenPercent * $iPercent]} {
                                 pWriteCue
                                 incr iTenPercent
                              }
                           }
                        }
                        if {$bPercent} {pWriteCue}
                        if {$iErrCtr} {
                           set pFile [open $sLogFilePath a+]
                           puts $pFile $sFile
                           close $pFile
                           puts "\n$iErrCtr error(s) generated - Review '$sLogFileError', correct problem(s) and restart"
                           if {$bContinueOnError != "TRUE"} {
                              exit 1
                              return
                           }
                        } else {
                           set pFile [open "$sLogFilePath" a+]
                           puts $pFile $sFile
                           close $pFile
                           puts "\n$iAddCtr items imported, $iSkipCtr items skipped - log file: $sLogFilePath"
                        }
                      }
                      pSpinDone $sSchemaType
                  }
               } else {
# Start Business Spinner               	
                  if {[lsearch $lsBusiness $aSchemaTitle($sSchemaType)] >= 0} {
                     set sSchemaTest $aSchemaTitle($sSchemaType)
                     if {[lsearch [list Role Group] $sSchemaTest] >= 0} {set sSchemaTest "User"}
                     if {[lsearch [list Command "Menu" Channel Portal Inquiry Table Column WebForm Field] $sSchemaTest] >= 0} {set sSchemaTest "WebComp"}
                     if {[lsearch [list Dimension Unit] $sSchemaTest] >= 0} {set sSchemaTest "Dimension"}
                     set sSchemaTestProg "emxSpinner$sSchemaTest.tcl"
                     if {$sSchemaTest == "State" || $sSchemaTest == "Signature"} {set sSchemaTestProg "emxSpinnerPolicy.tcl"}
                     if {$sSchemaTest == "Association"} {set sSchemaTestProg "emxSpinnerUser.tcl"}
                     if {[info procs "pAnalyze$sSchemaTest"] == ""} {
                        if {$bExecute != "TRUE" && [file exists $sSchemaTestProg]} {
                           set iBusProg [open $sSchemaTestProg r]
                           eval [read $iBusProg]
                           close $iBusProg
                        } elseif {$bExecute && [mql list program "$sSchemaTestProg"] != ""} {
                           eval [mql print program "$sSchemaTestProg" select code dump]
                        } else {
                           if {$bExecute} {
                              puts "ERROR: Program object '$sSchemaTestProg' is missing from database"
                           } else {
                              puts "ERROR: Program '$sSchemaTestProg' is missing from directory '[pwd]'"
                           }	
                           exit 1
                           return
                        }
                     }
                  }
# Read in data
                  puts "\nReading $aSchemaTitle($sSchemaType) data..."
                  set lsDataFile [glob -nocomplain "$sSpinDir/Business/*$aSchemaTitle($sSchemaType)Data*.*"]
                  set slsDataFile ""
                  foreach sDataFile $lsDataFile {
                     if {[lsearch $lsFileExtSkip [file ext $sDataFile]] < 0} {
                        set iFile [open $sDataFile r]
                        append slsDataFile "<HEADER>[read $iFile]"
                        close $iFile
                     }
                  }
                  set lsFile [split $slsDataFile \n]
                  if {$rTcl > 8.29 && $sSchemaType != "field"} {set lsFile [lsort -unique $lsFile]}
                  if {$sSchemaType == "policy"} {
                     if {$bForeignVault} {
                     	set slsVault "*"
                     } else {
                        set lsVault ""
                        set lsTempVault [split [mql list vault] \n]
                        foreach sVault $lsTempVault {if {[mql print vault $sVault select map dump] == ""} {lappend lsVault $sVault}}
                        set slsVault [join $lsVault ,]
                     }
                  }
# Screen Spinner files
                  if {$sSchemaType == "program"} {
                     set lsTempFile [list ]
                     set lsSpinFile [list emxSpinner emxRegUnRe emxDumper_ emxSchema_ emxExtract]
                     foreach sProgFile $lsFile {
                        set sProgTest [string range [string trim $sProgFile] 0 9]
                      	if {[lsearch $lsSpinFile $sProgTest] >= 0} {
                        } else { 
                           lappend lsTempFile $sProgFile
                        }
                     }
                     set lsFile $lsTempFile
                  }
                  set lsType [list ]
                  if {($sSchemaType == "role" || $sSchemaType == "group")} {
                     puts "   option to process users in Assignment field: $bUseAssignmentField\n   option to use parent or child field is set to: $sParentChild"
                  } elseif {$sSchemaType == "policy" || $sSchemaType == "rule"} {
                     puts "   option to process users in Access field: $bUseAccessField"
# Read in JPOs
                  } elseif {$sSchemaType == "program"} {
                     #TDQ: fix for packaged jpos: in package directories, the / is necessary: it is hence removed as a special character
                     set lsSpecChar [list COLON LTHAN GTHAN PYPE]
                     array set aSpecChar [list COLON ":" LTHAN "<" GTHAN ">" PYPE "\134\174"]
                     puts "   option to compile JPO's: $bCompile"

                     #TDQ: Get files in SourceFiles directory and all subdirectories (for packaged JPOs)
                     #set lsSF [glob -nocomplain "$sSpinDir/Business/SourceFiles/*"]
                     proc findFiles { basedir pattern } {
                         set basedir [string trimright [file join [file normalize $basedir] { }]]
                         set fileList {}
                         foreach fileName [glob -nocomplain -type {f r} -path $basedir $pattern] {
                             lappend fileList $fileName
                         }
                         foreach dirName [glob -nocomplain -type {d  r} -path $basedir *] {
                             set subDirList [findFiles $dirName $pattern]
                             if { [llength $subDirList] > 0 } {
                                 foreach subDirFile $subDirList {
                                     lappend fileList $subDirFile
                                 }
                             }
                         }
                         return $fileList
                      }

                     set lsSF [findFiles "$sSpinDir/Business/SourceFiles" *]

                     foreach sSF $lsSF {
                        if {[lsearch $lsFileExtSkip [file ext $sSF]] < 0} { 
                           set iCharIndexToCut [expr [string first "SourceFiles" $sSF] + [string length "SourceFiles"] + 1]
                           set sSF [string range $sSF $iCharIndexToCut end]

                           foreach sSpecChar $lsSpecChar {
                              regsub -all "$sSpecChar" $sSF "$aSpecChar($sSpecChar)" sSF
                           }
                           if {[string first "_mxJPO" $sSF] > 0} {
                              regsub "_mxJPO(.)*.java" $sSF "_mxJPO.java" sSFTest
                              if {[string first "_mxJPO.java" $sSFTest] > 0} {
                                 regsub "_mxJPO.java" $sSFTest "" sSFTest
# IR Fix 310671
                                 if {[file root $sSFTest] == $sSFTest && [lsearch $lsFile "$sSFTest\t\*"] < 0} {
                                    lappend lsFile "$sSFTest\t\t\tjava\timmediate\tFALSE\tFALSE\tFALSE\tFALSE\tFALSE"
                                 }
                              } else {
                                 puts "WARNING: Program file '$sSpinDir/Business/SourceFiles/$sSF' will not be processed"
                              }  
                           } elseif {[string first ".tcl" $sSF] > 0 && [pQuery "" "list program \042$sSF\042"] == ""} {
                              if {[lsearch $lsFile "$sSF\*"] < 0} {lappend lsFile "$sSF\t\t\tmql\timmediate\tFALSE\tFALSE\tFALSE\tFALSE\tFALSE"}
                           } elseif {[lsearch $lsFile "$sSF\*"] < 0} {
                              puts "WARNING: Program file '$sSpinDir/Business/SourceFiles/$sSF' will not be processed"
                           }
                        }
                     }
                  }
# Check for multiple entries or duplicate registrations
                  set lsErrorMsg [pDuplicate $lsFile]
                  if {[llength $lsErrorMsg] > 0} {
                     pWriteErrorMsg [join $lsErrorMsg \n]
                     exit 1
                     return
                  }
# Process business element rows
                  puts -nonewline "Processing [expr [llength $lsFile] - 2] $aSchemaTitle($sSchemaType) rows"
                  set iCounter 1
                  set bContinue TRUE
                  set bRepeat FALSE
                  set iPrevErrCtr 0
                  if {$bScan != "TRUE"} {append sFile "# \133[clock format [clock seconds] -format %H:%M:%S]\135 $aSchemaTitle($sSchemaType)\050s\051\n"}
                  while {$bContinue} {
                     if {$bScan != "TRUE" && $iCounter != 1} {append sFile "\n# Loop $iCounter..."}
                     set iErrCtr 0
                     set bContinue FALSE
                     set lsErrorType($iCounter) ""
                     set iErrorCheck [expr $iCounter - 1]
                     pSetValue [list bMulti bPercent bModFlag] FALSE
                     if {$bRepeat} {
                     	  if {[llength $lsErrorType($iErrorCheck)] > 50} {
                           set iPercent [expr [llength $lsErrorType($iErrorCheck)] / 10]
                           set bPercent TRUE
                           set iTenPercent 1
                           pSetValue [list iErrCtr iAddCtr iModCtr iDelCtr iSkipCtr iPrevAddModDel iPrevError] 0
                        }
                     } elseif {[llength $lsFile] > 50} {
                        set iPercent [expr [llength $lsFile] / 10]
                        set bPercent TRUE
                     }
                     foreach slsType $lsFile {
                        if {$slsType != "" && [string range $slsType 0 7] != "<HEADER>"} {
                           set bSkipType FALSE
                           if {$bRepeat} {
                              regsub -all "\042" $slsType "" sTypeTest
                              regsub -all "\134\133" $sTypeTest "" sTypeTest
                              regsub -all "\134\135" $sTypeTest "" sTypeTest
                              if {[lsearch $lsErrorType($iErrorCheck) $sTypeTest] < 0} {set bSkipType TRUE}
                           }
                           if {$bSkipType != "TRUE"} {
                              set bEscQuote FALSE
                              if {[lsearch [list command menu channel portal] $sSchemaType] >= 0} {
                              	 if {[string first "<ESCQUOTE>" $slsType] > -1} {
                              	    set bEscQuote TRUE
                              	 } elseif {[regsub -all "\134\134\042" $slsType "<ESCQUOTE>" slsType]} {
                              	    set bEscQuote TRUE
                              	 }
                              }
                              set lslsType [split $slsType $aDelimiter($sDelimiter)]
                              if {$bMulti} {
                                 if {[string first $aCol(0) [lindex $lslsType 0]] < 0 || [string first "<MULTILINE." [lindex $lslsType 0]] < 0} {
                                    pWriteErrorMsg "\nERROR: Data file sequencing error for multiline schema element '$sSchemaType $aCol(0)'"
                                    exit 1
                                    return
                                 }
                                 lappend lsBufferMulti $slsType
                                 foreach sColNo $aMultiColumn($sSchemaType) {if {[string trim [lindex $lslsType $sColNo]] != ""} {append aCol($sColNo) " | [string trim [lindex $lslsType $sColNo]]"}}
                                 incr iMulti -1
                                 incr iMultiCtr
                                 if {$iMulti > 1} {continue}
                              }
                              if {$bMulti} {
                                 set bMulti FALSE
                              } else {
                                 if {$bOverlay != "TRUE"} {
                                    regsub -all "<NULL>" $lslsType "" lslsType
                                    if {[string first "<<" $lslsType] >= 0 && [string first ">>" $lslsType] >= 2} {
                                       puts "Program halted:  Data file for '$sSchemaType' contains delete tags '<<' and '>>'.\nThese may only be used in 'overlay' mode"
                                       exit 1
                                       return
                                    }
                                 }
                                 for {set i 0} {$i < [expr $aIconIndex($sSchemaType) + 1]} {incr i} {
                                    set aCol($i) [string trim [lindex $lslsType $i]]
                                    set aCol($i) [pRegSubExcel $aCol($i)]
                                    if {[string first "<SPACE>" $aCol($i)] >= 0 && [lsearch $aMultiColumn($sSchemaType) $i] < 0} {regsub -all "<SPACE>" $aCol($i) " " aCol($i)}
                                    if {$bEscQuote} {
                                       if {$i == 4} {regsub -all "\042" $aCol(4) "" aCol(4)}
                                       regsub -all "<ESCQUOTE>" $aCol($i) "\042" aCol($i)
                                    }
                                 }
                                 if {[lsearch [list access state signature property unit trigger] $sSchemaType] < 0} {
                                    set sHidden $aCol($aHiddenIndex($sSchemaType))
                                    set bAdd FALSE
                                    set sHidden [pCompareAttr $sHidden nothidden hidden true true]
                                    if {$sSchemaType == "column"} {
                                       set bHiddenActual [pQuery false "print table \042$aCol(0)\042 system select column\[$aCol(1)\].hidden dump"]
                                    } elseif {$sSchemaType == "field"} {
                                       set bHiddenActual [pQuery false "print form \042$aCol(0)\042 select field\[$aCol(1)\].hidden dump"]
                                    } elseif {$sSchemaType == "table"} {
                                       set bHiddenActual [pQuery false "print table \042$aCol(0)\042 system select hidden dump"]
                                    } else {
                                       set bHiddenActual [pQuery false "print $aSchemaElement($sSchemaType) \042$aCol(0)\042 select hidden dump"]
                                    }
                                    set sHiddenActual [pCompareAttr $bHiddenActual nothidden hidden true false]
                                    if {$sHidden == ""} {set sHidden $sHiddenActual}
                                 }
                                 set sIcon $aCol($aIconIndex($sSchemaType))
                                 set bUpdate TRUE
                                 if {[string first "<MULTILINE." $aCol(0)] > -1} {
                                    regsub "<MULTILINE." $aCol(0) "|" slsName
                                    set aCol(0) [string trim [lindex [split $slsName |] 0]]
                                    set sMulti [lindex [split [lindex [split $slsName |] 1] .] 1]
                                    regsub ">" $sMulti "" iMulti
                                    set bMulti TRUE
                                    set lsBufferMulti ""
                                    lappend lsBufferMulti $slsType
                                    incr iMultiCtr
                                    continue
                                 }
                              }
# Set Add/Modify and Other Registration Parameters
                              if {$sSchemaType == "state" || $sSchemaType == "signature" || $sSchemaType == "trigger" || $sSchemaType == "column" || $sSchemaType == "field" || $sSchemaType == "unit" || $sSchemaType == "property"} {
                                 pSetValue [list bReg bAdd bDel] FALSE
                              } else {
                                 set bDel TRUE
                                 set bDelAddAttr FALSE
                                 if {[string first "<<" $aCol(0)] == 0 && [string first ">>" $aCol(0)] == [expr [string length $aCol(0)] -2]} {
                                    set aCol(0) [string range $aCol(0) 2 [expr [string length $aCol(0)] -3]]
                                    if {$sSchemaType == "attribute" && [string first "+" $aCol(0)] == 0} {
                                       set aCol(0) [string range $aCol(0) 1 end]
                                       set bDelAddAttr TRUE
                                       set bDel FALSE
                                    }
                                 } else {
                                    for {set i 1} {$i < [expr $aIconIndex($sSchemaType)]} {incr i} {
                                       if {$aCol($i) != ""} {
                                 	        set bDel FALSE
                                 	        break
                                 	     }
                                    }
                                 }
                                 if {$bOverlay && $aCol(1) == ""} {
                                 	  set aCol(1) "<SKIP>"
                                 } elseif {$aCol(1) == "<NULL>"} {
                                 	  set aCol(1) ""
                                 }
                                 set sSymbolic ""
                                 if {$aCol(1) != "" && $aCol(1) != "<SKIP>"} {
                                    set sFormatted_Name [join [split "$aCol(1)" $sReplaceSymbolic] ""]
                                    set sSymbolic [format %s%s "$aSchemaElement($sSchemaType)\_" $sFormatted_Name]
                                 }
                                 if {$bDel != "TRUE"} {
                                    set bReg TRUE
                                 } else {
                                    pSetValue [list bReg bAdd] FALSE
                                 }
                              }
                              if {$sSchemaType == "table" || $sSchemaType == "column" || ( $sSchemaType == "property" && $aCol(0) == "table" ) } {
                                 set sColumnField "column"
                                 set sSystem "system"
                                 set lsTable [split [mql list table system] \n]
                              } else {
                                 set sColumnField "field"
                                 set sSystem ""
                                 set lsTable [list ]
                              }
                              if {$bReg} {
                                 pSetValue [list bAdd bRegister bUnRegName bUnRegSym] FALSE
                                 set sNameExists [pPrintQuery "" name "" ""]
                                 set sModName $aCol(0)
                                 if {$aCol(1) == "<SKIP>"} {
                                    if {$sNameExists == ""} {set bAdd TRUE}
                                 } else {
                                    pSetValue [list sSymbolicFromName sNameFromSymbolic] ""
                                    catch {set sSymbolicFromName $aSymbolic($aSchemaElement($sSchemaType)|$aCol(0))} sMsg
                                    if {$sSymbolic != ""} {catch {set sNameFromSymbolic $aSchemaName($sSymbolic)} sMsg}
                                 #  Not in database & no registry name specified - add
                                    if {$sNameExists == "" && $sSymbolic == ""} {
                                       set bAdd TRUE
                                 #  Not in database & orig name symbolic not in database - add & register
                                    } elseif {$sNameExists == "" && $sNameFromSymbolic == ""} {
                                       pSetValue [list bAdd bRegister] TRUE
                                 #  Not in database & real name from orig name symbolic does not match - mod (rename)
                                    } elseif {$sNameExists == "" && $sNameFromSymbolic != $aCol(0)} {
                                       set aCol(0) $sNameFromSymbolic
                                       set bRegister TRUE
                                 #  Has no symbolic reference & no registry name specified - mod
                                    } elseif {$sSymbolicFromName == "" && $sSymbolic == ""} {
                                 #  Has no symbolic reference & orig name symbolic not in database - mod & register
                                    } elseif {$sSymbolicFromName == "" && $sNameFromSymbolic == ""} {
                                       set bRegister TRUE
                                 #  Has no symbolic reference & real name from orig name symbolic does not match - mod & unregister name from symbolic then register
                                    } elseif {$sSymbolicFromName == "" && $sNameFromSymbolic != $aCol(0)} {
                                       pSetValue [list bRegister bUnRegSym] TRUE
                                 #  Has symbolic reference & no registry name specified - mod & unregister name
                                    } elseif {$sSymbolicFromName != "" && $sSymbolic == ""} {
                                       set sSymbolicTest [lindex [split $sSymbolicFromName "_"] 0]
                                       if {$sSymbolicTest == $aSchemaElement($sSchemaType)} {set bUnRegName TRUE}
                                 #  Has symbolic reference & orig name symbolic not in database - mod & unregister name then register name
                                    } elseif {$sSymbolicFromName != "" && $sNameFromSymbolic == ""} {
                                       pSetValue [list bRegister bUnRegName] TRUE
                                 #  Symbolic reference matches orig name symbolic & orig name symbolic matches name - mod
                                    } elseif {$sSymbolicFromName == $sSymbolic && $sNameFromSymbolic == $aCol(0)} {
                                 #  Symbolic reference does not match orig name symbolic & orig name symbolic does not match name - mod & unregister name & unregister name from symbolic then register name
                                    } elseif {$sSymbolicFromName != $sSymbolic} {
                                       pSetValue [list bRegister bUnRegName bUnRegSym] TRUE
                                    }
                                 }
                                 set sDescriptionActual [pQuery "" "print $aSchemaElement($sSchemaType) \042$aCol(0)\042 $sSystem select description dump"]
                              } else {
                                 set sModName ""
                              }
                              set sAddMod Modify
                              if {$bAdd} {set sAddMod "Add"}
                              pSetAction "$sAddMod $sSchemaType $aCol(0)"
# Analyze data file fields
                              if {$bDel != "TRUE"} {
                              	 set iReturn 0
                                 switch $sSchemaType {
                                      role - group {
                                       pAnalyzeUser
                                    } command - menu - channel - portal - inquiry - table - column - webform - field {
                                    	 set iReturn [pAnalyzeWebComp]
                                         #Modified below if statement for incident 360006 on 27 Aug 08   
                                    	 if {$iReturn && $bScan != "TRUE"} {
                                          exit 1
                                          return
                                       }
                                    } property {
                                       set iReturn [pAnalyzeProperty]
                                       #Modified below if statement for incident 360006 on 27 Aug 08
                                       if {$iReturn && $bScan != "TRUE"} {
                                          exit 1
                                          return
                                       }
                                    } dimension - unit {
                                       set iReturn [pAnalyzeDimension]
                                       #Modified below if statement for incident 360006 on 27 Aug 08
                                       if {$iReturn && $bScan != "TRUE"} {
                                          exit 1
                                          return
                                       }
                                    } default {
                                       eval "pAnalyze$aSchemaTitle($sSchemaType)"
                                    }
                                 }
                              }
# Compare data file to database and add or modify as required
                              if {$bScan != "TRUE"} {mql start transaction update}
                              set bUpdate FALSE
                              if { [ catch {
                                 if {$bDel} {
                                    pSetAction "Delete $sSchemaType $aCol(0)"
                                    set sSchemaDel $sSchemaType
                                    if {$sSchemaType == "webform"} {set sSchemaDel "form"}
                                    if {[pQuery "" "print $sSchemaDel \042$aCol(0)\042 $sSystem"] != ""} {
                                       pMqlCmd "delete $sSchemaDel \042$aCol(0)\042 $sSystem"
                                       catch {
                                          if {$aSymbolic($sSchemaDel|$aCol(0)) != ""} {
                                             set aSchemaName($aSymbolic($sSchemaDel|$aCol(0))) ""
                                             set aSymbolic($aSchemaElement($sSchemaDel)|$aCol(0)) ""
                                          }
                                       } sMsg
                                    }
                                 } else {
                                    if {$sSchemaType == "trigger" || $sSchemaType == "property"} {
                                       set sRegType $aCol(0)
                                       set sRegName $aCol(1)
                                    } else {
                                       set sRegType $aSchemaElement($sSchemaType)
                                       set sRegName $aCol(0)
                                    }
                                    if {$sSchemaType != "association" && $sSchemaType != "property" && $sSchemaType != "rule"} {
                                       if {$sRegType == "table"} {
                                          set lsSpinStamp [list 0 ""]
                                          if {[lsearch $lsTable $aCol(0)] >= 0} {set lsSpinStamp [split [pQuery 0 "print $sRegType \042$sRegName\042 $sSystem select modified property\134\133SpinnerAgent\134\135.value dump |"] |]}
                                       } else {
                                          set lsSpinStamp [split [pQuery "0|" "list $sRegType \042$sRegName\042 $sSystem select modified property\134\133SpinnerAgent\134\135.value dump |"] |]
                                       }
                                       set sModified [lindex $lsSpinStamp 0]
                                       set sSpinStamp [lindex $lsSpinStamp 1]
                                    }
                                    switch $sSchemaType {
                                       role - group {
                                       	  set iReturn [pProcessUser]
                                       } command - menu - channel - portal - inquiry - table - column - webform - field {
                                       	  set iReturn [pProcessWebComp]
                                       } dimension - unit {
                                       	  set iReturn [pProcessDimension]
                                       } default {
									   ######## Added By SL Team for Policy issue (Policy having branches is screwed up with User Agen being populated etc in Signature approver fields)#######
										if {$sSchemaType == "state" } {
										set sProcReturn [pProcess$aSchemaTitle($sSchemaType) $lsMasterSignatureList]
										 } else { 										 
                                          set iReturn [pProcess$aSchemaTitle($sSchemaType)]
                                       }
										 ######## END #######
										  }
                                       
                                    }
                                    #Modified below if statement for incident 360006 on 27 Aug 08
                                    if {$iReturn && $bScan != "TRUE"} {
                                       exit 1
                                       return
                                    }
                                    if {$bSkipElement != "TRUE"} {
                                       if {[lsearch [list state signature property column field unit trigger] $sSchemaType] < 0} {
                                          regsub -all "\\\n" $sDescriptionActual "<NEWLINE>" sDescriptionActual
                                          if {$bOverlay} {
                                             if {$aCol($aDescIndex($sSchemaType)) == "<NULL>"} {
                                                set aCol($aDescIndex($sSchemaType)) ""
                                             } elseif {$bAdd != "TRUE" && $aCol($aDescIndex($sSchemaType)) == ""} {
                                                set aCol($aDescIndex($sSchemaType)) $sDescriptionActual
                                             }
                                          }
                                          if {$bAdd || $aCol($aDescIndex($sSchemaType)) != $sDescriptionActual} {
                                             set aCol($aDescIndex($sSchemaType)) [pRegSubEvalEscape $aCol($aDescIndex($sSchemaType))]
                                             if {$bScan != "TRUE"} {
										                            regsub -all "<NEWLINE>" $aCol($aDescIndex($sSchemaType)) "\\\n" aCol($aDescIndex($sSchemaType))
                                                pMqlCmd "escape mod $aSchemaElement($sSchemaType) \042$aCol(0)\042 $sSystem description \042$aCol($aDescIndex($sSchemaType))\042"
                                             }
                                             set bUpdate TRUE
                                          }
                                          if {$sIcon != "" && $bScan != "TRUE" && $sSchemaType != "table" && $sSchemaType != "webform"} {mql mod $sSchemaType $aCol(0) icon "$sSpinDir/Pix/$sIcon"}
                                       }
                                       if {$bAdd != "TRUE" && $sModName != ""} {
                                          if {$aCol(0) != $sModName} {
                                             pMqlCmd "mod $aSchemaElement($sSchemaType) \042$aCol(0)\042 $sSystem name \042$sModName\042"
                                             set aSchChgName("$sSchemaType|$aCol(0)") $sModName
                                          }
                                       }
                                    }
                                    set bSkipElement FALSE
                                 }
                              } result ] != 0 } {
# Unsuccessful transaction
                                 pAppend "TRANSACTION NOT SUCCESSFUL!  $result$resultappend\n" FALSE
                                 set bModFlag TRUE
                                 if {$bScan != "TRUE"} {mql abort transaction}
                                 if {$bPercent != "TRUE"} {puts -nonewline "!"}
                                 set iLogFileErr [open $sLogFileError a+]
                                 puts $iLogFileErr "$sAction\n$result$resultappend"
                                 close $iLogFileErr
                                 if {!$bScan && [lsearch [list role group type menu webform interface] $sSchemaType] >= 0} {
                                    set bContinue TRUE
                                 }
                                 incr iErrCtr
                                 set lsTypeTest ""
                                 if {[string first "<MULTILINE." $slsType] > -1} {
                                    set lsTypeTest $lsBufferMulti
                                 } else {
                                    lappend lsTypeTest $slsType
                                 }
                                 foreach sTypeTest $lsTypeTest {
                                    regsub -all "\042" $sTypeTest "" sTypeTest
                                    regsub -all "\134\133" $sTypeTest "" sTypeTest
                                    regsub -all "\134\135" $sTypeTest "" sTypeTest
                                    lappend lsErrorType($iCounter) $sTypeTest
                                 }
                              } else {
# Successful transaction
                                 if {$bUpdate} {
                                    if {$bScan != "TRUE"} {pAppend "# Transaction successful.\n" FALSE}
                                    set bModFlag TRUE
                                    if {$bAdd} {
                                       incr iAddCtr
                                       incr iAddCtrTot
                                       set sOut "+"
                                    } elseif {$bDel} {
                                       incr iDelCtr
                                       incr iDelCtrTot
                                       set sOut "-"
                                    } else {
                                       incr iModCtr
                                       incr iModCtrTot
                                       set sOut ":"
                                    }
                                    if {$bPercent != "TRUE" && ($sSchemaType != "program" || $aCol(3) != "java")} {puts -nonewline "$sOut"}
                                    if {$bScan != "TRUE"} {mql commit transaction}
                                    if {$bDel != "TRUE"} {
# Spinner registration
                                       if {$sModName != ""} {set sRegName $sModName}
                                       if {$sSchemaType != "association" && $sSchemaType != "property" && $sSchemaType != "rule"} {
                                       	  set sNewModified [pQuery 0 "print $sRegType \042$sRegName\042 $sSystem select modified dump"]
                                       	  set sSpinnerAgent [pQuery "" "print $sRegType \042$sRegName\042 $sSystem select property\134\133SpinnerAgent\134\135.value dump"]
                                       	  if {$sNewModified != 0} {
                                             if {$sSpinStamp == "" || $sSpinnerAgent == ""} {
                                                if {$bScan != "TRUE"} {
                                                   catch {eval "mql add property SpinnerAgent on $sRegType \042$sRegName\042 $sSystem value \042$sNewModified\042"} sMsg
                                                }
                                             } else {
                                                if {$bScan != "TRUE"} {
                                                   catch {eval "mql mod property SpinnerAgent on $sRegType \042$sRegName\042 $sSystem value \042$sNewModified\042"} sMsg
                                                }
# Timestamp compare fix for Incident 358324
                                                if {[catch {set iClockScan [expr [clock scan $sModified] - [clock scan $sSpinStamp]]} sMsg] == 0} {
                                                   if {$iClockScan > 1} {
                                                   			pWriteWarningMsg "\nWARNING: '$sRegType' '$sRegName' was modified on '$sModified' after last Spinner mod on '$sSpinStamp'"
                                                   }
                                                }
                                             }
                                          }
                                       }
# Compile program if JPO
                                       if {$bCompile} {
                                          set sTempName $aCol(0)
                                          if {$sModName != ""} {set sTempName $sModName}
                                          if {$sSchemaType == "program"} {
                                             if {$aCol(3) == "java"} {
                                                if {$bScan != "TRUE"} {
                                                   catch {mql compile program $sTempName force update} sMsg
						   #Added for incident 363724 on 12/16/2008 - start
						   catch {mql compile program $sTempName} sMsg
   						   #Added for incident 363724 on 12/16/2008 - end
                                                   if {[string first "already compiled" $sMsg] < 0} {
                                                      pWriteWarningMsg "\nWARNING: JPO '$sTempName' compile error - review 'mxtrace.log'"
                                                   } elseif {$bPercent != "TRUE"} {
                                                      puts -nonewline ";"
                                                   }
                                                }  
                                                pAppend "mql compile program $sTempName force update\n" FALSE
                                             }
                                          }
                                       }
                                    }
                                 } else {
                                    if {$bScan != "TRUE" && $bShowModOnly != "TRUE"} {pAppend " - not required" TRUE}
                                    if {$bPercent != "TRUE"} {puts -nonewline "."}
                                    incr iSkipCtr
                                    incr iSkipCtrTot
                                    if {$bScan != "TRUE"} {mql commit transaction}
                                 }
# Registrations
                                 if {$bReg && $bAEF} {
                                    if {$bUnRegName} {
                                       pUnRegisterSchema $aSchemaElement($sSchemaType) $sModName $aSymbolic($aSchemaElement($sSchemaType)|$aCol(0))
                                       array set aSymbolic [list "$aSchemaElement($sSchemaType)|$sModName" ""]
                                       if {$bUnRegSym != "TRUE"} {array set aSchemaName [list $sSymbolic ""]}
                                    }
                                    if {$bUnRegSym} {
                                       set lsSchemaSymbolic [split $aSchemaName($sSymbolic) |]
                                       foreach sSchemaSymbolic $lsSchemaSymbolic {
                                          pUnRegisterSchema $aSchemaElement($sSchemaType) $sSchemaSymbolic $sSymbolic
                                          array set aSymbolic [list "$aSchemaElement($sSchemaType)|$sSchemaSymbolic" ""]
                                       }
                                       array set aSchemaName [list $sSymbolic ""]
                                    }
                                    if {$bRegister} {
                                       pRegisterSchema $aSchemaElement($sSchemaType) $sModName $aCol(1) $sSymbolic
                                       array set aSymbolic [list "$aSchemaElement($sSchemaType)|$sModName" $sSymbolic]
                                       array set aSchemaName [list $sSymbolic $sModName]
                                    }
                                 }
                              }
                              if {$bPercent && $iTenPercent < 10 && [expr $iAddCtr + $iModCtr + $iDelCtr + $iSkipCtr + $iErrCtr + $iMultiCtr] > [expr $iTenPercent * $iPercent]} {
                                 pWriteCue
                                 incr iTenPercent
                              }
                           }
                        }
                     }
# Loop if error and continue loop if errors get corrected
                     if {$bContinue} {
                        if {($iModCtr == 0 && $iAddCtr == 0 & $iDelCtr == 0) || $iPrevErrCtr == $iErrCtr} {
                           set bContinue FALSE
                        } else {
                           incr iCounter
                           set iPrevErrCtr $iErrCtr
                           puts -nonewline "\nloop $iCounter"
                           if {$bContinueOnError != "TRUE"} {
                              set iLogFileErr [open $sLogFileError w]
                              close $iLogFileErr
                           }
                           set bRepeat TRUE
                        }
                     }
                     if {$bPercent} {pWriteCue}
                  }
# Process logs
                  if {$iAddCtr > 0 || $iModCtr > 0 || $iDelCtr > 0 || $iSkipCtr > 0 || $iErrCtr > 0} {puts ""}
                  set pFile [open $sLogFilePath a+]
                  puts $pFile $sFile
                  close $pFile
                  puts "$iAddCtrTot adds, $iModCtrTot mods, $iDelCtrTot dels, $iSkipCtrTot skips, $iRegisterCounter regs"
                  if {$iErrCtr > 0} {
                     puts "\n$iErrCtr error(s) generated - Review log file '$sLogFileError', correct problem(s) and restart"
                     if {$bScan != "TRUE" && $bContinueOnError != "TRUE"} {break}
                  } elseif {$bScan != "TRUE"} {
                     pSpinDone $sSchemaType
                     if {$bContinueOnError != "TRUE"} {
                        set iLogFileErr [open $sLogFileError w]
                        close $iLogFileErr
                     }
                  }
               }
# End Business Spinner
            }
            if {$bProcess && !$iErrCtr} {
               set lsSchemaType $lsSchemaElement
            } else {
               set bProcess FALSE
            }
         }
      } else {
         puts "No changes required -- all data files have already been processed or no data files found.\nTo force processing, use the parameter 'force': exec prog emxSpinnerAgent.tcl force;"
         set bLogMsg FALSE
      }
      if {$sWarning != ""} {
         set iLogFileErr [open $sLogFileError a+]
         puts $iLogFileErr $sWarning
      } else { 
         set iLogFileErr [open $sLogFileError r+]
         set sLogFileMsg [read $iLogFileErr]
         if {$sLogFileMsg == ""} {puts $iLogFileErr "SpinnerAgent finished with no errors."}
      }
      close $iLogFileErr
      if {$bLogMsg} {puts "\n...SpinnerAgent processing finished - log file generated: $sLogFilePath"}
      set bLogMsg TRUE
      if {$sLogFileMsg != ""} {break}
   }
}

